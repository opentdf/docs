{"searchDocs":[{"title":"Feature Matrix","type":0,"sectionRef":"#","url":"/pr-172/appendix/matrix","content":"Feature Matrix The following table shows the features of the different versions of the library. note Questions regarding specific features should be raised in the GitHub Discussions. The following tables utilize the following terms: Lifecycle: Alpha: The feature is in the early stages of development.Beta: The feature is in the later stages of development.GA: The feature is ready for production use. State: Planned: The feature is planned but not yet started.Unstable: The feature is in development and may change.Stable: The feature is ready for production use. Support: Official: The service, feature, or library is officially supported by the maintainers.Community: The service, feature, or library is supported by the community. Community-supported features will have a link to the community repository and not be included in the OpenTDF organization. Platform​ The platform is made of different services. This matrix captures the high-level state of the various service features. Service\tFeature\tStateAuthorization\tAccess\tStable Key Access\tRewrap\tStable Key Access\tPublic Key\tStable Key Access\tRotate\tStable Policy\tManage Attribute Namespaces\tStable Policy\tManage Attribute Definitions\tStable Policy\tManage Attribute Values\tStable Policy\tManage Key Access Server Registry\tStable Policy\tManage Key Access Server Grants\tStable Policy\tManage Subject Mappings\tStable Policy\tManage Subject Condition Sets\tStable Policy\tManage Resource Mappings\tStable Policy\tManage Resource Mapping Groups\tUnstable Policy\tUnsafe Mutations1\tStable SDK​ Feature matrix for the different SDK versions. Go\tJava\tJavaScriptLifecycle\tGA\tGA\tGA Support2\tOfficial\tOfficial\tOfficial Encrypt/Decrypt3\tStable\tStable\tStable - ZTDF4\tStable\tStable\tStable - ABAC5\tStable\tStable\tStable - Key Access Grants6\tStable\tStable\tStable Service APIs7\tStable\tStable\tPlanned - Authorization8\tStable\tStable\tPlanned - Key Access Server9\tStable\tStable\tPlanned - Policy: Attributes10\tStable\tStable\tPlanned FAQ​ Why isn't language supported as an SDK? To ensure we can provide the best support for the SDKs, we have decided to focus on a limited scope of languages which meet our criteria such as performance and environment. Python and C# were supported in the first version of the platform, but as we assessed our ability to maintain the SDKs, we decided to focus on the most popular and performant languages. We are open to community contributions to support these languages. Where can I get updates on the state of services and SDKs? The best place to get updates on the state of the services and SDKs is the OpenTDF GitHub Discussions. Footnotes​ Unsafe Mutations are operations that can cause unintended consequences to data security. This feature will enable these operations (which are prevented in the management APIs) and bind their execution to audit events. ↩ Support is the level of support for the SDK (Official, Community). ↩ Encrypt is the ability to encrypt data. ↩ Support for the Zero Trust Data Format utilizing JSON manifests and assertation. ↩ ABAC is Attribute Based Access Control. ↩ Autoconfigure for key splits ↩ Service APIs are APIs that are provided by the library to interact with the service. ↩ Authorization APIs for managing authorization policies. ↩ Key Access Server (KAS) APIs for accessing key management. ↩ APIs for managing policy attributes proto. ↩","keywords":"","version":"Next"},{"title":"Architecture","type":0,"sectionRef":"#","url":"/pr-172/architecture","content":"Architecture OpenTDF is built on a flexible, service-oriented architecture designed for robust and fine-grained access control. The platform consists of four core components that work together to protect data throughout its lifecycle. This architecture aligns with the well-established National Institute of Standards and Technology (NIST) model for Attribute-Based Access Control (ABAC), ensuring a standards-based and interoperable approach. Core Platform Components​ The four main services of the OpenTDF platform are the Policy Service, Authorization Service, Entity Resolution Service, and the Key Access Server. Policy Service​ The Policy Service is where all access control policies are defined and managed. It provides the tools and APIs to create a rich set of policies that govern data access. This includes not only attributes and their values, but also the definitions of actions, obligations, and key access mappings. In the context of the NIST ABAC model, the Policy Service functions as the Policy Administration Point (PAP). Authorization Service​ The Authorization Service is the core decision-making engine of the platform. It is responsible for evaluating the rich policies from the Policy Service against a set of attributes to render an authorization decision. In the context of the NIST ABAC model, it functions as the Policy Decision Point (PDP). Entity Resolution Service (ERS)​ The Entity Resolution Service is responsible for gathering the attributes about a subject needed for a decision. By default, it can derive attributes from claims in an authentication token. Optionally, it can be configured to connect to external attribute sources (LDAP, SQL) to &quot;hydrate&quot; the entity with more attributes. In the context of the NIST ABAC model, the ERS functions as the Policy Information Point (PIP). Key Access Server (KAS)​ The Key Access Server (KAS) enforces access control decisions. Its role is more extensive than a typical enforcement point: Cryptographic Enforcement: It enforces decisions by granting or withholding cryptographic keys for TDF decryption.Encryption Enablement: It manages key exchanges and enables various TDF encryption modes. In the context of the NIST ABAC model, the KAS functions as the Policy Enforcement Point (PEP). Furthermore, the OpenTDF platform is designed for flexibility. Developers can build and integrate their own custom PEPs. These custom enforcement points can leverage the platform's robust Authorization (PDP) and Policy (PAP) services while implementing enforcement logic tailored to specific applications. These custom PEPs can also optionally interface with the KAS to take advantage of its powerful cryptographic capabilities.","keywords":"","version":"Next"},{"title":"otdfctl auth","type":0,"sectionRef":"#","url":"/pr-172/components/cli/auth","content":"otdfctl auth auth - Manage local authentication session Synopsis otdfctl auth Description [!NOTE] Requires experimental profiles feature. (Linux not yet supported. Windows is brittle.) The auth commands facilitate the process of authenticating the user with the system using profiles to store the credentials.","keywords":"","version":"Next"},{"title":"otdfctl auth clear-client-credentials","type":0,"sectionRef":"#","url":"/pr-172/components/cli/auth/clear-client-credentials","content":"otdfctl auth clear-client-credentials clear-client-credentials - Clear the cached client credentials Synopsis otdfctl auth clear-client-credentials [flags] Description [!WARNING] Deprecated. Use the profile subcommand to manage profiles and credentials. Options --all &lt;all&gt; Deprecated -- see the `profile` subcommand (required: false)","keywords":"","version":"Next"},{"title":"otdfctl auth client-credentials","type":0,"sectionRef":"#","url":"/pr-172/components/cli/auth/client-credentials","content":"otdfctl auth client-credentials client-credentials - Authenticate to the platform with the client-credentials flow Synopsis otdfctl auth client-credentials &lt;client-id&gt; [client-secret] Description [!NOTE] Requires experimental profiles feature. OS\tKeychain\tStateMacOS\tKeychain\tStable Windows\tCredential Manager\tAlpha Linux\tSecret Service\tNot yet supported Allows the user to login in via Client Credentials flow. The client credentials will be stored safely in the OS keyring for future use. Examples​ Authenticate with client credentials (id and secret provided interactively) otdfctl auth client-credentials Authenticate with client credentials (secret provided interactively) otdfctl auth client-credentials &lt;client-id&gt; Authenticate with client credentials (secret provided as argument) otdfctl auth client-credentials &lt;client-id&gt; &lt;client-secret&gt; ","keywords":"","version":"Next"},{"title":"otdfctl auth login","type":0,"sectionRef":"#","url":"/pr-172/components/cli/auth/login","content":"otdfctl auth login login - Open a browser and login Synopsis otdfctl auth login [flags] Description [!NOTE] Requires experimental profiles feature. OS\tKeychain\tStateMacOS\tKeychain\tStable Windows\tCredential Manager\tAlpha Linux\tSecret Service\tNot yet supported Authenticate for use of the OpenTDF Platform through a browser (required). Provide a specific public 'client-id' known to support the Auth Code PKCE flow and recognized by the OpenTDF Platform (e.g. cli-client). The OIDC Access Token will be stored in the OS-specific keychain by default (Linux not yet supported). Options -i, --client-id &lt;client-id&gt; A clientId for a public (no-secret) IdP client supporting the auth code flow from any localhost port (e.g. cli-client) (required: true) -p, --port &lt;port&gt; A preferred port number to faciliate the auth flow process. (required: false)","keywords":"","version":"Next"},{"title":"CLI - otdfctl","type":0,"sectionRef":"#","url":"/pr-172/components/cli","content":"CLI - otdfctl otdfctl - otdfctl - OpenTDF Control Tool Synopsis otdfctl [flags] Description Note: Starting with version 1.67 of go-grpc, ALPN (Application-Layer Protocol Negotiation) is now enforced. To work around this, you can either: Disable ALPN enforcement by setting the following environment variable: export GRPC_ENFORCE_ALPN_ENABLED=falseEnable HTTP/2 on your load balancer. Options --version &lt;version&gt; show version (required: false) --profile &lt;profile&gt; profile to use for interacting with the platform (required: false) --host &lt;host&gt; Hostname of the platform (i.e. https://localhost) (required: false) --tls-no-verify &lt;tls-no-verify&gt; disable verification of the server's TLS certificate (required: false) --log-level &lt;log-level&gt; log level, default level is INFO (required: false) --with-access-token &lt;with-access-token&gt; access token for authentication via bearer token (required: false) --with-client-creds-file &lt;with-client-creds-file&gt; path to a JSON file containing a 'clientId' and 'clientSecret' for auth via client-credentials flow (required: false) --with-client-creds &lt;with-client-creds&gt; JSON string containing a 'clientId' and 'clientSecret' for auth via client-credentials flow (required: false) --json &lt;json&gt; output in JSON format (required: false) --debug &lt;debug&gt; DEPRECATED Use log-level. Setting this will enable debug logs (required: false)","keywords":"","version":"Next"},{"title":"otdfctl auth print-access-token","type":0,"sectionRef":"#","url":"/pr-172/components/cli/auth/print-access-token","content":"otdfctl auth print-access-token print-access-token - Print the cached OIDC access token (if found) Synopsis otdfctl auth print-access-token [flags] Description [!NOTE] Requires experimental profiles feature. OS\tKeychain\tStateMacOS\tKeychain\tStable Windows\tCredential Manager\tAlpha Linux\tSecret Service\tNot yet supported Retrieves a new OIDC Access Token using the client credentials and prints to stdout if found. Options --json &lt;json&gt; Print the full token in JSON format (required: false)","keywords":"","version":"Next"},{"title":"otdfctl config output","type":0,"sectionRef":"#","url":"/pr-172/components/cli/config/output","content":"otdfctl config output output - Define the configured output format Synopsis otdfctl config output [flags] Description DEPRECATED​ Please use profile set-output-format instead Options --format &lt;format&gt; 'json' or 'styled' as the configured output format (required: false) (default: styled)","keywords":"","version":"Next"},{"title":"Authorization Service","type":0,"sectionRef":"#","url":"/pr-172/components/authorization","content":"Authorization Service The Authorization service makes access decisions based on Attribute-Based Access Control (ABAC) policies and evaluates subject mappings and attribute definition rules to determine allowed actions on attribute values for specified entities. An entity is any being or principal interacting with the platform. A person entity (PE) represents an actual user, while a non-person entity (NPE) represents a system or program interacting on behalf of a user/organization or via automation. Entities are categorized into two types: Subject entities: These include PEs or NPEs and are evaluated in access decisions.Environment entities: These are excluded from access decisions. Two versions of Authorization Service are currently served simultaneously by the platform, with v1 being deprecated soon: v2v1 v2 (latest)​ Changes​ Version 2 of Authorization Service introduced the following changes: Consideration of policy actions from subject mappings in entitlement decisionsAPI structure and clarity improvements entity identifiermultiplexing design within decisioningremoval of scopes when retrieving entitlements, in deference to decision APIs Removal of configurable custom Rego support Entity Identifier​ The entity identifier is a request proto object allowing multiple structures representing an entity to stand in as the entity in an Auth Service request: an Entity Chain (the response from an entityresolutionservice.v2.CreateEntityChainsFromTokens call)a Token (access token JWT)the FQN of a Registered Resource Value (EXPERIMENTAL) Resource​ The resource is a request proto object allowing multiple structures representing a resource to stand in as the resource in an Auth Service Decision request: a list of Attribute Values FQNsthe FQN of a Registered Resource Value (EXPERIMENTAL) GetEntitlements​ The GetEntitlements endpoint takes an Entity Identifier and returns the entitled actions per attribute value back (entitlements). Entitlements are driven by subject mappings, as described in the policy documentation, and the entity data returned by the entity resolution service. The request flag with_comprehensive_hierarchy will drive response behavior for attribute values on definitions with a hierarchy rule. If the flag is omitted or passed with value false, the response will contain strictly the resolved subject mappings' entitled actions for each attribute value. However, if it is set to true in a request, actions will propagate down hierarchically to each lower-hierarchy attribute value within the response. This propagation behavior is the same utilized during GetDecision flows to drive ABAC entitlement between entities and resources. Say there are three subject mappings for a single entity as the EntityIdentifier ephemeral ID entity_xyz: contains actions read, update and a mapped attribute value https://example.com/attr/department/value/engineering on an ANY_OF definitioncontains action read and a mapped attribute value https://example.com/attr/level/value/higher on a HIERARCHY definition containing values higher, medium, lower, which therefore gets propagated down comprehensivelycontains action delete and a mapped attribute value https://example.com/attr/level/value/lower on a HIERARCHY definition containing values higher, medium, lower The GetEntitlements response would look like the below if with_comprehensive_hierarchy is set to true: { &quot;entitlements&quot;:[ { &quot;ephemeral_id&quot;:&quot;entity_xyz&quot;, &quot;actions_per_attribute_value_fqn&quot;:{ &quot;https://example.com/attr/level/value/higher&quot;:{ &quot;actions&quot;:[ { &quot;id&quot;:&quot;&lt;action policy object UUID&gt;&quot;, &quot;name&quot;:&quot;read&quot; } ] }, &quot;https://example.com/attr/level/value/medium&quot;:{ &quot;actions&quot;:[ { &quot;id&quot;:&quot;&lt;action policy object UUID&gt;&quot;, &quot;name&quot;:&quot;read&quot; } ] }, &quot;https://example.com/attr/level/value/lower&quot;:{ &quot;actions&quot;:[ { &quot;id&quot;:&quot;&lt;action policy object UUID&gt;&quot;, &quot;name&quot;:&quot;delete&quot; }, { &quot;id&quot;:&quot;&lt;action policy object UUID&gt;&quot;, &quot;name&quot;:&quot;read&quot; } ] }, &quot;https://example.com/attr/department/value/engineering&quot;:{ &quot;actions&quot;:[ { &quot;id&quot;:&quot;&lt;action policy object UUID&gt;&quot;, &quot;name&quot;:&quot;read&quot; }, { &quot;id&quot;:&quot;&lt;action policy object UUID&gt;&quot;, &quot;name&quot;:&quot;update&quot; } ] }, } } ] } GetDecision, GetDecisionMultiResource, GetDecisionBulk​ The GetDecision endpoints evaluate access control permissions over entities, actions, and resources. The request/response protos define structures for more specific decisioning flows than the v1 catch-all GetDecisions endpoint. In all decision flows, the access logic is as follows: given the Entity Identifier, which Subject Mappings in Policy are relevant and resolve to true?given the Subject Mappings, which contained Actions are entitled on which Attribute Values?given the entitled Actions per each Attribute Value, which Attribute Definitions are relevant to the Resource attributes?given the relevant entitlements and resource attributes, are the attribute definition rules satisfied by the entity's entitlements for the requested action name? In other words, a Decision will be to deny if: no subject mappings apply to an entitysome subject mappings apply to an entity, but none containing the specific requested actionsome subject mappings apply to an entity, but they only entitle the specific requested action on attribute values other than those of the requested resourcethe subject mappings entitle some of the resource's attribute values for the requested action, but not enough to satisfy the attribute definition rule (ANY_OF, ALL_OF, HIERARCHY) given the requested resource's attribute values Endpoints: GetDecision: can this entity take this action on this resource? one Entity Identifierone Action (name is required)one Resource GetDecisionMultiResource: can this entity take this action on these resources? one Entity Identifierone Action (name is required)multiple Resources GetDecisionBulk: more performant batch processing of multiple GetDecisionMultiResource requests useful for multiple entitiesuseful for multiple actions v1 (soon to be deprecated)​ GetEntitlements​ The GetEntitlements endpoint takes a list of entities and returns the attributes to which each entity is entitled. Entitlements are based on subject mappings, as described in the policy documentation, and the entity data returned by the entity resolution service. Entities​ Entities can be identified using various methods, as shown in the proto definition: message Entity { string id = 1; // Ephemeral ID for tracking between request and response // Standard entity types supported by the platform oneof entity_type { string email_address = 2; string user_name = 3; string remote_claims_url = 4; string uuid = 5; google.protobuf.Any claims = 6; EntityCustom custom = 7; string client_id = 8; } // Categories for entity classification enum Category { CATEGORY_UNSPECIFIED = 0; CATEGORY_SUBJECT = 1; CATEGORY_ENVIRONMENT = 2; } Category category = 9; } Entities are passed to the entity resolution service's Resolve method to be processed. An example GetEntitlements request: { &quot;entities&quot;: [ { &quot;id&quot;: &quot;e1&quot;, &quot;emailAddress&quot;: &quot;alice@example.com&quot;, &quot;category&quot;: &quot;CATEGORY_SUBJECT&quot; }, { &quot;id&quot;: &quot;e2&quot;, &quot;userName&quot;: &quot;bob&quot;, &quot;category&quot;: &quot;CATEGORY_SUBJECT&quot; } ], &quot;scope&quot;: { &quot;attributeValueFqns&quot;: [ &quot;https://example.com/attr/attr1/value/value1&quot;, &quot;https://example.com/attr/attr1/value/value2&quot; ] } } The first input is a list of entities as defined above. The second is an optional attribute scope; if provided, the service will only return the entitlements contained within the specified scope. The attributes provided in the scope must be formatted as FQNs. Below is an example response to the above GetEntitlements request: { &quot;entitlements&quot;: [ { &quot;entity_id&quot;: &quot;e1&quot;, &quot;attribute_value_fqns&quot;: [ &quot;https://example.com/attr/attr1/value/value1&quot; ] }, { &quot;entity_id&quot;: &quot;e2&quot;, &quot;attribute_value_fqns&quot;: [ &quot;https://example.com/attr/attr1/value/value1&quot;, &quot;https://example.com/attr/attr1/value/value2&quot; ] } ] } The entities in the response can be mapped back to the original input using the entity ID. The &quot;attribute_value_fqns&quot; field includes a list of attribute FQNs to which that particular entity has been entitled. If no scope was provided, this field will include ALL of the attribute entitlements for that entity. GetDecisions​ The GetDecisions endpoint evaluates access control rules for one or more entity chains and resources. It checks whether entities have permission to perform specified actions on resources, based on provided attributes. An example GetDecisions request looks like this: { &quot;decisionRequests&quot;: [ { &quot;actions&quot;: [ { &quot;standard&quot;: &quot;STANDARD_ACTION_DECRYPT&quot; } ], &quot;entityChains&quot;: [ { &quot;entities&quot;: [ { &quot;id&quot;: &quot;e1&quot;, &quot;emailAddress&quot;: &quot;bob@example.com&quot;, &quot;category&quot;: &quot;CATEGORY_SUBJECT&quot; }, { &quot;id&quot;: &quot;e2&quot;, &quot;userName&quot;: &quot;alice&quot;, &quot;category&quot;: &quot;CATEGORY_SUBJECT&quot; } ], &quot;id&quot;: &quot;ec1&quot; }, { &quot;entities&quot;: [ { &quot;id&quot;: &quot;e1&quot;, &quot;clientId&quot;: &quot;client1&quot;, &quot;category&quot;: &quot;CATEGORY_ENVIRONMENT&quot; } ], &quot;id&quot;: &quot;ec2&quot; } ], &quot;resourceAttributes&quot;: [ { &quot;attributeValueFqns&quot;: [ &quot;https://example.com/attr/attr1/value/value1&quot; ], &quot;resourceAttributesId&quot;: &quot;ra-set-1&quot; }, { &quot;attributeValueFqns&quot;: [ &quot;https://example.com/attr/attr1/value/value2&quot;, &quot;https://example.com/attr/attr1/value/value3&quot; ], &quot;resourceAttributesId&quot;: &quot;ra-set-2&quot; } ] } ] } In this example, there are two entity chains: one with users Bob and Alice (both categorized as subject entities) and the other with Client1 (categorized as an environment entity). The request evaluates whether these entity chains have permission to DECRYPT two resources with specific attributes. An example GetDecisions response: { &quot;decision_responses&quot;: [ { &quot;entity_chain_id&quot;: &quot;ec1&quot;, &quot;resource_attributes_id&quot;: &quot;ra-set-1&quot;, &quot;action&quot;: { &quot;standard&quot;: &quot;STANDARD_ACTION_DECRYPT&quot; }, &quot;decision&quot;: &quot;DECISION_DENY&quot;, &quot;obligations&quot;: [] }, { &quot;entity_chain_id&quot;: &quot;ec2&quot;, &quot;resource_attributes_id&quot;: &quot;ra-set-1&quot;, &quot;action&quot;: { &quot;standard&quot;: &quot;STANDARD_ACTION_DECRYPT&quot; }, &quot;decision&quot;: &quot;DECISION_PERMIT&quot;, &quot;obligations&quot;: [] }, { &quot;entity_chain_id&quot;: &quot;ec1&quot;, &quot;resource_attributes_id&quot;: &quot;ra-set-2&quot;, &quot;action&quot;: { &quot;standard&quot;: &quot;STANDARD_ACTION_DECRYPT&quot; }, &quot;decision&quot;: &quot;DECISION_PERMIT&quot;, &quot;obligations&quot;: [] }, { &quot;entity_chain_id&quot;: &quot;ec2&quot;, &quot;resource_attributes_id&quot;: &quot;ra-set-2&quot;, &quot;action&quot;: { &quot;standard&quot;: &quot;STANDARD_ACTION_DECRYPT&quot; }, &quot;decision&quot;: &quot;DECISION_PERMIT&quot;, &quot;obligations&quot;: [] } ] } In this response, there are four entries — one for each combination of entity chain and resource attribute set. The decision determines whether an entity chain is permitted to access resources with a given attribute set. For example, Bob and Alice do not have access to &quot;ra-set-1&quot;, but Client1, being an environment entity, is automatically granted DECISION_PERMIT because environment entities are excluded from attribute-based decisions.","keywords":"","version":"Next"},{"title":"otdfctl auth logout","type":0,"sectionRef":"#","url":"/pr-172/components/cli/auth/logout","content":"otdfctl auth logout logout - Clear credentials from profile Synopsis otdfctl auth logout Description [!NOTE] Requires experimental profiles feature. OS\tKeychain\tStateMacOS\tKeychain\tStable Windows\tCredential Manager\tAlpha Linux\tSecret Service\tNot yet supported Removes any auth credentials (Client Credentials or an Access Token from a login) from the current profile.","keywords":"","version":"Next"},{"title":"otdfctl config","type":0,"sectionRef":"#","url":"/pr-172/components/cli/config","content":"otdfctl config config - Manage Configuration Synopsis otdfctl config Description DEPRECATED​ Please use profile set-output-format instead","keywords":"","version":"Next"},{"title":"otdfctl dev design-system","type":0,"sectionRef":"#","url":"/pr-172/components/cli/dev/design-system","content":"otdfctl dev design-system design-system - Design System Synopsis otdfctl dev design-system Description The design system is a collection of design tokens, components, and guidelines that are used to create a consistent user experience across all of the CLI's interfaces. The design system is a living document and is subject to change as the CLI evolves.","keywords":"","version":"Next"},{"title":"otdfctl decrypt","type":0,"sectionRef":"#","url":"/pr-172/components/cli/decrypt","content":"otdfctl decrypt decrypt [file] - Decrypt a TDF file Synopsis otdfctl decrypt [flags] Description Decrypt a Trusted Data Format (TDF) file and output the contents to stdout or a file in the current working directory. The first argument is the TDF file with path from the current working directory being decrypted. Examples​ Various ways to decrypt a TDF file # decrypt file and write to standard output otdfctl decrypt hello.txt.tdf # decrypt file and write to hello.txt file otdfctl decrypt hello.txt.tdf -o hello.txt # decrypt piped TDF content and write to hello.txt file cat hello.txt.tdf | otdfctl decrypt -o hello.txt Advanced piping is supported $ echo &quot;hello world&quot; | otdfctl encrypt | otdfctl decrypt | cat hello world Session Key Algorithm -- EXPERIMENTAL​ The session-key-algorithm specifies the algorithm to use for the session key. The available options are (default: rsa:2048): rsa:2048ec:secp256r1ec:secp384r1ec:secp521r1 Example # Decrypt a file using the ec:secp256r1 algorithm for the session key # EXPERIMENTAL otdfctl decrypt hello.txt --session-key-algorithm ec:secp256r1 ZTDF Assertion Verification (experimental)​ To verify the signed assertions (metadata bound to the TDF), you can provide verification keys. The supported assertion signing algorithms are HS256 and RS256 so the keys provided should either be an HS256 key or a public RS256 key. # decrypt file and write to standard output otdfctl decrypt hello.txt.tdf --with-assertion-verification-keys my_assertion_verification_keys.json Where my_assertion_verification_keys.json looks like: {&quot;keys&quot;:{&quot;assertion1&quot;:{ &quot;alg&quot;:&quot;HS256&quot;,&quot;key&quot;:&quot;k0cn4xBcY+49z5gs4OHUs/kbQ3/T8p+uUW9pIQ/9aqE=&quot;},&quot;assertion2&quot;:{ &quot;alg&quot;:&quot;RS256&quot;,&quot;key&quot;:&quot;-----BEGIN PUBLIC KEY-----\\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCsgKCAQEAmr0wRsdXN0O9NiltxoGy\\nC6ZYwHbdiPVzvOnm9ven5g7Fpm3HOmygdi021WX1OlSua+OSrXGPjM2xbY3LTrFH\\nQXQEITjraXQRp5vlKDbBnOrtjYDaKazBXgTYVdelE4AIAuQaGoTudMasHBGiLPEW\\niTL4ySec0NzHn2s72Q4hn5/KJpIJOGqj0SlNViufdNylkjrJ3apoYFv1Mhwi3EF/\\niFZQ5encDDJmcG/UYF3msbuHRzArJJQ733BNRvicWF/nqixKxprvm8Ts8a54tr8N\\nZ7cEu1u5G6AY/pZFGk4ml8q3v5o1ja7xw2dgpJlS8Tl88tUzs+7GG8Ib8n7mHqeP\\nTQIDAQAB\\n-----END PUBLIC KEY-----\\n&quot;}}} If no verification keys are provided, the SDK will default to verifying using the payload key. If the assertions were not signed with the payload key, the decrypt call will fail. Options -o, --out &lt;out&gt; The file destination for decrypted content to be written instead of stdout. (required: false) -t, --tdf-type &lt;tdf-type&gt; Deprecated. TDF type is now auto-detected. (required: false) --no-verify-assertions &lt;no-verify-assertions&gt; disable verification of assertions (required: false) --session-key-algorithm &lt;session-key-algorithm&gt; EXPERIMENTAL: The type of session key algorithm to use for decryption (required: false) (default: rsa:2048) --with-assertion-verification-keys &lt;with-assertion-verification-keys&gt; EXPERIMENTAL: path to JSON file of keys to verify signed assertions. See examples for more information. (required: false) --kas-allowlist &lt;kas-allowlist&gt; A custom allowlist of comma-separated KAS Urls, e.g. `https://example.com/kas,http://localhost:8080`. If none specified, the platform will use the list of KASes in the KAS registry. To ignore the allowlist, use a quoted wildcard e.g. `--kas-allowlist '*'` **WARNING:** Bypassing the allowlist may expose you to potential security risks, as untrusted KAS URLs could be used. (required: false)","keywords":"","version":"Next"},{"title":"otdfctl dev selectors","type":0,"sectionRef":"#","url":"/pr-172/components/cli/dev/selectors","content":"otdfctl dev selectors selectors - Selectors Synopsis otdfctl dev selectors Description Commands to generate and test selectors on Subject Entity Representations. For more information, see the help manual for each subcommand or additional context within Subject Condition Sets. Aliases sel","keywords":"","version":"Next"},{"title":"Flattening-syntax","type":0,"sectionRef":"#","url":"/pr-172/components/cli/dev/selectors/test","content":"test - Test resolution of a set of selector expressions for keys and values of a Subject Context. Synopsis otdfctl dev selectors test [flags] Description Test a subject Entity Representation as a JWT or JSON object, such as that provided by an Identity Provider (idP), LDAP, or OIDC Access Token JWT, against provided selectors employing flattening syntax to validate their resolution to field values on the subject's entity representation. Flattening-syntax The platform maintains a very simple flattening library such that the below structure flattens into the key/value pairs beneath. Original: { &quot;key&quot;: &quot;abc&quot;, &quot;something&quot;: { &quot;nested&quot;: &quot;nested_value&quot;, &quot;list&quot;: [&quot;item_1&quot;, &quot;item_2&quot;] } } Flattened: Selector\tValue\tSignificance&quot;.key&quot;\t&quot;abc&quot;\tspecified field &quot;.something.nested&quot;\t&quot;nested_value&quot;\tnested field &quot;.something.list[0]&quot;\t&quot;item_1&quot;\tfirst index specifically &quot;.something.list[]&quot;\t&quot;item_1&quot;\tany index in the list &quot;.something.list[1]&quot;\t&quot;item_2&quot;\tsecond index specifically &quot;.something.list[]&quot;\t&quot;item_2&quot;\tany index in the list Testing the example above with --selector '.key' would find the value abc on the key field and return it in the command output. Testing the example above with --selector .values[] would not find a list at a field named values because it is missing entirely from the input object. Options -s, --subject &lt;subject&gt; A Subject Context string (JSON or JWT, auto-detected) (required: false) -x, --selector &lt;selector&gt; Individual selectors to test against the Subject Context (i.e. '.key,.realm_access.roles[]') (required: false)","keywords":"","version":"Next"},{"title":"Inspect a TDF file","type":0,"sectionRef":"#","url":"/pr-172/components/cli/inspect","content":"inspect [file] - Inspect a TDF file Synopsis otdfctl inspect Description Inspect a TDF file Prints the manifest.json of the specified TDF for inspection. This is useful for development and administration. Example​ $ otdfctl inspect example.tdf ","keywords":"","version":"Next"},{"title":"Flattening-syntax","type":0,"sectionRef":"#","url":"/pr-172/components/cli/dev/selectors/generate","content":"generate - Generate a set of selector expressions for keys and values of a Subject Context Synopsis otdfctl dev selectors generate [flags] Description Take in an Entity Representation as a JWT or JSON object, such as that provided by an Identity Provider (idP), LDAP, or OIDC Access Token JWT, and generate sample selectors employing flattening syntax to utilize within within Subject Condition Sets that resolve an external Subject Context into mapped Attribute Values. Flattening-syntax The platform maintains a very simple flattening library such that the below structure flattens into the key/value pairs beneath. Subject input (--subject): { &quot;key&quot;: &quot;abc&quot;, &quot;something&quot;: { &quot;nested&quot;: &quot;nested_value&quot;, &quot;list&quot;: [&quot;item_1&quot;, &quot;item_2&quot;] } } Generated Selectors: Selector\tValue\tSignificance&quot;.key&quot;\t&quot;abc&quot;\tspecified field &quot;.something.nested&quot;\t&quot;nested_value&quot;\tnested field &quot;.something.list[0]&quot;\t&quot;item_1&quot;\tfirst index specifically &quot;.something.list[]&quot;\t&quot;item_1&quot;\tany index in the list &quot;.something.list[1]&quot;\t&quot;item_2&quot;\tsecond index specifically &quot;.something.list[]&quot;\t&quot;item_2&quot;\tany index in the list Options -s, --subject &lt;subject&gt; A Subject Context string (JSON or JWT, default JSON) (required: false) Aliases gen","keywords":"","version":"Next"},{"title":"otdfctl policy","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy","content":"otdfctl policy policy - Manage policy Synopsis otdfctl policy [flags] Description Policy is a set of rules that are enforced by the platform. Specific to the the data-centric security, policy revolves around data attributes (referred to as attributes). Within the context of attributes are namespaces, values, subject-mappings, resource-mappings, registered-resources, key-access-server grants, and other key elements. Options --json &lt;json&gt; output single command in JSON (overrides configured output format) (required: false) (default: false) Aliases pol, policies","keywords":"","version":"Next"},{"title":"otdfctl interactive","type":0,"sectionRef":"#","url":"/pr-172/components/cli/interactive","content":"otdfctl interactive interactive - Interactive Mode (experimental) Synopsis otdfctl interactive Description Aliases i","keywords":"","version":"Next"},{"title":"otdfctl encrypt","type":0,"sectionRef":"#","url":"/pr-172/components/cli/encrypt","content":"otdfctl encrypt encrypt [file] - Encrypt file or stdin as a TDF Synopsis otdfctl encrypt [flags] Description Build a Trusted Data Format (TDF) with encrypted content from a specified file or input from stdin utilizing OpenTDF platform. Examples​ Various ways to encrypt a file # output to stdout otdfctl encrypt hello.txt # output to hello.txt.tdf otdfctl encrypt hello.txt --out hello.txt.tdf # encrypt piped content and write to hello.txt.tdf cat hello.txt | otdfctl encrypt --out hello.txt.tdf Automatically append .tdf to the output file name $ cat hello.txt | otdfctl encrypt --out hello.txt; ls hello.txt hello.txt.tdf $ cat hello.txt | otdfctl encrypt --out hello.txt.tdf; ls hello.txt hello.txt.tdf Advanced piping is supported $ echo &quot;hello world&quot; | otdfctl encrypt | otdfctl decrypt | cat hello world Wrapping Key Algorithm - EXPERIMENTAL​ The wrapping-key-algorithm specifies the algorithm to use for the wrapping key. The available options are (default: rsa:2048): rsa:2048ec:secp256r1ec:secp384r1ec:secp521r1 Example # Encrypt a file using the ec:secp256r1 algorithm for the wrapping key # EXPERIMENTAL otdfctl encrypt hello.txt --wrapping-key-algorithm ec:secp256r1 --out hello.txt.tdf Attributes​ Attributes can be added to the encrypted data. The attribute value is a Fully Qualified Name (FQN) that is used to restrict access to the data based on entity entitlements. # output to hello.txt.tdf with attribute otdfctl encrypt hello.txt --out hello.txt.tdf --attr https://example.com/attr/attr1/value/value1 ZTDF Assertions (experimental)​ Assertions are a way to bind metadata to the TDF data object in a cryptographically secure way. The data is signed with the provided signing key, or if none is provided, the payload key. The signing key algorithms supported are HS256 and RS256. STANAG 5636​ The following example demonstrates how to bind a STANAG 5636 metadata assertion, to the TDF data object. otdfctl encrypt hello.txt --out hello.txt.tdf --with-assertions '[{&quot;id&quot;:&quot;assertion1&quot;,&quot;type&quot;:&quot;handling&quot;,&quot;scope&quot;:&quot;tdo&quot;,&quot;appliesToState&quot;:&quot;encrypted&quot;,&quot;statement&quot;:{&quot;format&quot;:&quot;json+stanag5636&quot;,&quot;schema&quot;:&quot;urn:nato:stanag:5636:A:1:elements:json&quot;,&quot;value&quot;:&quot;{\\&quot;ocl\\&quot;:\\&quot;2024-10-21T20:47:36Z\\&quot;}&quot;}]' We also support providing an assertions json file. You can optionally provide your own signing key. In this example, we provide an RS256 private key. [{&quot;id&quot;:&quot;assertion1&quot;,&quot;type&quot;:&quot;handling&quot;,&quot;scope&quot;:&quot;tdo&quot;,&quot;appliesToState&quot;:&quot;encrypted&quot;,&quot;statement&quot;:{&quot;format&quot;:&quot;json+stanag5636&quot;,&quot;schema&quot;:&quot;urn:nato:stanag:5636:A:1:elements:json&quot;,&quot;value&quot;:&quot;{\\&quot;ocl\\&quot;:\\&quot;2024-10-21T20:47:36Z\\&quot;}&quot;},&quot;signingKey&quot;:{&quot;alg&quot;:&quot;RS256&quot;,&quot;key&quot;:&quot;-----BEGIN PRIVATE KEY-----\\nMIIEugIBADANBgkqhkiG9w0BAQEFAASCBKQwggSgAgEAAoIBAQCavTBGx1c3Q702\\nKW3GgbILpljAdt2I9XO86eb296fmDsWmbcc6bKB2LTbVZfU6VK5r45KtcY+MzbFt\\njctOsUdBdAQhOOtpdBGnm+UoNsGc6u2NgNoprMFeBNhV16UTgAgC5BoahO50xqwc\\nEaIs8RaJMvjJJ5zQ3MefazvZDiGfn8omkgk4aqPRKU1WK5903KWSOsndqmhgW/Uy\\nHCLcQX+IVlDl6dwMMmZwb9RgXeaxu4dHMCsklDvfcE1G+JxYX+eqLErGmu+bxOzx\\nrni2vw1ntwS7W7kboBj+lkUaTiaXyre/mjWNrvHDZ2CkmVLxOXzy1TOz7sYbwhvy\\nfuYep49NAgMBAAECgf8N2RrYrTRyIZmlzMJZgpc4gCujIqSPjJfEn3D5XC5+w9XA\\nu/lfONZbn/9Y6/CeTgRcpYRNKO9QI0pb3RQzgiLBO+/Z1UJjtORxR0gXdJ0XXVTz\\ntLWsD4dCycpkyT8snLkMQFdzXXRAefNyYdavOVz0kvCNgGgw606rZhkYbtHUCM3X\\nb1LZFcIAYrpftKUXxn+xOcSjIKdqKoUlBW6Yk7iTjJuy/Su63gTJ5PbgKpNvK7Xu\\nyzu4L7t2pswE5pWxb7uMMpTujqLNYiaXDlzpy/fPN8EjL1mhKzia365+EJ3uKH8c\\nQ9dz/1g36lSQnD/lus0cES9xXzQ6+1izc17dTsECgYEA1XGM4PVxCt4TaApDoT7X\\npeLDG9pQW55DQQiix4A/0EmQgxf6WN0uZ4b8lds02JhNBGVUIe2nyTNknV+9styu\\nJsKJhq+KjrcHmE8uy18++G2cZuOM2S49p8y0HPA8YBcRBC4fAoKFFG3cmrIJW5Vu\\nMzzaN+W3/1h/xdkUTpI1lYkCgYEAuZdHWrMNt96WMUuaSwu2tg3BHaYhSeyIcbwi\\nm2mIOeLQ6gGtGqyALC6N/K8Ie8KwkisTI9GqcX8O9FrkZx4RvkQrONUaS4aXEJ28\\nEZzwJenybkSuWunypVLMmp/pN7+mZZ7GUaDbXTF6pg4GOrlp6MIUk4plJYGXXumg\\nqaXvPqUCgYA0pmvf2etmiN00nsOL9Npw+vyx1CpaTzG7ywuMNqCHGn5hN/rzDKwz\\nsWKA/K+OdhMZcH1OWTc4NEsvXryGcFUtDnOqG4cMKS3gbjfWxsnbsf4QizTlJbjj\\nuWT8dm4OLeJuq4nOrq9xGKCAMEaKptOmI+6YNzwp6oSqIyAVOY+qMQKBgDM7IlRU\\nNwY5qIYlE4uByUcKFvQDRw8r/yI+R+NUx2kLRpZCLjG9yofntgQ5oQLg5HME9vyd\\nRQqdg1hKuuAIOeem07OVh/OvTIYmtKK8CsK8iNKNnP+1suiWKarJV8yu19UXdjFU\\nURmxreSm3GtbgXPiF2H/AxrOYiWuIk6SYq+NAoGAZy96GLP3HfA41UWFZH6b8ZdP\\nM6CXKDDvHOk06S/hwmhvq3UO5lQULZ+pd+aURv/TDF9DXhZIyl1CXqyOYB5IqJjk\\nAFI8A9n/naq7GyIZZRjzJu2blhSjW3ukkS/5CO4zJ6HfauSUjQA4u+5RStjeK3zd\\nF267fElUPN4+pSOAhPI=\\n-----END PRIVATE KEY-----\\n&quot;}}] otdfctl encrypt hello.txt --out hello.txt.tdf --with-assertions my_assertions_signed_rs256.json Signing with HS256 is also available. [{&quot;id&quot;:&quot;assertion1&quot;,&quot;type&quot;:&quot;handling&quot;,&quot;scope&quot;:&quot;tdo&quot;,&quot;appliesToState&quot;:&quot;encrypted&quot;,&quot;statement&quot;:{&quot;format&quot;:&quot;json+stanag5636&quot;,&quot;schema&quot;:&quot;urn:nato:stanag:5636:A:1:elements:json&quot;,&quot;value&quot;:&quot;{\\&quot;ocl\\&quot;:\\&quot;2024-10-21T20:47:36Z\\&quot;}&quot;},&quot;signingKey&quot;:{&quot;alg&quot;:&quot;HS256&quot;,&quot;key&quot;:&quot;k0cn4xBcY+49z5gs4OHUs/kbQ3/T8p+uUW9pIQ/9aqE=&quot;}}] otdfctl encrypt hello.txt --out hello.txt.tdf --with-assertions my_assertions_signed_hs256.json Target Mode​ To encrypt with a target tdf spec version, use the --target-mode flag. A version &lt; 4.3.0 will include hex encoded signature hashes and will not include a schema version in the manifest. otdfctl encrypt hello.txt --out hello.txt.tdf --target-mode 4.3.0 Options -o, --out &lt;out&gt; The output file TDF in the current working directory instead of stdout ('-o file.txt' and '-o file.txt.tdf' both write the TDF as file.txt.tdf). (required: false) -a, --attr &lt;attr&gt; Attribute value Fully Qualified Names (FQNs, i.e. 'https://example.com/attr/attr1/value/value1') to apply to the encrypted data. (required: false) --wrapping-key-algorithm &lt;wrapping-key-algorithm&gt; EXPERIMENTAL: The algorithm to use for the wrapping key (required: false) (default: rsa:2048) --mime-type &lt;mime-type&gt; The MIME type of the input data. If not provided, the MIME type is inferred from the input data. (required: false) -t, --tdf-type &lt;tdf-type&gt; The type of TDF to encrypt as (tdf3 is an alias for ztdf). (required: false) (default: ztdf) --kas-url-path &lt;kas-url-path&gt; URL path to the KAS service at the platform endpoint domain. Leading slash is required if needed. (required: false) (default: /kas) --target-mode &lt;target-mode&gt; The target TDF spec version (e.g., &quot;4.3.0&quot;); intended for legacy compatibility and subject to removal. (required: false) --with-assertions &lt;with-assertions&gt; EXPERIMENTAL: JSON string or path to a JSON file of assertions to bind metadata to the TDF. See examples for more information. WARNING: Providing keys in a JSON string is strongly discouraged. If including sensitive keys, instead provide a path to a JSON file containing that information. (required: false)","keywords":"","version":"Next"},{"title":"otdfctl policy actions delete","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/actions/delete","content":"otdfctl policy actions delete delete - Delete a Custom Action Synopsis otdfctl policy actions delete [flags] Description Removes a Custom Action from platform Policy. Standard Actions ('create', 'read', 'update', 'delete'), cannot be deleted. Action deletion cascades to any associated entitlement Subject Mappings, Obligations, and Registered Resource entitlement requirements. Make sure you know what you are doing. For more information about Actions, see the manual for the actions subcommand. Example​ otdfctl policy actions delete --id 217b300a-47f9-4bee-be8c-d38c880053f7 Options -i, --id &lt;id&gt; ID of the custom action (required: true) --force &lt;force&gt; Force deletion without interactive confirmation (required: false)","keywords":"","version":"Next"},{"title":"otdfctl policy actions","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/actions","content":"otdfctl policy actions actions - Manage Actions Synopsis otdfctl policy actions Description Actions are a set of standard and custom verbs at the core of an Access Decision or an Obligation. In the context of an entitlement decision, adding Actions to Subject Mappings answers &quot;what can an Entity do to a Resource?&quot; Standard Actions in Policy are comprised of the below, and only their metadata labels are mutable: createread (considered within all TDF decrypt flows)updatedelete Custom Actions known to Policy are admin-defined, globally unique (not namespaced), and will be lower cased when stored. They may contain underscores (_) or hyphens (-) if preceded or followed by an alphanumeric character. For example: downloadqueue-to-printsend_email For more information about entitlement and Subject Mappings, see the subject-mappings command. Aliases action","keywords":"","version":"Next"},{"title":"otdfctl policy actions create","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/actions/create","content":"otdfctl policy actions create create - Create a Custom Action Synopsis otdfctl policy actions create [flags] Description Add a custom action to the platform Policy. An Action name is normalized to lower case and may contain underscores (_) or hyphens (-) between other alphanumeric characters. Each name must be globally unique as actions are not namespaced. For more information, see the actions subcommand. Examples​ Create a custom action named 'install_package': otdfctl policy actions create --name install_package Options -n, --name &lt;name&gt; Name of the custom action (must be unique within Policy) (required: true) -l, --label &lt;label&gt; Optional metadata 'labels' in the format: key=value (required: false) Aliases c, add, new","keywords":"","version":"Next"},{"title":"otdfctl policy actions get","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/actions/get","content":"otdfctl policy actions get get - Get a Standard or Custom Action Synopsis otdfctl policy actions get [flags] Description If both id and name flag values are provided, id is preferred. For more information about Actions, see the manual for the actions subcommand. Example​ Get by ID: otdfctl policy actions get --id e1402c63-eeaa-45e2-85d2-b939d135941f Get by Name: otdfctl policy actions get --name read Options -i, --id &lt;id&gt; ID of the action (required: false) -n, --name &lt;name&gt; Name of the action (required: false) Aliases g","keywords":"","version":"Next"},{"title":"otdfctl policy actions update","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/actions/update","content":"otdfctl policy actions update update - Update a Custom Action Synopsis otdfctl policy actions update [flags] Description Update the name and/or metadata labels for a Custom Action. If PEPs rely on this action name, a name update could break access. Make sure you know what you are doing. For more information about Actions, see the manual for the actions subcommand. Example​ otdfctl policy actions update --id 34c62145-5d99-45cb-a732-13cb16270e63 --name new_action_name Options -i, --id &lt;id&gt; ID of the action to update (required: true) -n, --name &lt;name&gt; Optional updated name of the custom action (must be unique within Policy) (required: false) -l, --label &lt;label&gt; Optional metadata 'labels' in the format: key=value (required: false) --force-replace-labels &lt;force-replace-labels&gt; Destructively replace entire set of existing metadata 'labels' with any provided to this command (required: false) Aliases u","keywords":"","version":"Next"},{"title":"otdfctl policy attributes","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/attributes","content":"otdfctl policy attributes attributes - Manage attributes Synopsis otdfctl policy attributes Description Commands to manage attributes within the platform. Attributes are used to to define the properties of a piece of data. These attributes will then be used to define the access controls based on subject encodings and entity entitlements. Aliases attr, attribute","keywords":"","version":"Next"},{"title":"otdfctl policy actions list","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/actions/list","content":"otdfctl policy actions list list - List Actions Synopsis otdfctl policy actions list [flags] Description For more information about Actions, see the manual for the actions subcommand. Example​ otdfctl policy actions list Options -l, --limit &lt;limit&gt; Limit retrieved count (required: false) -o, --offset &lt;offset&gt; Offset (page) quantity from start of the list (required: false) Aliases l","keywords":"","version":"Next"},{"title":"otdfctl policy attributes deactivate","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/attributes/deactivate","content":"otdfctl policy attributes deactivate deactivate - Deactivate an attribute definition Synopsis otdfctl policy attributes deactivate [flags] Description Deactivation preserves uniqueness of the attribute and values underneath within policy and all existing relations, essentially reserving them. However, a deactivation of an attribute means its associated values cannot be entitled in an access decision. For information about reactivation, see the unsafe reactivate subcommand. For more general information about attributes, see the attributes subcommand. Example​ otdfctl policy attributes deactivate --id 3c51a593-cbf8-419d-b7dc-b656d0bedfbb Options -i, --id &lt;id&gt; ID of the attribute (required: true) --force &lt;force&gt; Force deactivation without interactive confirmation (dangerous) (required: false)","keywords":"","version":"Next"},{"title":"otdfctl policy attributes create","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/attributes/create","content":"otdfctl policy attributes create create - Create an attribute definition Synopsis otdfctl policy attributes create [flags] Description Under a namespace, create an attribute with a rule. An attribute definition name is normalized to lower case and may contain hyphens and underscores between other alphanumeric characters. Rules​ ANY_OF​ If an Attribute is defined with logical rule ANY_OF, an Entity who is mapped to any of the associated Values of the Attribute on TDF'd Resource Data will be Entitled to take the actions in the mapping. ALL_OF​ If an Attribute is defined with logical rule ALL_OF, an Entity must be mapped to all of the associated Values of the Attribute on TDF'd Resource Data to be Entitled to take the actions in the mapping. HIERARCHY​ If an Attribute is defined with logical rule HIERARCHY, an Entity must be mapped to the same level Value or a level above in hierarchy compared to a given Value on TDF'd Resource Data. Hierarchical values are considered highest at index 0 and lowest at the last index. Actions propagate down through the hierarchy, so a mapping of a read action on the highest level Value on the Attribute will entitle the action to each hierarchically lower value, and so on. For more general information about attributes, see the attributes subcommand. Example​ otdfctl policy attributes create --namespace 3d25d33e-2469-4990-a9ed-fdd13ce74436 --name myattribute --rule ANY_OF Options -n, --name &lt;name&gt; Name of the attribute (required: true) -r, --rule &lt;rule&gt; Rule of the attribute (required: true) -v, --value &lt;value&gt; Value of the attribute (i.e. 'value1') (required: true) -s, --namespace &lt;namespace&gt; Namespace ID of the attribute (required: true) -l, --label &lt;label&gt; Optional metadata 'labels' in the format: key=value (required: false) Aliases new, add, c","keywords":"","version":"Next"},{"title":"otdfctl policy attributes get","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/attributes/get","content":"otdfctl policy attributes get get - Get an attribute definition Synopsis otdfctl policy attributes get [flags] Description Retrieve an attribute along with its metadata, rule, and values. For more general information about attributes, see the attributes subcommand. Example​ otdfctl policy attributes get --id=3c51a593-cbf8-419d-b7dc-b656d0bedfbb Options -i, --id &lt;id&gt; ID of the attribute (required: false) Aliases g","keywords":"","version":"Next"},{"title":"otdfctl policy attributes key","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/attributes/key","content":"otdfctl policy attributes key key - Key Management changes to attribute definition Synopsis otdfctl policy attributes key Description Manages KAS key associations for attribute definitions.","keywords":"","version":"Next"},{"title":"otdfctl policy attributes key assign","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/attributes/key/assign","content":"otdfctl policy attributes key assign assign - Assign a KAS key to an attribute definition Synopsis otdfctl policy attributes key assign [flags] Description Assigns a KAS key to a policy attribute. This enables the attribute to be used with the specified KAS key for encryption and decryption operations. Example​ otdfctl policy attributes key assign --attribute 3d25d33e-2469-4990-a9ed-fdd13ce74436 --key-id 8f7e6d5c-4b3a-2d1e-9f8d-7c6b5a432f1d otdfctl policy attributes key assign --attribute &quot;https://example.com/attr/example&quot; --key-id 8f7e6d5c-4b3a-2d1e-9f8d-7c6b5a432f1d Options -a, --attribute &lt;attribute&gt; URI or ID of the attribute definition (required: true) -k, --key-id &lt;key-id&gt; ID of the KAS key to assign (required: true)","keywords":"","version":"Next"},{"title":"otdfctl policy attributes key remove","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/attributes/key/remove","content":"otdfctl policy attributes key remove remove - Remove a KAS key from an attribute definition Synopsis otdfctl policy attributes key remove [flags] Description Removes a KAS key association from a policy attribute. This will prevent the attribute from being used with the specified KAS key for encryption and decryption operations. Example​ otdfctl policy attributes key remove --attribute 3d25d33e-2469-4990-a9ed-fdd13ce74436 --key-id 8f7e6d5c-4b3a-2d1e-9f8d-7c6b5a432f1d otdfctl policy attributes key remove --attribute &quot;https://example.com/attr/example&quot; --key-id 8f7e6d5c-4b3a-2d1e-9f8d-7c6b5a432f1d Options -a, --attribute &lt;attribute&gt; URI or ID of attribute definition (required: true) -k, --key-id &lt;key-id&gt; ID of the KAS key to remove (required: true)","keywords":"","version":"Next"},{"title":"otdfctl policy attributes list","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/attributes/list","content":"otdfctl policy attributes list list - List attribute definitions Synopsis otdfctl policy attributes list [flags] Description By default, the list will only provide active attributes if unspecified, but the filter can be controlled with the --state flag. For more general information about attributes, see the attributes subcommand. Example​ otdfctl policy attributes list Options -s, --state &lt;state&gt; Filter by state (required: false) (default: active) -l, --limit &lt;limit&gt; Limit retrieved count (required: false) -o, --offset &lt;offset&gt; Offset (page) quantity from start of the list (required: false) Aliases l","keywords":"","version":"Next"},{"title":"otdfctl policy attributes namespaces create","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/attributes/namespaces/create","content":"otdfctl policy attributes namespaces create create - Create an attribute namespace Synopsis otdfctl policy attributes namespaces create [flags] Description Creation of a namespace is required to add attributes or any other policy objects beneath. A namespace name is normalized to lower case, may contain hyphens and underscores between other alphanumeric characters, and it must contain two segments separated by a ., such as example.com. For more information, see the namespaces subcommand. Example​ otdfctl policy attributes namespaces create --name opentdf.io Options -n, --name &lt;name&gt; Name of the attribute namespace (must be unique within Policy) (required: true) -l, --label &lt;label&gt; Optional metadata 'labels' in the format: key=value (required: false) Aliases c, add, new","keywords":"","version":"Next"},{"title":"otdfctl policy attributes namespaces","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/attributes/namespaces","content":"otdfctl policy attributes namespaces namespaces - Manage attribute namespaces Synopsis otdfctl policy attributes namespaces Description A namespace is the root (parent) of a set of platform policy. Like an owner or an authority, it fully qualifies attributes and their values, resource mapping groups, etc. As the various mappings of a platform are to attributes or values, a namespace effectively &quot;owns&quot; the mappings as well (transitively if not directly). In an attribute or other FQN (Fully Qualified Name), the namespace is found after the scheme: https://&lt;namespace&gt; Namespaces, like other FQN'd objects, are normalized to lower case both on create and in a decision request lookup. As the Namespace is the parent of policy, a namespace's existence is required to create attributes or resource mapping groups beneath. Aliases ns, namespace","keywords":"","version":"Next"},{"title":"otdfctl policy attributes namespaces get","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/attributes/namespaces/get","content":"otdfctl policy attributes namespaces get get - Get an attribute namespace Synopsis otdfctl policy attributes namespaces get [flags] Description For more information, see the namespaces subcommand. Example​ otdfctl policy attributes namespaces get --id=7650f02a-be00-4faa-a1d1-37cded5e23dc Options -i, --id &lt;id&gt; ID of the attribute namespace (required: false) Aliases g","keywords":"","version":"Next"},{"title":"otdfctl policy attributes namespaces deactivate","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/attributes/namespaces/deactivate","content":"otdfctl policy attributes namespaces deactivate deactivate - Deactivate an attribute namespace Synopsis otdfctl policy attributes namespaces deactivate [flags] Description Deactivating an Attribute Namespace will make the namespace name inactive as well as any attribute definitions and values beneath. Deactivation of a Namespace renders any existing TDFs of those attributes inaccessible. Deactivation will permanently reserve the Namespace name within a platform. Reactivation and deletion are both considered &quot;unsafe&quot; behaviors. For information about reactivation, see the unsafe reactivate subcommand. For reactivation, see the unsafe command. Example​ otdfctl policy attributes namespaces deactivate --id 7650f02a-be00-4faa-a1d1-37cded5e23dc Options -i, --id &lt;id&gt; ID of the attribute namespace (required: true) --force &lt;force&gt; Force deactivation without interactive confirmation (dangerous) (required: false)","keywords":"","version":"Next"},{"title":"otdfctl policy attributes namespaces key assign","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/attributes/namespaces/key/assign","content":"otdfctl policy attributes namespaces key assign assign - Assign a KAS key to an attribute namespace Synopsis otdfctl policy attributes namespaces key assign [flags] Description Assigns a KAS key to a policy attribute namespace. This enables the attribute namespace to be used with the specified KAS key for encryption and decryption operations. Example​ otdfctl policy attributes namespaces assign --namespace 3d25d33e-2469-4990-a9ed-fdd13ce74436 --key-id 8f7e6d5c-4b3a-2d1e-9f8d-7c6b5a432f1d otdfctl policy attributes namespaces remove --namespace &quot;https://example.com&quot; --key-id 8f7e6d5c-4b3a-2d1e-9f8d-7c6b5a432f1d Options -n, --namespace &lt;namespace&gt; Can be URI or ID of namespace (required: true) -k, --key-id &lt;key-id&gt; ID of the KAS key to assign (required: true)","keywords":"","version":"Next"},{"title":"otdfctl policy attributes namespaces key","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/attributes/namespaces/key","content":"otdfctl policy attributes namespaces key key - Key Management changes to attribute namespaces Synopsis otdfctl policy attributes namespaces key Description Manages KAS key associations for attribute namespaces.","keywords":"","version":"Next"},{"title":"otdfctl policy attributes namespaces list","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/attributes/namespaces/list","content":"otdfctl policy attributes namespaces list list - List attribute namespaces Synopsis otdfctl policy attributes namespaces list [flags] Description For more general information, see the namespaces subcommand. Example​ otdfctl policy attributes namespaces list Options -s, --state &lt;state&gt; Filter by state [active, inactive, any] (required: false) -l, --limit &lt;limit&gt; Limit retrieved count (required: false) -o, --offset &lt;offset&gt; Offset (page) quantity from start of the list (required: false) Aliases ls, l","keywords":"","version":"Next"},{"title":"otdfctl policy attributes namespaces key remove","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/attributes/namespaces/key/remove","content":"otdfctl policy attributes namespaces key remove remove - Remove a KAS key from an attribute namespace Synopsis otdfctl policy attributes namespaces key remove [flags] Description Removes a KAS key from a policy attribute namespace. After removing the key, the attribute namespace can no longer be used with the specified KAS key for encryption and decryption operations. Example​ otdfctl policy attributes namespaces remove --namespace 3d25d33e-2469-4990-a9ed-fdd13ce74436 --key-id 8f7e6d5c-4b3a-2d1e-9f8d-7c6b5a432f1d otdfctl policy attributes namespaces remove --namespace &quot;https://example.com&quot; --key-id 8f7e6d5c-4b3a-2d1e-9f8d-7c6b5a432f1d Options -n, --namespace &lt;namespace&gt; Can be URI or ID of namespace (required: true) -k, --key-id &lt;key-id&gt; ID of the KAS key to remove (required: true)","keywords":"","version":"Next"},{"title":"otdfctl policy attributes namespaces unsafe","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/attributes/namespaces/unsafe","content":"otdfctl policy attributes namespaces unsafe unsafe - Unsafe changes to attribute namespaces Synopsis otdfctl policy attributes namespaces unsafe [flags] Description Unsafe changes are dangerous mutations to Policy that can significantly change access behavior around existing attributes and entitlement. Depending on the unsafe change introduced and already existing TDFs, TDFs might become inaccessible that were previously accessible or vice versa. Make sure you know what you are doing. For more general information, see the namespaces subcommand. Options --force &lt;force&gt; Force unsafe change without confirmation (required: false)","keywords":"","version":"Next"},{"title":"Unsafe Delete Warning","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/attributes/namespaces/unsafe/delete","content":"delete - Delete an attribute namespace Synopsis otdfctl policy attributes namespaces unsafe delete [flags] Description Unsafe Delete Warning Deleting a Namespace cascades deletion of any Attribute Definitions, Values, and any associated mappings underneath. Any existing TDFs containing attributes under this namespace will be rendered inaccessible until it has been recreated. Make sure you know what you are doing. For more general information, see the namespaces subcommand. Example​ otdfctl policy attributes namespaces unsafe delete --id 7650f02a-be00-4faa-a1d1-37cded5e23dc Options -i, --id &lt;id&gt; ID of the attribute namespace (required: true)","keywords":"","version":"Next"},{"title":"Unsafe Reactivate Warning","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/attributes/namespaces/unsafe/reactivate","content":"reactivate - Reactivate an attribute namespace Synopsis otdfctl policy attributes namespaces unsafe reactivate [flags] Description Unsafe Reactivate Warning Reactivating a Namespace can potentially open up an access path to any existing TDFs referencing attributes under that Namespace. The Active/Inactive state of any Attribute Definitions or Values under this Namespace will NOT be changed. Make sure you know what you are doing. For more general information, see the namespaces subcommand. Example​ otdfctl policy attributes namespaces unsafe reactivate --id 7650f02a-be00-4faa-a1d1-37cded5e23dc Options -i, --id &lt;id&gt; ID of the attribute namespace (required: true)","keywords":"","version":"Next"},{"title":"Unsafe Update Warning","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/attributes/namespaces/unsafe/update","content":"update - Update an attribute namespace Synopsis otdfctl policy attributes namespaces unsafe update [flags] Description Unsafe Update Warning Renaming a Namespace means any Attribute Definitions, Values, and any associated mappings underneath will now be tied to the new name. Any existing TDFs containing attributes under the old namespace will be rendered inaccessible, and any TDFs tied to the new namespace and already created may now become accessible. Make sure you know what you are doing. For more general information, see the namespaces subcommand. Example​ otdfctl policy attributes namespaces unsafe update --id=7650f02a-be00-4faa-a1d1-37cded5e23dc --name opentdf2.io Options -i, --id &lt;id&gt; ID of the attribute namespace (required: true) -n, --name &lt;name&gt; Name of the attribute namespace (new) (required: true)","keywords":"","version":"Next"},{"title":"otdfctl policy attributes unsafe","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/attributes/unsafe","content":"otdfctl policy attributes unsafe unsafe - Unsafe changes to attribute definitions Synopsis otdfctl policy attributes unsafe [flags] Description Unsafe changes are dangerous mutations to Policy that can significantly change access behavior around existing attributes and entitlement. Depending on the unsafe change introduced and already existing TDFs, TDFs might become inaccessible that were previously accessible or vice versa. Make sure you know what you are doing. For more general information about attributes, see the attributes subcommand. Options --force &lt;force&gt; Force unsafe change without confirmation (required: false)","keywords":"","version":"Next"},{"title":"otdfctl policy attributes namespaces update","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/attributes/namespaces/update","content":"otdfctl policy attributes namespaces update update - Update a attribute namespace Synopsis otdfctl policy attributes namespaces update [flags] Description Attribute Namespace changes can be dangerous, so this command is for updates considered &quot;safe&quot; (currently just mutations to metadata labels). For unsafe updates, see the dedicated unsafe update command. For more general information, see the namespaces subcommand. Example​ otdfctl policy attributes namespaces update --id=7650f02a-be00-4faa-a1d1-37cded5e23dc --label hello=world Options -i, --id &lt;id&gt; ID of the attribute namespace (required: true) -l, --label &lt;label&gt; Optional metadata 'labels' in the format: key=value (required: false) --force-replace-labels &lt;force-replace-labels&gt; Destructively replace entire set of existing metadata 'labels' with any provided to this command (required: false) Aliases u","keywords":"","version":"Next"},{"title":"Unsafe Delete Warning","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/attributes/unsafe/delete","content":"delete - Delete an attribute definition Synopsis otdfctl policy attributes unsafe delete [flags] Description Unsafe Delete Warning Deleting an Attribute Definition cascades deletion of any Attribute Values and any associated mappings underneath. Any existing TDFs containing the deleted attribute of this name will be rendered inaccessible until it has been recreated. Make sure you know what you are doing. For more general information about attributes, see the attributes subcommand. Example​ otdfctl policy attributes unsafe delete --id 3c51a593-cbf8-419d-b7dc-b656d0bedfbb Options -i, --id &lt;id&gt; ID of the attribute definition (required: true)","keywords":"","version":"Next"},{"title":"Unsafe Reactivate Warning","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/attributes/unsafe/reactivate","content":"reactivate - Reactivate an attribute definition Synopsis otdfctl policy attributes unsafe reactivate [flags] Description Unsafe Reactivate Warning Reactivating an Attribute Definition can potentially open up an access path to any existing TDFs referencing values under that definition. The Active/Inactive state of any Attribute Values under this Definition will NOT be changed. Make sure you know what you are doing. For more general information about attributes, see the attributes subcommand. Example​ otdfctl policy attributes unsafe reactivate --id 3c51a593-cbf8-419d-b7dc-b656d0bedfbb Options -i, --id &lt;id&gt; ID of the attribute definition (required: true)","keywords":"","version":"Next"},{"title":"Unsafe Update Warning","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/attributes/unsafe/update","content":"update - Update an attribute definition Synopsis otdfctl policy attributes unsafe update [flags] Description Unsafe Update Warning Name Update​ Renaming an Attribute Definition means any Values and any associated mappings underneath will now be tied to the new name. Any existing TDFs containing attributes under the old definition name will be rendered inaccessible, and any TDFs tied to the new name and already created may now become accessible. Rule Update​ Altering a rule of an Attribute Definition changes the evaluation of entitlement to data. Existing TDFs of the same definition name and values will now be accessible based on the updated rule. An anyOf rule becoming hierarchy or vice versa, for example, have entirely different meanings and access evaluations. Values-Order Update​ In the case of a hierarchy Attribute Definition Rule, the order of Values on the attribute has significant impact on data access. Changing this order (complete, destructive replacement of the existing order) will impact access to data. To remove Values from an Attribute Definition, delete them separately via the values unsafe commands. To add, utilize safevalues create commands. Make sure you know what you are doing. For more general information about attributes, see the attributes subcommand. Example​ otdfctl policy attributes unsafe update --id 3c51a593-cbf8-419d-b7dc-b656d0bedfbb --name mynewname Options -i, --id &lt;id&gt; ID of the attribute definition (required: true) -n, --name &lt;name&gt; Name of the attribute definition (required: false) -r, --rule &lt;rule&gt; Rule of the attribute definition (required: false) -o, --values-order &lt;values-order&gt; Order of the attribute values (IDs) (required: false)","keywords":"","version":"Next"},{"title":"otdfctl policy attributes update","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/attributes/update","content":"otdfctl policy attributes update update - Update an attribute definition Synopsis otdfctl policy attributes update [flags] Description Attribute Definition changes can be dangerous, so this command is for updates considered &quot;safe&quot; (currently just mutations to metadata labels). For unsafe updates, see the dedicated unsafe update command. For more general information, see the attributes subcommand. For more general information about attributes, see the attributes subcommand. Example​ otdfctl policy attributes update --id=3c51a593-cbf8-419d-b7dc-b656d0bedfbb --label hello=world Options -i, --id &lt;id&gt; ID of the attribute (required: true) -l, --label &lt;label&gt; Optional metadata 'labels' in the format: key=value (required: false) --force-replace-labels &lt;force-replace-labels&gt; Destructively replace entire set of existing metadata 'labels' with any provided to this command (required: false) Aliases u","keywords":"","version":"Next"},{"title":"otdfctl policy attributes values","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/attributes/values","content":"otdfctl policy attributes values values - Manage attribute values Synopsis otdfctl policy attributes values Description Attribute values are the individual units tagged on TDFs containing Resource Data. They are mapped to entitle person and non-person entities through Subject Mappings, to varied terms for tagging providers through Resource Mappings, to individual keys and Key Access Servers through KAS Grants, and more. They are fully-qualified through the FQN structure https://&lt;namespace&gt;/attr/&lt;definition name&gt;/value/&lt;value&gt;, and the presence of one or more values on a piece of Resource Data (a TDF) determines an entity's access to the data through a combination of entitlements and the attribute definition rule evaluation. In other words, Attribute Values are the atomic units that drive access control relation of Data -&gt; Entities and vice versa. Values are contextualized by Attribute Definitions within Namespaces, and only have logical meaning as part of a Definition. Giving data multiple Attribute Values across the same or multiple Definitions/Namespaces will require all of the definition rules to be satisfied by an Entity's mapped Entitlements to result in key release, decryption, and resulting access to TDF'd data. For more information on: values, see the attributes values subcommandattribute definitions, see the attributes subcommandnamespaces, see the attributes namespaces subcommand Aliases val, value","keywords":"","version":"Next"},{"title":"otdfctl policy attributes values deactivate","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/attributes/values/deactivate","content":"otdfctl policy attributes values deactivate deactivate - Deactivate an attribute value Synopsis otdfctl policy attributes values deactivate [flags] Description Deactivation preserves uniqueness of the attribute value within policy and all existing relations, essentially reserving it. However, a deactivation of an attribute value means it cannot be entitled in an access decision. For information about reactivation, see the unsafe reactivate subcommand. For more information on attribute values, see the values subcommand. Example​ otdfctl policy attributes values deactivate --id 355743c1-c0ef-4e8d-9790-d49d883dbc7d Options -i, --id &lt;id&gt; The ID of the attribute value to deactivate (required: false)","keywords":"","version":"Next"},{"title":"otdfctl policy attributes values get","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/attributes/values/get","content":"otdfctl policy attributes values get get - Get an attribute value Synopsis otdfctl policy attributes values get [flags] Description Retrieve an attribute value along with its metadata. For more general information about attribute values, see the values subcommand. Example​ otdfctl policy attributes values get --id 355743c1-c0ef-4e8d-9790-d49d883dbc7d Options -i, --id &lt;id&gt; The ID of the attribute value to get (required: false) Aliases g","keywords":"","version":"Next"},{"title":"otdfctl policy attributes values create","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/attributes/values/create","content":"otdfctl policy attributes values create create - Create an attribute value Synopsis otdfctl policy attributes values create [flags] Description Add a single new value underneath an existing attribute. An attribute value is normalized to lower case and may contain hyphens and underscores between other alphanumeric characters. For a hierarchical attribute, a new value is added in lowest hierarchy (last). For more information on attribute values, see the values subcommand. Example​ otdfctl policy attributes values create --attribute-id 3c51a593-cbf8-419d-b7dc-b656d0bedfbb --value myvalue1 Options -a, --attribute-id &lt;attribute-id&gt; The ID of the attribute to create a value for (required: false) -v, --value &lt;value&gt; The value to create (required: false) -l, --label &lt;label&gt; Optional metadata 'labels' in the format: key=value (required: false) Aliases new, add, c","keywords":"","version":"Next"},{"title":"otdfctl policy attributes values key remove","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/attributes/values/key/remove","content":"otdfctl policy attributes values key remove remove - Remove a KAS key from an attribute value Synopsis otdfctl policy attributes values key remove [flags] Description Removes a KAS key from a policy attribute value. After removing the key, the attribute value can no longer be used with the specified KAS key for encryption and decryption operations. Example​ otdfctl policy attributes values remove --value 3d25d33e-2469-4990-a9ed-fdd13ce74436 --key-id 8f7e6d5c-4b3a-2d1e-9f8d-7c6b5a432f1d otdfctl policy attributes values remove --value &quot;https://example.com/attr/example/value/1&quot; --key-id 8f7e6d5c-4b3a-2d1e-9f8d-7c6b5a432f1d Options -v, --value &lt;value&gt; URI or ID of attribute value (required: true) -k, --key-id &lt;key-id&gt; ID of the KAS key to remove (required: true)","keywords":"","version":"Next"},{"title":"otdfctl policy attributes values key assign","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/attributes/values/key/assign","content":"otdfctl policy attributes values key assign assign - Assign a KAS key to an attribute value Synopsis otdfctl policy attributes values key assign [flags] Description Assigns a KAS key to a policy attribute value. This enables the attribute value to be used with the specified KAS key for encryption and decryption operations. Example​ otdfctl policy attributes values assign --value 3d25d33e-2469-4990-a9ed-fdd13ce74436 --key-id 8f7e6d5c-4b3a-2d1e-9f8d-7c6b5a432f1d otdfctl policy attributes values assign --value &quot;https://demo.com/attr/example/value/1&quot; --key-id 8f7e6d5c-4b3a-2d1e-9f8d-7c6b5a432f1d Options -v, --value &lt;value&gt; URI or ID of attribute value (required: true) -k, --key-id &lt;key-id&gt; ID of the KAS key to assign (required: true)","keywords":"","version":"Next"},{"title":"otdfctl policy attributes values key","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/attributes/values/key","content":"otdfctl policy attributes values key key - Key Management changes to attribute value Synopsis otdfctl policy attributes values key Description Manages KAS key associations for attribute values.","keywords":"","version":"Next"},{"title":"otdfctl policy attributes values list","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/attributes/values/list","content":"otdfctl policy attributes values list list - List attribute values Synopsis otdfctl policy attributes values list [flags] Description By default, the list will only provide active values if unspecified, but the filter can be controlled with the --state flag. For more general information about attribute values, see the values subcommand. Example​ otdfctl policy attributes values list --attribute-id 3c51a593-cbf8-419d-b7dc-b656d0bedfbb Options -a, --attribute-id &lt;attribute-id&gt; The ID of the attribute to list values for (required: false) -s, --state &lt;state&gt; Filter by state (required: false) (default: active) -l, --limit &lt;limit&gt; Limit retrieved count (required: false) -o, --offset &lt;offset&gt; Offset (page) quantity from start of the list (required: false) Aliases ls, l","keywords":"","version":"Next"},{"title":"Unsafe Delete Warning","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/attributes/values/unsafe/delete","content":"delete - Delete an attribute value Synopsis otdfctl policy attributes values unsafe delete [flags] Description Unsafe Delete Warning Deleting an Attribute Value cascades deletion of any associated mappings underneath. Any existing TDFs containing the deleted attribute of this value will be rendered inaccessible until it has been recreated. Make sure you know what you are doing. For more information on attribute values, see the values subcommand. Example​ otdfctl policy attributes values unsafe delete --id b20458b0-1855-4608-8869-3f6199bc2878 Options -i, --id &lt;id&gt; ID of the attribute value (required: true)","keywords":"","version":"Next"},{"title":"Unsafe Reactivate Warning","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/attributes/values/unsafe/reactivate","content":"reactivate - Reactivate an attribute value Synopsis otdfctl policy attributes values unsafe reactivate [flags] Description Unsafe Reactivate Warning Reactivating an Attribute Value can potentially open up an access path to any existing TDFs referencing values under that definition. The Active/Inactive state of the Attribute Definition and Namespace above this Value will NOT be changed. Make sure you know what you are doing. For more information on attribute values, see the values subcommand. Example​ otdfctl policy attributes values unsafe reactivate --id 355743c1-c0ef-4e8d-9790-d49d883dbc7d Options -i, --id &lt;id&gt; ID of the attribute value (required: true)","keywords":"","version":"Next"},{"title":"otdfctl policy attributes values unsafe","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/attributes/values/unsafe","content":"otdfctl policy attributes values unsafe unsafe - Unsafe changes to attribute values Synopsis otdfctl policy attributes values unsafe [flags] Description Unsafe changes are dangerous mutations to Policy that can significantly change access behavior around existing attributes and entitlement. Depending on the unsafe change introduced and already existing TDFs, TDFs might become inaccessible that were previously accessible or vice versa. Make sure you know what you are doing. For more information on attribute values, see the values subcommand. Options --force &lt;force&gt; Force unsafe change without confirmation (required: false)","keywords":"","version":"Next"},{"title":"Unsafe Update Warning","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/attributes/values/unsafe/update","content":"update - Update an attribute value Synopsis otdfctl policy attributes values unsafe update [flags] Description Unsafe Update Warning Value Update​ Changing an Attribute Value means any associated mappings underneath will now be tied to the new value. Any existing TDFs containing attributes under the old value will be rendered inaccessible, and any TDFs tied to the new value and already created may now become accessible. Make sure you know what you are doing. For more information on attribute values, see the values subcommand. Example​ otdfctl policy attributes values unsafe update --id 355743c1-c0ef-4e8d-9790-d49d883dbc7d --name mynewvalue1 Options -i, --id &lt;id&gt; ID of the attribute value (required: true) -v, --value &lt;value&gt; The new value replacing the current value (required: false)","keywords":"","version":"Next"},{"title":"otdfctl policy attributes values update","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/attributes/values/update","content":"otdfctl policy attributes values update update - Update attribute value Synopsis otdfctl policy attributes values update [flags] Description Attribute Value changes can be dangerous, so this command is for updates considered &quot;safe&quot; (currently just mutations to metadata labels). For unsafe updates, see the dedicated unsafe update command. For more general information, see the values subcommand. For more general information about attributes, see the attributes subcommand. Example​ otdfctl policy attributes values update --id 355743c1-c0ef-4e8d-9790-d49d883dbc7d --label hello=world Options -i, --id &lt;id&gt; The ID of the attribute value to update (required: false) -l, --label &lt;label&gt; Optional metadata 'labels' in the format: key=value (required: false) --force-replace-labels &lt;force-replace-labels&gt; Destructively replace entire set of existing metadata 'labels' with any provided to this command (required: false) Aliases u","keywords":"","version":"Next"},{"title":"Deprecated\\n\\nThis command is deprecated and will be removed in a future release.","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/kas-grants/list","content":"list - (Deprecated) List KAS Grants Synopsis otdfctl policy kas-grants list [flags] Description Deprecated\\n\\nThis command is deprecated and will be removed in a future release. List the Grants of Registered Key Access Servers (KASes) to attribute namespaces, definitions, or values. Omitting kas lists all grants known to platform policy, otherwise results are filtered to the KAS URI or ID specified by the flag value. For more information, see kas-registry and kas-grants manuals. Example​ otdfctl policy kas-grants list Options -k, --kas &lt;kas&gt; The optional ID or URI of a KAS to filter the list (required: false) -l, --limit &lt;limit&gt; Limit retrieved count (required: false) -o, --offset &lt;offset&gt; Offset (page) quantity from start of the list (required: false) Aliases l","keywords":"","version":"Next"},{"title":"Deprecated\\n\\nThis command is deprecated. Use policy attributes namespace key assign, policy attributes key assign, or policy attributes value key assign instead.","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/kas-grants/assign","content":"assign - (Deprecated) Assign a grant Synopsis otdfctl policy kas-grants assign [flags] Description Deprecated\\n\\nThis command is deprecated. Use policy attributes namespace key assign, policy attributes key assign, or policy attributes value key assign instead. Assign a registered Key Access Server (KAS) to an attribute namespace, definition, or value. For more information, see kas-registry and kas-grants manuals. Example​ Namespace grant: otdfctl policy kas-grants assign --namespace-id 3d25d33e-2469-4990-a9ed-fdd13ce74436 --kas-id 62857b55-560c-4b67-96e3-33e4670ecb3b Attribute grant: otdfctl policy kas-grants assign --attribute-id a21eb299-3a7d-4035-8a39-c8662c03cb15 --kas-id 62857b55-560c-4b67-96e3-33e4670ecb3b Attribute value grant: otdfctl policy kas-grants assign --value-id 0a40b27c-6cc9-49e8-a6ae-663cac2c324b --kas-id 62857b55-560c-4b67-96e3-33e4670ecb3b Options -n, --namespace-id &lt;namespace-id&gt; The ID of the Namespace being assigned a KAS Grant (required: false) -a, --attribute-id &lt;attribute-id&gt; The ID of the Attribute Definition being assigned a KAS Grant (required: true) -v, --value-id &lt;value-id&gt; The ID of the Value being assigned a KAS Grant (required: true) -k, --kas-id &lt;kas-id&gt; The ID of the Key Access Server being assigned to the grant (required: true) -l, --label &lt;label&gt; Optional metadata 'labels' in the format: key=value (required: false) --force-replace-labels &lt;force-replace-labels&gt; Destructively replace entire set of existing metadata 'labels' with any provided to this command (required: false) Aliases u, update, create, add, new, upsert","keywords":"","version":"Next"},{"title":"Deprecated","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/kas-grants","content":"kas-grants - (Deprecated) Manage Key Access Server grants Synopsis otdfctl policy kas-grants Description Deprecated Once Key Access Servers (KASs) have been registered within a platform's policy, they can be assigned grants to various attribute objects (namespaces, definitions, values). See kas-registry command within policy to manage the KASs known to the platform. Key Access Grants are associations between a registered KAS (see KAS Registry docs) and an Attribute. An attribute can be assigned a KAS Grant on its namespace, its definition, or any one of its values. Grants enable key split behaviors on TDFs with attributes, which can be useful for various collaboration scenarios around shared policy. [!WARNING] KAS Grants are considered experimental, as grants to namespaces are not fully utilized within encrypt/decrypt flows at present. Utilization​ The steps below are driven by the SDK on encrypt, and they are the same steps followed on decrypt by a KAS making a decision request on a key release (once the decision is found to be permissible): look up the attributes on the TDF within the platformfind any associated grants for those attributes' values, definitions, namespacesretrieve the public key of each KAS granted to those attribute objectsdetermine based on the specificity matrix below which keys to utilize in splits Specificity​ When KAS grants are considered, they follow a most-to-least specificity matrix. Grants to Attribute Values supersede any grants to Definitions which also supersede any grants to a Namespace. Grants to Attribute Objects: Namespace Grant\tAttr Definition Grant\tAttr Value Grant\tData Encryption Key Utilizedyes\tno\tno\tnamespace yes\tyes\tno\tattr definition no\tyes\tno\tattr definition yes\tyes\tyes\tvalue no\tyes\tyes\tvalue no\tno\tyes\tvalue no\tno\tno\tdefault KAS/platform key [!NOTE] A namespace grant may soon be required with deprecation of a default KAS/platform key. Split Scenarios​ AnyOf Split​ Bob and Alice want to share data equally, but maintain their ability to decrypt the data without sharing each other’s private keys. With KAS Grants, they can define a key split where the shared data is wrapped with both of their public keys and AnyOf logic, meaning that each partner could decrypt the data with just one of those keys. If Bob assigns a grant between Bob's running/registered KAS to a known attribute value, and Alice defines a grant of Alice's running/registered KAS to the same attribute value, any data encrypted in a TDF will be decryptable with a key released by either of their Key Access Servers. Attribute A: https://conglomerate.com/attr/organization/value/acmeco Attribute B: https://conglomerate.com/attr/organization/value/example_inc Attribute\tNamespace\tDefinition\tValueA\tconglomerate.com\torganization\tacmeco B\tconglomerate.com\torganization\texample_inc Attribute KAS Grant Scenarios Bob &amp; Alice represent individual KAS Grants to attributes on TDF'd dataNote that the attributes A and B are of the same definition and namespace Definition: organization\tValue: acmeco\tValue: example_inc\tSplitBob, Alice\t-\t-\tOR -\tBob, Alice\t-\tOR -\t-\tBob, Alice\tOR -\tBob\tAlice\tOR AllOf Split​ Unlike the AnyOf split above, this time Bob and Alice want to make sure both of their keys must be granted for data in a TDF to be decrypted. With KAS Grants, they can define a key split where the shared data is wrapped with both of their public keys and AllOf logic, meaning that neither partner can decrypt the data with just one of those keys. To accomplish this, they each define KAS Grants between their KASes and policy attributes, and TDF data with at least two attributes - one assigned a KAS Grant to Bob's KAS and another assigned a KAS Grant to Alice's KAS. Both KASes will need to permit access and release payload keys for the data TDF'd with multiple attributes assigned KAS Grants to be accessible and decrypted. Attribute A: https://conglomerate.com/attr/organization/value/acmeco Attribute B: https://conglomerate.com/attr/department/value/marketing Attribute\tNamespace\tDefinition\tValueA\tconglomerate.com\torganization\tacmeco A\tconglomerate.com\tdepartment\tmarketing Attribute KAS Grant Scenarios Bob &amp; Alice represent individual KAS Grants to attributes on TDF'd dataNote that the attributes A and B are of the same namespace but different definitions Definition: A\tValue: A\tDefinition: B\tValue: B\tSplitBob\t-\tAlice\t-\tAND Bob\t-\t-\tAlice\tAND -\tBob\t-\tAlice\tAND [!NOTE] Any KAS Grants to attributes across different definitions or namespaces will be AND splits. Aliases kasg, kas-grant","keywords":"","version":"Next"},{"title":"Deprecated\\n\\nThis command is deprecated and will be removed in a future release. Use policy attributes namespace key remove, policy attributes key remove, or policy attributes value key remove instead.","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/kas-grants/unassign","content":"unassign - (Deprecated) Unassign a grant Synopsis otdfctl policy kas-grants unassign [flags] Description Deprecated\\n\\nThis command is deprecated and will be removed in a future release. Use policy attributes namespace key remove, policy attributes key remove, or policy attributes value key remove instead. Unassign a registered Key Access Server (KAS) to an attribute namespace, definition, or value. For more information, see kas-registry and kas-grants manuals. Example​ Namespace grant: otdfctl policy kas-grants unassign --namespace-id 3d25d33e-2469-4990-a9ed-fdd13ce74436 --kas-id 62857b55-560c-4b67-96e3-33e4670ecb3b Attribute grant: otdfctl policy kas-grants unassign --attribute-id a21eb299-3a7d-4035-8a39-c8662c03cb15 --kas-id 62857b55-560c-4b67-96e3-33e4670ecb3b Attribute value grant: otdfctl policy kas-grants unassign --value-id 0a40b27c-6cc9-49e8-a6ae-663cac2c324b --kas-id 62857b55-560c-4b67-96e3-33e4670ecb3b Options -n, --namespace-id &lt;namespace-id&gt; The ID of the Namespace being unassigned a KAS Grant (required: false) -a, --attribute-id &lt;attribute-id&gt; The ID of the Attribute Definition being unassigned the KAS grant (required: true) -v, --value-id &lt;value-id&gt; The ID of the Value being unassigned the KAS Grant (required: true) -k, --kas-id &lt;kas-id&gt; The Key Access Server (KAS) ID being unassigned a grant (required: true) --force &lt;force&gt; Force the unassignment with no confirmation (required: false) Aliases delete, remove","keywords":"","version":"Next"},{"title":"otdfctl policy kas-registry","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/kas-registry","content":"otdfctl policy kas-registry kas-registry - Manage KAS registrations Synopsis otdfctl policy kas-registry Description The Key Access Server (KAS) registry is a record of KASes safeguarding access and maintaining public keys. The registry contains critical information like each server's uri, its public key (which can be either cached or at a remote uri), and any metadata about the server. Registered Key Access Servers may grant keys for specified Namespaces, Attributes, and their Values via KAS Grants. For more information about grants and how KASs are utilized once registered, see the manual for thekas-grants command. Aliases kasr, kas-registries","keywords":"","version":"Next"},{"title":"otdfctl policy kas-registry create","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/kas-registry/create","content":"otdfctl policy kas-registry create create - Create a Key Access Server registration Synopsis otdfctl policy kas-registry create [flags] Description Examples​ otdfctl policy kas-registry create --uri http://example.com/kas --name example-kas Options -u, --uri &lt;uri&gt; URI of the Key Access Server (required: true) -c, --public-keys &lt;public-keys&gt; (Deprecated: Use otdfctl policy kas-registry keys) One or more public keys saved for the KAS (required: false) -r, --public-key-remote &lt;public-key-remote&gt; (Deprecated: Use otdfctl policy kas-registry keys) Remote URI where the public key can be retrieved for the KAS (required: false) --label &lt;label&gt; (required: false) -n, --name &lt;name&gt; Optional name of the registered KAS (must be unique within Policy) (required: false) -l, --label &lt;label&gt; Optional metadata 'labels' in the format: key=value (required: false) Aliases c, add, new","keywords":"","version":"Next"},{"title":"otdfctl policy kas-registry delete","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/kas-registry/delete","content":"otdfctl policy kas-registry delete delete - Delete a Key Access Server registration Synopsis otdfctl policy kas-registry delete [flags] Description Removes knowledge of a KAS (registration) from a platform's policy. If resource data has been TDFd utilizing key splits from the registered KAS, deletion from the registry (and therefore any associated grants) may prevent decryption depending on the type of grants and relevant key splits. Make sure you know what you are doing. For more information about registration of Key Access Servers, see the manual for kas-registry. Example​ otdfctl policy kas-registry delete --id 3c39618a-cd8c-48cf-a60c-e8a2f4be4dd5 Options -i, --id &lt;id&gt; ID of the Key Access Server registration (required: true) --force &lt;force&gt; Force deletion without interactive confirmation (dangerous) (required: false)","keywords":"","version":"Next"},{"title":"otdfctl policy kas-registry get","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/kas-registry/get","content":"otdfctl policy kas-registry get get - Get a registered Key Access Server Synopsis otdfctl policy kas-registry get [flags] Description For more information about registration of Key Access Servers, see the manual for kas-registry. Example​ otdfctl policy kas-registry get --id=62857b55-560c-4b67-96e3-33e4670ecb3b Options -i, --id &lt;id&gt; ID of the Key Access Server registration (required: true) Aliases g","keywords":"","version":"Next"},{"title":"otdfctl policy kas-registry key","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/kas-registry/key","content":"otdfctl policy kas-registry key key - Key management for KAS Registry Synopsis otdfctl policy kas-registry key Description Provides a set of subcommands for managing cryptographic keys within the Key Access Server (KAS) registry. These keys are essential for encryption and decryption operations within the OpenTDF platform. Operations include creating, retrieving, listing, updating, and managing the platform's base key. Aliases k, keys","keywords":"","version":"Next"},{"title":"otdfctl policy kas-registry key base","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/kas-registry/key/base","content":"otdfctl policy kas-registry key base base - Platform Base Key Management Synopsis otdfctl policy kas-registry key base Description Provides subcommands for managing the platform's base cryptographic key. This base key is a fallback used for encryption operations in specific scenarios: No attributes present when encrypting a fileNo keys associated with an attribute Available operations include get to retrieve the current base key and set to designate a new base key.","keywords":"","version":"Next"},{"title":"otdfctl policy kas-registry key base set","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/kas-registry/key/base/set","content":"otdfctl policy kas-registry key base set set - Set Base Key Synopsis otdfctl policy kas-registry key base set [flags] Description Command for setting a base key to be used for encryption operations on data where no attributes are present or where no keys are present on found attributes. The key to be set as the base key must be identified using its KeyID or UUID via the --key flag, and the KAS it belongs to must be specified with the --kas flag. Examples​ Set the platform base key using the internal UUID of a key from a KAS specified by its URI: otdfctl policy kas-registry key base set --key 8af2059f-5d0b-46c2-84f0-bed8a6101d90 --kas https://kas.example.com/kas otdfctl policy kas-registry key base set --key my-platform-base-key-v1 --kas primary-key-access-server Options -k, --key &lt;key&gt; The KeyID (human-readable identifier) or the internal UUID of an existing key within the specified KAS. This key will be designated as the platform base key. The system will attempt to resolve the provided value as either a UUID or a KeyID. (required: true) --kas &lt;kas&gt; Specify the Key Access Server (KAS) where the key (identified by `--key`) is registered. The KAS can be identified by its ID, URI, or Name. (required: false) Aliases s","keywords":"","version":"Next"},{"title":"otdfctl policy kas-registry key base get","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/kas-registry/key/base/get","content":"otdfctl policy kas-registry key base get get - Get Base Key Synopsis otdfctl policy kas-registry key base get Description Command for retrieving information about the currently configured platform base key. This key is used for encryption operations when no attributes are present or when attributes lack associated keys. The command will display details such as the key's identifier (KeyID or UUID) and the Key Access Server (KAS) it is registered with. Examples​ Retrieve the platform base key information in the default (human-readable) format: otdfctl policy kas-registry key base get Aliases g","keywords":"","version":"Next"},{"title":"otdfctl policy kas-registry key get","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/kas-registry/key/get","content":"otdfctl policy kas-registry key get get - Get Key Synopsis otdfctl policy kas-registry key get [flags] Description This command retrieves detailed information about a specific key registered within a Key Access Server (KAS). You must specify the key using its KeyID or UUID and the KAS it belongs to. Examples​ Retrieve details for a key identified by its UUID from a KAS specified by its URI: otdfctl policy kas-registry key get --key &quot;123e4567-e89b-12d3-a456-426614174000&quot; --kas &quot;https://kas.example.com/kas&quot; Retrieve details for a key identified by its human-readable KeyID from a KAS specified by its name, and output in JSON format: otdfctl policy kas-registry key get --key &quot;my-specific-key-v2&quot; --kas &quot;Secondary KAS&quot; --json Options -k, --key &lt;key&gt; The KeyID (human-readable identifier) or the internal UUID of the key to retrieve from the specified KAS. The system will attempt to resolve the provided value as either a UUID or a KeyID. (required: true) --kas &lt;kas&gt; Specify the Key Access Server (KAS) where the key (identified by `--key`) is registered. The KAS can be identified by its ID, URI, or Name. (required: true) Aliases g","keywords":"","version":"Next"},{"title":"otdfctl policy kas-registry key create","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/kas-registry/key/create","content":"otdfctl policy kas-registry key create create - Create Key Synopsis otdfctl policy kas-registry key create [flags] Description Creates a new cryptographic key within a specified Key Access Server (KAS). This key is primarily used for encrypting and decrypting data keys in the TDF (Trusted Data Format) ecosystem, forming a crucial part of data protection policies. Examples​ Create a key in local mode​ The KAS generates the key pair, and the private key is wrapped by the provided wrappingKey. The KAS is identified by its ID. otdfctl policy kas-registry key create --key-id &quot;aws-key&quot; --algorithm &quot;rsa:2048&quot; --mode &quot;local&quot; --kas 891cfe85-b381-4f85-9699-5f7dbfe2a9ab --wrapping-key-id &quot;virtru-stored-key&quot; --wrapping-key &quot;a8c4824daafcfa38ed0d13002e92b08720e6c4fcee67d52e954c1a6e045907d1&quot; otdfctl policy kas-registry key create --key-id &quot;aws-key&quot; --algorithm &quot;rsa:2048&quot; --mode &quot;local&quot; --kas &quot;https://test-kas.com&quot; --wrapping-key-id &quot;virtru-stored-key&quot; --wrapping-key &quot;a8c4824daafcfa38ed0d13002e92b08720e6c4fcee67d52e954c1a6e045907d1&quot; otdfctl policy kas-registry key create --key-id &quot;aws-key&quot; --algorithm &quot;rsa:2048&quot; --mode &quot;provider&quot; --kas &quot;https://test-kas.com&quot; --public-key-pem &quot;LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tXG5NSUlDL1RDQ0FlV2dBd0lCQWdJVVNIVEoyYnpBaDdkUW1tRjAzcTZJcS9uMGw5MHdEUVlKS29aSWh2Y05BUUVMXG5CUUF3RGpFTU1Bb0dBMVVFQXd3RGEyRnpNQjRYRFRJME1EWXdOakUzTkRZMU5Gb1hEVEkxTURZd05qRTNORFkxXG5ORm93RGpFTU1Bb0dBMVVFQXd3RGEyRnpNSUlCSWpBTkJna3Foa2lHOXcwQkFRRUZBQU9DQVE4QU1JSUJDZ0tDXG5BUUVBeE4zQVBpaFRpb2pjYUg2b1dqMXRNdFpNYWFaK0lBMXF0cUZtcHk1Rmc4RDViRXNQNzM2R3h6VU1Gc01WXG5zaHJLRVh6OGRZOUtwMjN1SXd5ZUMwUlBXTGU1eElmVGtKVWJ5THBxR2RsRWdxajEwUlE4a1NWcTI3MFhQRVMyXG5HWlVpajJEdUpWZndwVHBMemN0aTJQc2dFT29PS0M2Tm5uQUkwTlMxbWFvLzJEeFF4cy9EOWhBSmpHZHB6eW1iXG54aTJUeEdudllidm9mQ1BkOFJkRlRDUHZnd0tMUzcrTXFCY21pYzlWZFg5MVFOT1BtclAzcklvS3RqamQrNVBZXG5sL3o3M1BBeFIzSzNTSXpJWkx2SXRxMmFob2JPT01pU3h3OHNvT2xPZEhOVUpUcEVDY2R1aFJicXVxbUs2ZlR3XG5WT2ZyY1JRaGhVNFRrRHU5MkxJN1NnbE9XUUlEQVFBQm8xTXdVVEFkQmdOVkhRNEVGZ1FVZGd4eDdVNUFRZ2ZpXG5pUVd1M2toaTl5bmVFVm93SHdZRFZSMGpCQmd3Rm9BVWRneHg3VTVBUWdmaWlRV3Uza2hpOXluZUVWb3dEd1lEXG5WUjBUQVFIL0JBVXdBd0VCL3pBTkJna3Foa2lHOXcwQkFRc0ZBQU9DQVFFQVRjTFliSG9tSmdMUS9INmlEdmNBXG5JcElTRi9SY3hnaDdObklxUmtCK1RtNHhObE5ISXhsNFN6K0trRVpFUGgwV0tJdEdWRGozMjkzckFyUk9FT1hJXG50Vm1uMk9CdjlNLzVEUWtIajc2UnU0UFEyVGNMMENBQ2wxSktmcVhMc01jNkhIVHA4WlRQOGxNZHBXNGt6RWMzXG5mVnRndnRwSmM0V0hkVUlFekF0VGx6WVJxSWJ5eUJNV2VUalh3YTU0YU12M1JaUWRKK0MwZWh3V1REUURwaDduXG5LWTMrN0cwZW5ORVZ0eVc0ZHR4dlFRYmlkTWFueTBKRXByNlFwUG14QzhlMFoyM2RNRGRrUjFJb1Q5OVBoZFcvXG5RQzh4TWp1TENpUkVWN2E2ZTJNeENHajNmeHJuTVh3T0lxTzNBek5zd2UyYW1jb3oya3R1b3FnRFRZbG8rRmtLXG41dz09XG4tLS0tLUVORCBDRVJUSUZJQ0FURS0tLS0tXG4=&quot; --private-key-pem &quot;LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tXG5NSUlDL1RDQ0FlV2dBd0lCQWdJVVNIVEoyYnpBaDdkUW1tRjAzcTZJcS9uMGw5MHdEUVlKS29aSWh2Y05BUUVMXG5CUUF3RGpFTU1Bb0dBMVVFQXd3RGEyRnpNQjRYRFRJME1EWXdOakUzTkRZMU5Gb1hEVEkxTURZd05qRTNORFkxXG5ORm93RGpFTU1Bb0dBMVVFQXd3RGEyRnpNSUlCSWpBTkJna3Foa2lHOXcwQkFRRUZBQU9DQVE4QU1JSUJDZ0tDXG5BUUVBeE4zQVBpaFRpb2pjYUg2b1dqMXRNdFpNYWFaK0lBMXF0cUZtcHk1Rmc4RDViRXNQNzM2R3h6VU1Gc01WXG5zaHJLRVh6OGRZOUtwMjN1SXd5ZUMwUlBXTGU1eElmVGtKVWJ5THBxR2RsRWdxajEwUlE4a1NWcTI3MFhQRVMyXG5HWlVpajJEdUpWZndwVHBMemN0aTJQc2dFT29PS0M2Tm5uQUkwTlMxbWFvLzJEeFF4cy9EOWhBSmpHZHB6eW1iXG54aTJUeEdudllidm9mQ1BkOFJkRlRDUHZnd0tMUzcrTXFCY21pYzlWZFg5MVFOT1BtclAzcklvS3RqamQrNVBZXG5sL3o3M1BBeFIzSzNTSXpJWkx2SXRxMmFob2JPT01pU3h3OHNvT2xPZEhOVUpUcEVDY2R1aFJicXVxbUs2ZlR3XG5WT2ZyY1JRaGhVNFRrRHU5MkxJN1NnbE9XUUlEQVFBQm8xTXdVVEFkQmdOVkhRNEVGZ1FVZGd4eDdVNUFRZ2ZpXG5pUVd1M2toaTl5bmVFVm93SHdZRFZSMGpCQmd3Rm9BVWRneHg3VTVBUWdmaWlRV3Uza2hpOXluZUVWb3dEd1lEXG5WUjBUQVFIL0JBVXdBd0VCL3pBTkJna3Foa2lHOXcwQkFRc0ZBQU9DQVFFQVRjTFliSG9tSmdMUS9INmlEdmNBXG5JcElTRi9SY3hnaDdObklxUmtCK1RtNHhObE5ISXhsNFN6K0trRVpFUGgwV0tJdEdWRGozMjkzckFyUk9FT1hJXG50Vm1uMk9CdjlNLzVEUWtIajc2UnU0UFEyVGNMMENBQ2wxSktmcVhMc01jNkhIVHA4WlRQOGxNZHBXNGt6RWMzXG5mVnRndnRwSmM0V0hkVUlFekF0VGx6WVJxSWJ5eUJNV2VUalh3YTU0YU12M1JaUWRKK0MwZWh3V1REUURwaDduXG5LWTMrN0cwZW5ORVZ0eVc0ZHR4dlFRYmlkTWFueTBKRXByNlFwUG14QzhlMFoyM2RNRGRrUjFJb1Q5OVBoZFcvXG5RQzh4TWp1TENpUkVWN2E2ZTJNeENHajNmeHJuTVh3T0lxTzNBek5zd2UyYW1jb3oya3R1b3FnRFRZbG8rRmtLXG41dz09XG4tLS0tLUVORCBDRVJUSUZJQ0FURS0tLS0tXG4=&quot; --wrapping-key-id &quot;openbao-key&quot; --provider-config-id &quot;f86b166a-98a5-407a-939f-ef84916ce1e5&quot; otdfctl policy kas-registry key create --key-id &quot;aws-key&quot; --algorithm &quot;rsa:2048&quot; --mode &quot;remote&quot; --kas &quot;https://test-kas.com&quot; --wrapping-key-id &quot;openbao-key&quot; --provider-config-id &quot;f86b166a-98a5-407a-939f-ef84916ce1e5&quot; --public-key-pem &quot;LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tXG5NSUlDL1RDQ0FlV2dBd0lCQWdJVVNIVEoyYnpBaDdkUW1tRjAzcTZJcS9uMGw5MHdEUVlKS29aSWh2Y05BUUVMXG5CUUF3RGpFTU1Bb0dBMVVFQXd3RGEyRnpNQjRYRFRJME1EWXdOakUzTkRZMU5Gb1hEVEkxTURZd05qRTNORFkxXG5ORm93RGpFTU1Bb0dBMVVFQXd3RGEyRnpNSUlCSWpBTkJna3Foa2lHOXcwQkFRRUZBQU9DQVE4QU1JSUJDZ0tDXG5BUUVBeE4zQVBpaFRpb2pjYUg2b1dqMXRNdFpNYWFaK0lBMXF0cUZtcHk1Rmc4RDViRXNQNzM2R3h6VU1Gc01WXG5zaHJLRVh6OGRZOUtwMjN1SXd5ZUMwUlBXTGU1eElmVGtKVWJ5THBxR2RsRWdxajEwUlE4a1NWcTI3MFhQRVMyXG5HWlVpajJEdUpWZndwVHBMemN0aTJQc2dFT29PS0M2Tm5uQUkwTlMxbWFvLzJEeFF4cy9EOWhBSmpHZHB6eW1iXG54aTJUeEdudllidm9mQ1BkOFJkRlRDUHZnd0tMUzcrTXFCY21pYzlWZFg5MVFOT1BtclAzcklvS3RqamQrNVBZXG5sL3o3M1BBeFIzSzNTSXpJWkx2SXRxMmFob2JPT01pU3h3OHNvT2xPZEhOVUpUcEVDY2R1aFJicXVxbUs2ZlR3XG5WT2ZyY1JRaGhVNFRrRHU5MkxJN1NnbE9XUUlEQVFBQm8xTXdVVEFkQmdOVkhRNEVGZ1FVZGd4eDdVNUFRZ2ZpXG5pUVd1M2toaTl5bmVFVm93SHdZRFZSMGpCQmd3Rm9BVWRneHg3VTVBUWdmaWlRV3Uza2hpOXluZUVWb3dEd1lEXG5WUjBUQVFIL0JBVXdBd0VCL3pBTkJna3Foa2lHOXcwQkFRc0ZBQU9DQVFFQVRjTFliSG9tSmdMUS9INmlEdmNBXG5JcElTRi9SY3hnaDdObklxUmtCK1RtNHhObE5ISXhsNFN6K0trRVpFUGgwV0tJdEdWRGozMjkzckFyUk9FT1hJXG50Vm1uMk9CdjlNLzVEUWtIajc2UnU0UFEyVGNMMENBQ2wxSktmcVhMc01jNkhIVHA4WlRQOGxNZHBXNGt6RWMzXG5mVnRndnRwSmM0V0hkVUlFekF0VGx6WVJxSWJ5eUJNV2VUalh3YTU0YU12M1JaUWRKK0MwZWh3V1REUURwaDduXG5LWTMrN0cwZW5ORVZ0eVc0ZHR4dlFRYmlkTWFueTBKRXByNlFwUG14QzhlMFoyM2RNRGRrUjFJb1Q5OVBoZFcvXG5RQzh4TWp1TENpUkVWN2E2ZTJNeENHajNmeHJuTVh3T0lxTzNBek5zd2UyYW1jb3oya3R1b3FnRFRZbG8rRmtLXG41dz09XG4tLS0tLUVORCBDRVJUSUZJQ0FURS0tLS0tXG4=&quot; otdfctl policy kas-registry key create --key-id &quot;aws-key&quot; --algorithm &quot;rsa:2048&quot; --mode &quot;public_key&quot; --kas &quot;https://test-kas.com&quot; --public-key-pem &quot;LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tXG5NSUlDL1RDQ0FlV2dBd0lCQWdJVVNIVEoyYnpBaDdkUW1tRjAzcTZJcS9uMGw5MHdEUVlKS29aSWh2Y05BUUVMXG5CUUF3RGpFTU1Bb0dBMVVFQXd3RGEyRnpNQjRYRFRJME1EWXdOakUzTkRZMU5Gb1hEVEkxTURZd05qRTNORFkxXG5ORm93RGpFTU1Bb0dBMVVFQXd3RGEyRnpNSUlCSWpBTkJna3Foa2lHOXcwQkFRRUZBQU9DQVE4QU1JSUJDZ0tDXG5BUUVBeE4zQVBpaFRpb2pjYUg2b1dqMXRNdFpNYWFaK0lBMXF0cUZtcHk1Rmc4RDViRXNQNzM2R3h6VU1Gc01WXG5zaHJLRVh6OGRZOUtwMjN1SXd5ZUMwUlBXTGU1eElmVGtKVWJ5THBxR2RsRWdxajEwUlE4a1NWcTI3MFhQRVMyXG5HWlVpajJEdUpWZndwVHBMemN0aTJQc2dFT29PS0M2Tm5uQUkwTlMxbWFvLzJEeFF4cy9EOWhBSmpHZHB6eW1iXG54aTJUeEdudllidm9mQ1BkOFJkRlRDUHZnd0tMUzcrTXFCY21pYzlWZFg5MVFOT1BtclAzcklvS3RqamQrNVBZXG5sL3o3M1BBeFIzSzNTSXpJWkx2SXRxMmFob2JPT01pU3h3OHNvT2xPZEhOVUpUcEVDY2R1aFJicXVxbUs2ZlR3XG5WT2ZyY1JRaGhVNFRrRHU5MkxJN1NnbE9XUUlEQVFBQm8xTXdVVEFkQmdOVkhRNEVGZ1FVZGd4eDdVNUFRZ2ZpXG5pUVd1M2toaTl5bmVFVm93SHdZRFZSMGpCQmd3Rm9BVWRneHg3VTVBUWdmaWlRV3Uza2hpOXluZUVWb3dEd1lEXG5WUjBUQVFIL0JBVXdBd0VCL3pBTkJna3Foa2lHOXcwQkFRc0ZBQU9DQVFFQVRjTFliSG9tSmdMUS9INmlEdmNBXG5JcElTRi9SY3hnaDdObklxUmtCK1RtNHhObE5ISXhsNFN6K0trRVpFUGgwV0tJdEdWRGozMjkzckFyUk9FT1hJXG50Vm1uMk9CdjlNLzVEUWtIajc2UnU0UFEyVGNMMENBQ2wxSktmcVhMc01jNkhIVHA4WlRQOGxNZHBXNGt6RWMzXG5mVnRndnRwSmM0V0hkVUlFekF0VGx6WVJxSWJ5eUJNV2VUalh3YTU0YU12M1JaUWRKK0MwZWh3V1REUURwaDduXG5LWTMrN0cwZW5ORVZ0eVc0ZHR4dlFRYmlkTWFueTBKRXByNlFwUG14QzhlMFoyM2RNRGRrUjFJb1Q5OVBoZFcvXG5RQzh4TWp1TENpUkVWN2E2ZTJNeENHajNmeHJuTVh3T0lxTzNBek5zd2UyYW1jb3oya3R1b3FnRFRZbG8rRmtLXG41dz09XG4tLS0tLUVORCBDRVJUSUZJQ0FURS0tLS0tXG4=&quot; The &quot;algorithm&quot; specifies the key algorithm: Key Algorithmrsa:2048 rsa:4096 ec:secp256r1 ec:secp384r1 ec:secp521r1 The &quot;mode&quot; specifies where the key that is encrypting TDFs is stored. All keys will be encrypted when stored in Virtru's DB, for modes &quot;local&quot; and &quot;provider&quot; Mode\tDescriptionlocal\tRoot Key is stored within Virtru's database and the symmetric wrapping key is stored in KAS provider\tRoot Key is stored within Virtru's database and the symmetric wrapping key is stored externally remote\tRoot Key and wrapping key are stored remotely public_key\tRoot Key and wrapping key are stored remotely. Use this when importing another org's policy information Options --key-id &lt;key-id&gt; A unique, often human-readable, identifier for the new key to be created. (required: true) -a, --algorithm &lt;algorithm&gt; Algorithm for the new key (see table below for options). (required: true) -m, --mode &lt;mode&gt; Describes how the private key is managed (see table below for options). (required: true) --kas &lt;kas&gt; Specify the Key Access Server (KAS) where the new key will be created. The KAS can be identified by its ID, URI, or Name. (required: true) --wrapping-key-id &lt;wrapping-key-id&gt; Identifier related to the wrapping key. Its meaning depends on the `mode`. For `local` mode, it's a descriptive ID for the `wrappingKey` you provide. For `provider` or `remote` mode, it's the ID of the key within the external provider/system used for wrapping. (required: false) -w, --wrapping-key &lt;wrapping-key&gt; The symmetric key material (AES cipher, hex encoded) used to wrap the generated private key. Primarily used when `mode` is `local`. (required: false) --private-key-pem &lt;private-key-pem&gt; The private key PEM (encrypted by an AES 32-byte key, then base64 encoded). Used when importing an existing key pair, typically with `provider` mode. (required: false) -p, --provider-config-id &lt;provider-config-id&gt; Configuration ID for the key provider. Often required when `mode` is `provider` or `remote` and an external key provider is used. (required: false) -e, --public-key-pem &lt;public-key-pem&gt; The base64 encoded public key PEM. Required for `remote` and `public_key` modes, and can be used with `provider` mode if importing an existing key pair. (required: false) -l, --label &lt;label&gt; Comma-separated key=value pairs for metadata labels to associate with the new key (e.g., &quot;owner=team-a,env=production&quot;). (required: false) Aliases c","keywords":"","version":"Next"},{"title":"otdfctl policy kas-registry key list-mappings","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/kas-registry/key/list-mappings","content":"otdfctl policy kas-registry key list-mappings list-mappings - List Key Mappings Synopsis otdfctl policy kas-registry key list-mappings [flags] Description This command lists key mappings. You can list all key mappings, or filter by a specific key. To filter by a key, you can either provide the system ID of the key, or the user-defined key ID along with the KAS identifier. The list is paginated, so you must provide limit and offset flags. Examples​ List the first 10 key mappings: otdfctl policy kas-registry key list-mappings --limit 10 --offset 0 List key mappings for a key with a specific system ID: otdfctl policy kas-registry key list-mappings --id &quot;cc8bf36a-8c76-4c8c-9723-3c0d1ce897b8&quot; --limit 10 --offset 0 List key mappings for a key with a user-defined ID within a KAS specified by its URI: otdfctl policy kas-registry key list-mappings --key-id &quot;my-key&quot; --kas &quot;https://kas.example.com/kas&quot; --limit 10 --offset 0 Options -l, --limit &lt;limit&gt; Maximum number of key mappings to return (required: true) -o, --offset &lt;offset&gt; Offset (page) quantity from start of the list (required: true) -i, --id &lt;id&gt; The system ID of the key for which to list mappings. (required: false) --key-id &lt;key-id&gt; The user-defined ID of the key for which to list mappings. Must be used with --kas. (required: false) --kas &lt;kas&gt; Specify the Key Access Server (KAS) where the key (identified by `--key-id`) is registered. The KAS can be identified by its ID, URI, or Name. (required: false) Aliases m","keywords":"","version":"Next"},{"title":"otdfctl policy kas-registry key list","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/kas-registry/key/list","content":"otdfctl policy kas-registry key list list - List Keys Synopsis otdfctl policy kas-registry key list [flags] Description This command lists keys registered within a specified Key Access Server (KAS). You must specify the KAS using its ID, URI, or Name. The list can be filtered by key algorithm. Pagination is supported using limit and offset flags to manage the number of results returned. Examples​ List the first 10 keys from a KAS specified by its URI: otdfctl policy kas-registry key list --kas &quot;https://kas.example.com/kas&quot; --limit 10 --offset 0 List keys from a KAS named &quot;Primary KAS&quot;, filtering for keys using the &quot;RSA:2048&quot; algorithm, and output in JSON format: otdfctl policy kas-registry key list --kas &quot;Primary KAS&quot; --alg &quot;RSA:2048&quot; --limit 20 --offset 0 --json List the next 5 keys (skipping the first 5) from a KAS identified by its ID: otdfctl policy kas-registry key list --kas &quot;kas-id-12345&quot; --limit 5 --offset 5 List only legacy keys otdfctl policy kas-registry key list --legacy true Exclude legacy keys otdfctl policy kas-registry key list --legacy false Options -l, --limit &lt;limit&gt; Maximum number of keys to return (required: true) -o, --offset &lt;offset&gt; Number of keys to skip before starting to return results (required: true) -a, --algorithm &lt;algorithm&gt; Key Algorithm to filter for (required: false) --kas &lt;kas&gt; Specify the Key Access Server (KAS) where the key (identified by `--key`) is registered. The KAS can be identified by its ID, URI, or Name. (required: false) --legacy &lt;legacy&gt; Filter keys by legacy status. (required: false) Aliases l","keywords":"","version":"Next"},{"title":"otdfctl policy kas-registry key import","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/kas-registry/key/import","content":"otdfctl policy kas-registry key import import - Import Key Synopsis otdfctl policy kas-registry key import [flags] Description Imports an existing cryptographic key into a specified Key Access Server (KAS). [!IMPORTANT] Use this command when migrating keys from KAS over to the platform. All keys created with import will be of key_mode=KEY_MODE_CONFIG_ROOT_KEY Examples​ Import a key​ otdfctl policy kas-registry key import --key-id &quot;imported-key&quot; --algorithm &quot;rsa:2048&quot; \\ --kas 891cfe85-b381-4f85-9699-5f7dbfe2a9ab \\ --wrapping-key-id &quot;my-wrapping-key&quot; \\ --wrapping-key &quot;a8c4824daafcfa38ed0d13002e92b08720e6c4fcee67d52e954c1a6e045907d1&quot; \\ --public-key-pem &lt;base64 encoded public key pem&gt; \\ --private-key-pem &lt;base64 encoded private key pem&gt; \\ Import a legacy key​ otdfctl policy kas-registry key import --key-id &quot;imported-key&quot; --algorithm &quot;rsa:2048&quot; \\ --kas 891cfe85-b381-4f85-9699-5f7dbfe2a9ab \\ --wrapping-key-id &quot;my-wrapping-key&quot; \\ --wrapping-key &quot;a8c4824daafcfa38ed0d13002e92b08720e6c4fcee67d52e954c1a6e045907d1&quot; \\ --public-key-pem &lt;base64 encoded public key pem&gt; \\ --private-key-pem &lt;base64 encoded private key pem&gt; \\ --legacy true The algorithm specifies the key algorithm: Key Algorithmrsa:2048 rsa:4096 ec:secp256r1 ec:secp384r1 ec:secp521r1 Options --key-id &lt;key-id&gt; A unique, often human-readable, identifier for the key being imported. (required: true) -a, --algorithm &lt;algorithm&gt; Algorithm for the key being imported (see table below for options). (required: true) --kas &lt;kas&gt; Specify the Key Access Server (KAS) where the key will be imported. The KAS can be identified by its ID, URI, or Name. (required: true) --wrapping-key-id &lt;wrapping-key-id&gt; Identifier related to the wrapping key. (required: true) -w, --wrapping-key &lt;wrapping-key&gt; The symmetric key material (AES cipher, hex encoded) used to wrap the imported private key. (required: true) --private-key-pem &lt;private-key-pem&gt; The base64 encoded private key PEM to import (required: true) -e, --public-key-pem &lt;public-key-pem&gt; The base64 encoded public key PEM to import (required: true) --legacy &lt;legacy&gt; Mark the imported key as a legacy key. (required: false) -l, --label &lt;label&gt; Comma-separated key=value pairs for metadata labels to associate with the imported key (e.g., &quot;owner=team-a,env=production&quot;). (required: false) Aliases i","keywords":"","version":"Next"},{"title":"Unsafe Delete Warning","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/kas-registry/key/unsafe/delete","content":"delete - Delete a key Synopsis otdfctl policy kas-registry key unsafe delete [flags] Description Unsafe Delete Warning Deleting a key is a destructive operation. Any existing TDFs encrypted with this key will be rendered inaccessible. Make sure you know what you are doing. Example​ otdfctl policy kas-keys unsafe delete --id 3c51a593-cbf8-419d-b7dc-b656d0bedfbb --kas-uri https://kas.example.com --key-id &quot;key-1&quot; Options -i, --id &lt;id&gt; Sytem given ID of the key (required: true) --kas-uri &lt;kas-uri&gt; The URI of the KAS instance (required: true) --key-id &lt;key-id&gt; The ID of the key assigned by the admin (required: true)","keywords":"","version":"Next"},{"title":"otdfctl policy kas-registry key unsafe","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/kas-registry/key/unsafe","content":"otdfctl policy kas-registry key unsafe unsafe - Unsafe changes to keys Synopsis otdfctl policy kas-registry key unsafe [flags] Description Unsafe changes are dangerous mutations to KAS that can significantly change access behavior around existing keys and entitlement. Depending on the unsafe change introduced and already existing TDFs, TDFs might become inaccessible that were previously accessible or vice versa. Make sure you know what you are doing. Options --force &lt;force&gt; Force unsafe change without confirmation (required: false)","keywords":"","version":"Next"},{"title":"otdfctl policy kas-registry key update","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/kas-registry/key/update","content":"otdfctl policy kas-registry key update update - Update Key Access Server Key Synopsis otdfctl policy kas-registry key update [flags] Description This command updates the key for an existing key registered in a Key Access Server (KAS). You must identify the key using its UUID via the --id flag. Currently, this command primarily supports updating the metadata labels associated with the key. Examples​ Update key identified by its UUID: otdfctl policy kas-registry key update --id &quot;123e4567-e89b-12d3-a456-426614174000&quot; --label &quot;status=active,project=phoenix&quot; Options -i, --id &lt;id&gt; The internal UUID of the key to be updated. (required: true) -l, --label &lt;label&gt; Comma-separated key=value pairs for metadata labels (e.g., &quot;owner=team-a,env=production&quot;). Providing new labels will replace any existing labels on the key. (required: false) Aliases u","keywords":"","version":"Next"},{"title":"otdfctl policy kas-registry key rotate","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/kas-registry/key/rotate","content":"otdfctl policy kas-registry key rotate rotate - Rotate Key Synopsis otdfctl policy kas-registry key rotate [flags] Description Rotates a cryptographic key within a specified Key Access Server (KAS). This command replaces an existing key with a new one while maintaining references to the old key to ensure data encrypted with the old key can still be decrypted. Examples​ Rotate a key in local mode​ Rotate an existing key to a new key in local mode, where the KAS generates the key pair and the private key is wrapped by the provided wrappingKey: otdfctl policy kas-registry key rotate --key &quot;old-key-id&quot; --kas &quot;https://kas.example.com/kas&quot; --key-id &quot;new-key-v2&quot; --algorithm &quot;rsa:2048&quot; --mode &quot;local&quot; --wrapping-key-id &quot;virtru-stored-key&quot; --wrapping-key &quot;YWVzIGtleQ==&quot; Rotate a key in provider mode​ otdfctl policy kas-registry key rotate --key &quot;123e4567-e89b-12d3-a456-426614174000&quot; --kas &quot;https://kas.example.com/kas&quot; --key-id &quot;provider-key-v2&quot; --algorithm &quot;rsa:2048&quot; --mode &quot;provider&quot; --public-key-pem &quot;LS0tLS1CRUdJTi...&quot; --private-key-pem &quot;LS0tLS1CRUdJTi...&quot; --wrapping-key-id &quot;openbao-key&quot; --provider-config-id &quot;f86b166a-98a5-407a-939f-ef84916ce1e5&quot; Rotate a key in remote mode​ otdfctl policy kas-registry key rotate --key &quot;my-remote-key&quot; --kas &quot;Secondary KAS&quot; --key-id &quot;remote-key-v2&quot; --algorithm &quot;rsa:2048&quot; --mode &quot;remote&quot; --wrapping-key-id &quot;openbao-key&quot; --provider-config-id &quot;f86b166a-98a5-407a-939f-ef84916ce1e5&quot; --public-key-pem &quot;LS0tLS1CRUdJTi...&quot; Rotate a key in public_key mode​ otdfctl policy kas-registry key rotate --key &quot;public-key-old&quot; --kas &quot;Secondary KAS&quot; --key-id &quot;public-key-v2&quot; --algorithm &quot;rsa:2048&quot; --mode &quot;public_key&quot; --public-key-pem &quot;LS0tLS1CRUdJTi...&quot; Key Algorithms and Modes​ The &quot;algorithm&quot; specifies the key algorithm: Key Algorithmrsa:2048 rsa:4096 ec:secp256r1 ec:secp384r1 ec:secp521r1 The &quot;mode&quot; specifies where the key that is encrypting TDFs is stored. All keys will be encrypted when stored in Virtru's DB, for modes &quot;local&quot; and &quot;provider&quot; Mode\tDescriptionlocal\tRoot Key is stored within Virtru's database and the symmetric wrapping key is stored in KAS provider\tRoot Key is stored within Virtru's database and the symmetric wrapping key is stored externally remote\tRoot Key and wrapping key are stored remotely public_key\tRoot Key and wrapping key are stored remotely. Use this when importing another org's policy information Options -k, --key &lt;key&gt; The KeyID (human-readable identifier) or the internal UUID of the existing key to rotate from the specified KAS. The system will attempt to resolve the provided value as either a UUID or a KeyID. (required: true) --kas &lt;kas&gt; Specify the Key Access Server (KAS) where the key is registered. The KAS can be identified by its ID, URI, or Name. (required: true) --key-id &lt;key-id&gt; A unique, often human-readable, identifier for the new key to be created. (required: true) -a, --algorithm &lt;algorithm&gt; Algorithm for the new key (see table below for options). (required: true) -m, --mode &lt;mode&gt; Describes how the private key is managed (see table below for options). (required: true) --wrapping-key-id &lt;wrapping-key-id&gt; Identifier related to the wrapping key. Its meaning depends on the `mode`. For `local` mode, it's a descriptive ID for the `wrappingKey` you provide. For `provider` or `remote` mode, it's the ID of the key within the external provider/system used for wrapping. (required: false) -w, --wrapping-key &lt;wrapping-key&gt; The symmetric key material (AES cipher, base64 encoded) used to wrap the generated private key. Primarily used when `mode` is `local`. (required: false) --private-key-pem &lt;private-key-pem&gt; The private key PEM (encrypted by an AES 32-byte key, then base64 encoded). Used when importing an existing key pair, typically with `provider` mode. (required: false) -p, --provider-config-id &lt;provider-config-id&gt; Configuration ID for the key provider. Often required when `mode` is `provider` or `remote` and an external key provider is used. (required: false) -e, --public-key-pem &lt;public-key-pem&gt; The base64 encoded public key PEM. Required for `remote` and `public_key` modes, and can be used with `provider` mode if importing an existing key pair. (required: false) -l, --label &lt;label&gt; Comma-separated key=value pairs for metadata labels to associate with the new key (e.g., &quot;owner=team-a,env=production&quot;). (required: false) Aliases r","keywords":"","version":"Next"},{"title":"otdfctl policy kas-registry update","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/kas-registry/update","content":"otdfctl policy kas-registry update update - Update a Key Access Server registration Synopsis otdfctl policy kas-registry update [flags] Description Update the uri, metadata, or key material (remote/cached) for a KAS registered to the platform. If resource data has been TDFd utilizing key splits from the registered KAS, deletion from the registry (and therefore any associated grants) may prevent decryption depending on the type of grants and relevant key splits. Make sure you know what you are doing. For more information about registration of Key Access Servers, see the manual for kas-registry. Example​ otdfctl policy kas-registry update --id 3c39618a-cd8c-48cf-a60c-e8a2f4be4dd5 --name example-kas2-newname --public-key-remote &quot;https://example.com/kas2/new_public_key&quot; Options -i, --id &lt;id&gt; ID of the Key Access Server registration (required: true) -u, --uri &lt;uri&gt; URI of the Key Access Server (required: false) -c, --public-keys &lt;public-keys&gt; One or more 'cached' public keys saved for the KAS (required: false) -r, --public-key-remote &lt;public-key-remote&gt; URI of the 'remote' public key of the Key Access Server (required: false) -n, --name &lt;name&gt; Optional name of the registered KAS (must be unique within Policy) (required: false) -l, --label &lt;label&gt; Optional metadata 'labels' in the format: key=value (required: false) --force-replace-labels &lt;force-replace-labels&gt; Destructively replace entire set of existing metadata 'labels' with any provided to this command (required: false) Aliases u","keywords":"","version":"Next"},{"title":"otdfctl policy kas-registry list","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/kas-registry/list","content":"otdfctl policy kas-registry list list - List Key Access Server registrations Synopsis otdfctl policy kas-registry list [flags] Description For more information about registration of Key Access Servers, see the manual for kas-registry. Example​ otdfctl policy kas-registry list Options -l, --limit &lt;limit&gt; Limit retrieved count (required: false) -o, --offset &lt;offset&gt; Offset (page) quantity from start of the list (required: false) Aliases l","keywords":"","version":"Next"},{"title":"otdfctl policy key-management","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/key-management","content":"otdfctl policy key-management keymanagement - Key management Synopsis otdfctl policy key-management [flags] Description Set of commands for managing key configuration, currently supports managing key provider configuration via the provider command. Options --json &lt;json&gt; output single command in JSON (overrides configured output format) (required: false) (default: false) Aliases k","keywords":"","version":"Next"},{"title":"otdfctl policy key-management provider create","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/key-management/provider/create","content":"otdfctl policy key-management provider create create - Create a Provider Config Synopsis otdfctl policy key-management provider create [flags] Description Creates a new provider config with the specified name and configuration. Examples​ otdfctl keymanagement provider create --name &lt;name&gt; --config &lt;json-config&gt; otdfctl keymanagement provider create --name aws --config `{&quot;region&quot;: &quot;us-west-2&quot;}` Options -n, --name &lt;name&gt; Name of the provider config to create (required: true) -m, --manager &lt;manager&gt; Key Manager for the provider config (required: true) -c, --config &lt;config&gt; JSON configuration for the provider (required: true) -l, --label &lt;label&gt; Metadata labels for the provider config (required: false) Aliases c","keywords":"","version":"Next"},{"title":"otdfctl policy key-management provider delete","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/key-management/provider/delete","content":"otdfctl policy key-management provider delete delete - Delete a Provider Config Synopsis otdfctl policy key-management provider delete [flags] Description Deletes a provider config by its unique ID. Examples​ otdfctl keymanagement provider delete --id &lt;provider-config-id&gt; otdfctl keymanagement provider delete --id '04ba179c-2f77-4e0d-90c5-fe4d1c9aa3f7' otdfctl keymanagement provider delete --id '04ba179c-2f77-4e0d-90c5-fe4d1c9aa3f7' --force Options -f, --force &lt;force&gt; Force the deletion of a provider configuration without confirmation (required: false) -i, --id &lt;id&gt; ID of the provider config to delete (required: true) Aliases d, remove","keywords":"","version":"Next"},{"title":"otdfctl policy key-management provider","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/key-management/provider","content":"otdfctl policy key-management provider provider - Provider configuration for Key Management Synopsis otdfctl policy key-management provider Description Commands used for managing a key providers configuration. You should register key providers when creating keys where the key is either: Wrapped by a key stored outside of your KAS server. For example. if you created a key that is of mode``providerThe actual wrapped key is not stored within the platform database, but a reference to the key is. For example, if you created a key that is of mode remote. You should not create provider configurations for keys of mode: localpublic_key Aliases p","keywords":"","version":"Next"},{"title":"otdfctl policy key-management provider list","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/key-management/provider/list","content":"otdfctl policy key-management provider list list - List Provider Configs Synopsis otdfctl policy key-management provider list [flags] Description Lists all provider configs with pagination support. Examples​ otdfctl keymanagement provider list --limit 10 --offset 0 Options -l, --limit &lt;limit&gt; Maximum number of results to return (required: true) -o, --offset &lt;offset&gt; Offset for pagination (required: true) Aliases l","keywords":"","version":"Next"},{"title":"otdfctl policy key-management provider update","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/key-management/provider/update","content":"otdfctl policy key-management provider update update - Update a Provider Config Synopsis otdfctl policy key-management provider update [flags] Description Updates an existing provider config with the specified parameters. Examples​ otdfctl keymanagement provider update --id &lt;id&gt; --name &lt;new-name&gt; --config &lt;new-json-config&gt; otdfctl keymanagement provider update --id '04ba179c-2f77-4e0d-90c5-fe4d1c9aa3f7' --name 'gcp' --config `{&quot;region&quot;: &quot;us-west-2&quot;}` Options -i, --id &lt;id&gt; ID of the provider config to update (required: true) -n, --name &lt;name&gt; New name for the provider config (required: false) -m, --manager &lt;manager&gt; New key manager for the provider config (required: false) -c, --config &lt;config&gt; New JSON configuration for the provider (required: false) -l, --label &lt;label&gt; Metadata labels for the provider config (required: false) Aliases u","keywords":"","version":"Next"},{"title":"otdfctl policy key-management provider get","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/key-management/provider/get","content":"otdfctl policy key-management provider get get - Get a Provider Config Synopsis otdfctl policy key-management provider get [flags] Description Retrieves a provider config by its ID or name. Examples​ otdfctl keymanagement provider get --id '04ba179c-2f77-4e0d-90c5-fe4d1c9aa3f7' Options -i, --id &lt;id&gt; ID of the provider config to retrieve (required: false) -n, --name &lt;name&gt; Name of the provider config to retrieve (required: false) Aliases g","keywords":"","version":"Next"},{"title":"otdfctl policy obligations","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/obligations","content":"otdfctl policy obligations obligations - Manage obligations Synopsis otdfctl policy obligations Description Obligations enable conditional access enforcement at the Policy Enforcement Point (PEP) level and allow security administrators to enforce additional restrictions beyond basic attribute-based access control (ABAC), such as requiring multi-factor authentication (MFA), enforcing watermarking, or applying time-based access expiration. Aliases obl","keywords":"","version":"Next"},{"title":"otdfctl policy obligations create","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/obligations/create","content":"otdfctl policy obligations create create - Create an obligation definition Synopsis otdfctl policy obligations create [flags] Description Add an obligation definition to the platform Policy. For more information, see the obligations subcommand. Examples​ Create an obligation definition named 'my_obligation' with value 'my_value': otdfctl policy obligations create --name my_obligation --value my_value Options -n, --name &lt;name&gt; Name of the obligation (must be unique within a Namespace) (required: true) -s, --namespace &lt;namespace&gt; Namespace ID or FQN (required: true) -v, --value &lt;value&gt; Value of the obligation (i.e. 'value1', must be unique within the Obligation) (required: false) -l, --label &lt;label&gt; Optional metadata 'labels' in the format: key=value (required: false) Aliases c, add, new","keywords":"","version":"Next"},{"title":"otdfctl policy obligations list","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/obligations/list","content":"otdfctl policy obligations list list - List obligation definitions Synopsis otdfctl policy obligations list [flags] Description List obligations definitions (optionally by namespace). For more information about obligations, see the obligations subcommand. Example​ otdfctl policy obligations list --limit 10 --offset 0 Options -l, --limit &lt;limit&gt; Limit retrieved count (required: false) -o, --offset &lt;offset&gt; Offset (page) quantity from start of the list (required: false) -n, --namespace &lt;namespace&gt; Namespace ID or FQN by which to filter results (required: false) Aliases l","keywords":"","version":"Next"},{"title":"otdfctl policy obligations delete","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/obligations/delete","content":"otdfctl policy obligations delete delete - Delete an obligation definition Synopsis otdfctl policy obligations delete [flags] Description Removes an obligation definition from platform Policy. Obligation deletion cascades to the associated obligation values. For more information about obligations, see the manual for the obligations subcommand. Example​ Delete by ID: otdfctl policy obligations delete --id 217b300a-47f9-4bee-be8c-d38c880053f7 Delete by FQN: otdfctl policy obligations delete --fqn &quot;https://namespace.com/obl/name/drm&quot; Options -i, --id &lt;id&gt; ID of the obligation (required: false) -f, --fqn &lt;fqn&gt; FQN of the obligation (required: false) --force &lt;force&gt; Force deletion without interactive confirmation (required: false)","keywords":"","version":"Next"},{"title":"otdfctl policy obligations get","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/obligations/get","content":"otdfctl policy obligations get get - Get an obligation definition Synopsis otdfctl policy obligations get [flags] Description Retrieve an obligation definition along with its metadata and values. If both id and fqn flag values are provided, id is preferred. For more information about obligations, see the manual for the obligations subcommand. Example​ Get by ID: otdfctl policy obligations get --id=3c51a593-cbf8-419d-b7dc-b656d0bedfbb Get by FQN: otdfctl policy obligations get --fqn=https://namespace.com/obl/drm Options -i, --id &lt;id&gt; ID of the obligation (required: false) -f, --fqn &lt;fqn&gt; FQN of the obligation (required: false) Aliases g","keywords":"","version":"Next"},{"title":"otdfctl policy obligations triggers","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/obligations/triggers","content":"otdfctl policy obligations triggers triggers - Manage obligation triggers Synopsis otdfctl policy obligations triggers Description Obligations triggers are the link between an attribute value, a PEPs intended action on a TDF, and what the PEP is obliged to do.","keywords":"","version":"Next"},{"title":"otdfctl policy obligations update","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/obligations/update","content":"otdfctl policy obligations update update - Update an obligation definition Synopsis otdfctl policy obligations update [flags] Description Update the name and/or metadata labels for an obligation definition. If PEPs rely on this obligation name, a name update could break access. Make sure you know what you are doing. For more information about obligations, see the obligations subcommand. Example​ otdfctl policy obligations update --id 34c62145-5d99-45cb-a732-13cb16270e63 --name new_obligation_name Options -i, --id &lt;id&gt; ID of the obligation to update (required: true) -n, --name &lt;name&gt; Optional updated name of the obligation (must be unique within the Namespace) (required: false) -l, --label &lt;label&gt; Optional metadata 'labels' in the format: key=value (required: false) --force-replace-labels &lt;force-replace-labels&gt; Destructively replace entire set of existing metadata 'labels' with any provided to this command (required: false) Aliases u","keywords":"","version":"Next"},{"title":"otdfctl policy obligations triggers create","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/obligations/triggers/create","content":"otdfctl policy obligations triggers create create - Create an obligation trigger Synopsis otdfctl policy obligations triggers create [flags] Description Add an obligation trigger to the platform Policy with our without a client identifier. [!NOTE] Creating an obligation trigger with a client-id scopes the trigger to a specific policy enforcement point, which is identified through the requestor's authentication token. Scoping a trigger to a specific client does two things: If the requesting application is NOT scoped to the trigger, it will not be used in the authorization decisioning and the obligation does not need to be fulfilled.If the requesting application IS scoped to the trigger, the application must be able to fulfill the obligation the trigger is mapped to. Examples​ Create an obligation trigger with FQNs/Names: otdfctl policy obligations triggers create --attribute-value &quot;https://example.com/attr/classification/value/confidential&quot; --action &quot;read&quot; --obligation-value &quot;https://example.com/obl/test/value/mfa&quot; Create an obligation trigger with IDs otdfctl policy obligations triggers create --attribute-value &quot;d10e0fb6-4b4a-4976-8036-33903ebc6be3&quot; --action &quot;f15f65db-6889-453a-b032-212f78e8eb18&quot; --obligation-value &quot;0cbbb9bb-ed2d-41c0-8efa-1bcdddc44771&quot; Create a scoped obligation trigger with IDs. otdfctl policy obligations triggers create --attribute-value &quot;d10e0fb6-4b4a-4976-8036-33903ebc6be3&quot; --action &quot;f15f65db-6889-453a-b032-212f78e8eb18&quot; --obligation-value &quot;0cbbb9bb-ed2d-41c0-8efa-1bcdddc44771&quot; --client-id &quot;my-service&quot; Options --attribute-value &lt;attribute-value&gt; Attribute value ID or FQN (required: true) --action &lt;action&gt; Action ID or Name (required: true) --obligation-value &lt;obligation-value&gt; Obligation value ID or FQN (required: true) --client-id &lt;client-id&gt; Create a scoped trigger. Optionally include the clientID for which this trigger should be scoped to. (required: false) -l, --label &lt;label&gt; Optional metadata 'labels' in the format: key=value (required: false) Aliases c, add, new","keywords":"","version":"Next"},{"title":"otdfctl policy obligations triggers list","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/obligations/triggers/list","content":"otdfctl policy obligations triggers list list - List obligation triggers Synopsis otdfctl policy obligations triggers list [flags] Description List obligation triggers (optionally by namespace). Example​ otdfctl policy obligations triggers list --limit 10 --offset 0 otdfctl policy obligations triggers list --limit 10 --offset 0 --namespace &quot;https://example.com&quot; Options -l, --limit &lt;limit&gt; Limit retrieved count (required: false) -o, --offset &lt;offset&gt; Offset (page) quantity from start of the list (required: false) -n, --namespace &lt;namespace&gt; Namespace ID or FQN by which to filter results (required: false) Aliases l","keywords":"","version":"Next"},{"title":"otdfctl policy obligations triggers delete","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/obligations/triggers/delete","content":"otdfctl policy obligations triggers delete delete - Delete an obligation trigger Synopsis otdfctl policy obligations triggers delete [flags] Description Delete an obligation trigger. Examples​ Delete an obligation trigger by its ID: otdfctl policy obligations triggers delete --id &quot;79b798f2-50a4-4a6d-9c5d-0f0e3c8787e8&quot; Force the deletion of an obligation trigger: otdfctl policy obligations triggers delete --id &quot;79b798f2-50a4-4a6d-9c5d-0f0e3c8787e8&quot; --force Options --id &lt;id&gt; ID of the obligation trigger to delete (required: true) --force &lt;force&gt; Force deletion without interactive confirmation (required: false)","keywords":"","version":"Next"},{"title":"otdfctl policy obligations values","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/obligations/values","content":"otdfctl policy obligations values values - Manage obligation values Synopsis otdfctl policy obligations values Description Obligation values are the values associated with an obligation. Aliases val, value","keywords":"","version":"Next"},{"title":"otdfctl policy obligations values create","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/obligations/values/create","content":"otdfctl policy obligations values create create - Create an obligation value Synopsis otdfctl policy obligations values create [flags] Description Add a value to an obligation in the platform Policy. For more information about obligation values, see the obligations subcommand. Examples​ Create an obligation value for the obligation with ID '3c51a593-cbf8-419d-b7dc-b656d0bedfbb', and value 'my_value': otdfctl policy obligations values create --obligation 3c51a593-cbf8-419d-b7dc-b656d0bedfbb --value my_value Trigger examples​ You can also create multiple obligation triggers while creating an obligation value. Create an obligation value and create a non-scoped trigger that will map to the created value. otdfctl policy obligations values create --obligation 3c51a593-cbf8-419d-b7dc-b656d0bedfbb --value my_value --triggers '[{&quot;action&quot;: &quot;read&quot;, &quot;attribute_value&quot;: &quot;https://test.org/attr/test/value/red&quot;}]' Create an obligation value and create a scoped trigger that will map to the created value otdfctl policy obligations values create --obligation 3c51a593-cbf8-419d-b7dc-b656d0bedfbb --value my_value --triggers '[{&quot;action&quot;: &quot;read&quot;, &quot;attribute_value&quot;: &quot;https://test.org/attr/test/value/red&quot;, &quot;context&quot;: {&quot;pep&quot;: {&quot;client_id&quot;: &quot;a-pep&quot; }}}]' Create an obligation value and triggers, where the triggers come from a json file. otdfctl policy obligations values create --obligation 3c51a593-cbf8-419d-b7dc-b656d0bedfbb --value my_value --triggers &quot;/path/to/file.json&quot; Options -o, --obligation &lt;obligation&gt; Identifier of the associated obligation (ID or FQN) (required: true) -v, --value &lt;value&gt; Value of the obligation (i.e. 'value1', must be unique within the definition) (required: true) -t, --triggers &lt;triggers&gt; Optional JSON array or file path of obligation trigger(s) to be created and stored on the obligation value. (required: false) -l, --label &lt;label&gt; Optional metadata 'labels' in the format: key=value (required: false) Aliases c, add, new","keywords":"","version":"Next"},{"title":"otdfctl policy obligations values get","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/obligations/values/get","content":"otdfctl policy obligations values get get - Get an obligation value Synopsis otdfctl policy obligations values get [flags] Description Retrieve an obligation value along with its metadata. If both id and fqn flag values are provided, id is preferred. For more information about obligation values, see the manual for the values subcommand. Example​ Get by ID: otdfctl policy obligations values get --id=3c51a593-cbf8-419d-b7dc-b656d0bedfbb Get by FQN: otdfctl policy obligations values get --fqn=https://namespace.com/drm/value/watermark Options -i, --id &lt;id&gt; ID of the obligation value (required: false) -f, --fqn &lt;fqn&gt; FQN of the obligation value (required: false) Aliases g","keywords":"","version":"Next"},{"title":"otdfctl policy obligations values delete","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/obligations/values/delete","content":"otdfctl policy obligations values delete delete - Delete an obligation value Synopsis otdfctl policy obligations values delete [flags] Description Removes an obligation value from platform Policy. For more information about obligation values, see the manual for the values subcommand. Example​ Delete by ID: otdfctl policy obligations values delete --id 217b300a-47f9-4bee-be8c-d38c880053f7 Delete by FQN: otdfctl policy obligations values delete --fqn &quot;https://namespace.com/obl/name/drm/value/expiration&quot; Options -i, --id &lt;id&gt; ID of the obligation value (required: false) -f, --fqn &lt;fqn&gt; FQN of the obligation value (required: false) --force &lt;force&gt; Force deletion without interactive confirmation (required: false)","keywords":"","version":"Next"},{"title":"otdfctl policy obligations values update","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/obligations/values/update","content":"otdfctl policy obligations values update update - Update an obligation value Synopsis otdfctl policy obligations values update [flags] Description Update the value and/or metadata labels for an obligation value. If PEPs rely on this value, a value update could break access. Make sure you know what you are doing. For more information about obligation values, see the manual for the values subcommand. Example​ otdfctl policy obligations values update --id 3c51a593-cbf8-419d-b7dc-b656d0bedfbb --value new_value --label &quot;hello=world&quot; Trigger Example​ [!CAUTION] Updating a obligation value with triggers will replace all existing triggers, on the obligation value being updated, with the new list. Update an obligation value and assign one unscoped trigger to the new value. [!NOTE] View the create command under obligation triggers to read more about scoped and unscoped triggers. otdfctl policy obligations values update --id 3c51a593-cbf8-419d-b7dc-b656d0bedfbb --value new_value --label &quot;hello=world&quot; --triggers '[{&quot;action&quot;: &quot;read&quot;, &quot;attribute_value&quot;: &quot;https://test.org/attr/test/value/red&quot;}]' Update triggers on an obligation value via a json file. otdfctl policy obligations values update --id 3c51a593-cbf8-419d-b7dc-b656d0bedfbb --value new_value --label &quot;hello=world&quot; --triggers &quot;/path/to/file.json&quot; Options -i, --id &lt;id&gt; ID of the obligation value to update (required: true) -v, --value &lt;value&gt; Optional updated value of the obligation value (must be unique within the definition) (required: false) -t, --triggers &lt;triggers&gt; Optional JSON array or file path of obligation trigger(s) to be created and stored on the obligation value. (required: false) -l, --label &lt;label&gt; Optional metadata 'labels' in the format: key=value (required: false) Aliases u","keywords":"","version":"Next"},{"title":"otdfctl policy registered-resources","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/registered-resources","content":"otdfctl policy registered-resources registered-resources - Manage Registered Resources Synopsis otdfctl policy registered-resources Description Registered Resources are &quot;non-data&quot; resources (i.e. not a TDF data object) that are registered with the platform policy and may serve as the &quot;Entity&quot; or &quot;Resource&quot; in a decision request. Aliases reg-res","keywords":"","version":"Next"},{"title":"otdfctl policy registered-resources create","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/registered-resources/create","content":"otdfctl policy registered-resources create create - Create a Registered Resource Synopsis otdfctl policy registered-resources create [flags] Description Add a registered resource to the platform Policy. A registered resource name is normalized to lower case and may contain hyphens or dashes between other alphanumeric characters. For more information, see the registered-resources subcommand. Examples​ Create a registered resource named 'my_resource' with value 'my_value': otdfctl policy registered-resources create --name my_resource --value my_value Options -n, --name &lt;name&gt; Name of the registered resource (must be unique within Policy) (required: true) -v, --value &lt;value&gt; Value of the registered resource (i.e. 'value1', must be unique within the Registered Resource) (required: false) -l, --label &lt;label&gt; Optional metadata 'labels' in the format: key=value (required: false) Aliases c, add, new","keywords":"","version":"Next"},{"title":"otdfctl policy registered-resources delete","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/registered-resources/delete","content":"otdfctl policy registered-resources delete delete - Delete a Registered Resource Synopsis otdfctl policy registered-resources delete [flags] Description Removes a Registered Resource from platform Policy. Registered resource deletion cascades to the associated Registered Resource Values and Action Attribute Values. For more information about Registered Resources, see the manual for the registered-resources subcommand. Example​ otdfctl policy registered-resources delete --id 217b300a-47f9-4bee-be8c-d38c880053f7 Options -i, --id &lt;id&gt; ID of the registered resource (required: true) --force &lt;force&gt; Force deletion without interactive confirmation (required: false)","keywords":"","version":"Next"},{"title":"otdfctl policy registered-resources get","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/registered-resources/get","content":"otdfctl policy registered-resources get get - Get a Registered Resource Synopsis otdfctl policy registered-resources get [flags] Description Retrieve a registered resource along with its metadata and values. If both id and name flag values are provided, id is preferred. For more information about Registered Resources, see the manual for the registered-resources subcommand. Example​ Get by ID: otdfctl policy registered-resources get --id=3c51a593-cbf8-419d-b7dc-b656d0bedfbb Get by Name: otdfctl policy registered-resources get --name=my_resource Options -i, --id &lt;id&gt; ID of the registered resource (required: false) -n, --name &lt;name&gt; Name of the registered resource (required: false) Aliases g","keywords":"","version":"Next"},{"title":"otdfctl policy registered-resources list","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/registered-resources/list","content":"otdfctl policy registered-resources list list - List Registered Resources Synopsis otdfctl policy registered-resources list [flags] Description For more information about Registered Resources, see the registered-resources subcommand. Example​ otdfctl policy registered-resources list Options -l, --limit &lt;limit&gt; Limit retrieved count (required: false) -o, --offset &lt;offset&gt; Offset (page) quantity from start of the list (required: false) Aliases l","keywords":"","version":"Next"},{"title":"otdfctl policy registered-resources update","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/registered-resources/update","content":"otdfctl policy registered-resources update update - Update a Registered Resource Synopsis otdfctl policy registered-resources update [flags] Description Update the name and/or metadata labels for a Registered Resource. If PEPs rely on this registered resource name, a name update could break access. Make sure you know what you are doing. For more information about Registered Resources, see the registered-resources subcommand. Example​ otdfctl policy registered-resources update --id 34c62145-5d99-45cb-a732-13cb16270e63 --name new_resource_name Options -i, --id &lt;id&gt; ID of the registered resource to update (required: true) -n, --name &lt;name&gt; Optional updated name of the registered resource (must be unique within Policy) (required: false) -l, --label &lt;label&gt; Optional metadata 'labels' in the format: key=value (required: false) --force-replace-labels &lt;force-replace-labels&gt; Destructively replace entire set of existing metadata 'labels' with any provided to this command (required: false) Aliases u","keywords":"","version":"Next"},{"title":"otdfctl policy registered-resources values create","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/registered-resources/values/create","content":"otdfctl policy registered-resources values create create - Create Registered Resource Value Synopsis otdfctl policy registered-resources values create [flags] Description Add a value to a registered resource in the platform Policy. A registered resource value value is normalized to lower case and may contain hyphens or dashes between other alphanumeric characters. For more information, see the registered-resources subcommand. Examples​ Create a registered resource value for the registered resource with ID '3c51a593-cbf8-419d-b7dc-b656d0bedfbb', value 'my_value', and action attribute values using action/attribute value IDs, action names, and attribute value FQNs: otdfctl policy registered-resources values create --resource 3c51a593-cbf8-419d-b7dc-b656d0bedfbb --value my_value --action-attribute-value &quot;74a3eade-ef6c-4422-b764-fe0471f5c6c1;405a35a7-2051-49a6-9645-3a667b4739f3&quot; --action-attribute-value &quot;create;https://example.com/attr/my_attribute/value/my_value&quot; Options -r, --resource &lt;resource&gt; Identifier of the associated registered resource (ID or name) (required: true) -v, --value &lt;value&gt; Value of the registered resource (i.e. 'value1', must be unique within the Registered Resource) (required: true) -a, --action-attribute-value &lt;action-attribute-value&gt; Optional action attribute values in the format: &quot;&lt;action_id | action_name&gt;;&lt;attribute_value_id | attribute_value_fqn&gt;&quot; (required: false) -l, --label &lt;label&gt; Optional metadata 'labels' in the format: key=value (required: false) Aliases c, add, new","keywords":"","version":"Next"},{"title":"otdfctl policy registered-resources values","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/registered-resources/values","content":"otdfctl policy registered-resources values values - Manage Registered Resource Values Synopsis otdfctl policy registered-resources values Description Registered Resource Values are the values associated with a registered resource. Aliases val, value","keywords":"","version":"Next"},{"title":"otdfctl policy registered-resources values delete","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/registered-resources/values/delete","content":"otdfctl policy registered-resources values delete delete - Delete a Registered Resource Value Synopsis otdfctl policy registered-resources values delete [flags] Description Removes a Registered Resource Value from platform Policy. Registered resource value deletion cascades to the associated Action Attribute Values. For more information about Registered Resource Values, see the manual for the values subcommand. Example​ otdfctl policy registered-resources values delete --id 217b300a-47f9-4bee-be8c-d38c880053f7 Options -i, --id &lt;id&gt; ID of the registered resource value (required: true) --force &lt;force&gt; Force deletion without interactive confirmation (required: false)","keywords":"","version":"Next"},{"title":"otdfctl policy registered-resources values get","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/registered-resources/values/get","content":"otdfctl policy registered-resources values get get - Get a Registered Resource Value Synopsis otdfctl policy registered-resources values get [flags] Description Retrieve a registered resource value along with its metadata. If both id and fqn flag values are provided, id is preferred. For more information about Registered Resource Values, see the manual for the values subcommand. Example​ Get by ID: otdfctl policy registered-resources values get --id=3c51a593-cbf8-419d-b7dc-b656d0bedfbb Get by FQN: otdfctl policy registered-resources values get --fqn=https://reg_res/my_name/value/my_value Options -i, --id &lt;id&gt; ID of the registered resource value (required: false) -f, --fqn &lt;fqn&gt; FQN of the registered resource value (required: false) Aliases g","keywords":"","version":"Next"},{"title":"otdfctl policy resource-mapping-groups","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/resource-mapping-groups","content":"otdfctl policy resource-mapping-groups resource-mapping-groups - Manage resource mapping groups Synopsis otdfctl policy resource-mapping-groups Description Resource mapping groups allow you to organize multiple resource mappings into logical collections. By grouping related resource mappings, you can manage sets of resources more efficiently. This is useful for scenarios where resources share common access controls or need to be managed together as a unit. Aliases resmg, remapgrp, resource-mapping-group","keywords":"","version":"Next"},{"title":"otdfctl policy registered-resources values list","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/registered-resources/values/list","content":"otdfctl policy registered-resources values list list - List Registered Resource Values Synopsis otdfctl policy registered-resources values list [flags] Description List registered resource values in the platform Policy. For more information about Registered Resource Values, see the manual for the values subcommand. Example​ otdfctl policy registered-resources values list Options -r, --resource &lt;resource&gt; Identifier of the associated registered resource (ID or name) (required: false) -l, --limit &lt;limit&gt; Limit retrieved count (required: false) -o, --offset &lt;offset&gt; Offset (page) quantity from start of the list (required: false) Aliases l","keywords":"","version":"Next"},{"title":"otdfctl policy resource-mapping-groups create","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/resource-mapping-groups/create","content":"otdfctl policy resource-mapping-groups create create - Create a resource mapping group Synopsis otdfctl policy resource-mapping-groups create [flags] Description Create a new group to organize resource mappings. Resource mapping groups belong to a namespace and are identified by a name. For more information about resource mapping groups, see the resource-mapping-groups subcommand. Examples​ otdfctl policy resource-mapping-groups create --namespace-id 891cfe85-b381-4f85-9699-5f7dbfe2a9ab --name my-group Options --namespace-id &lt;namespace-id&gt; The ID of the namespace of the group (required: false) --name &lt;name&gt; The name of the group (required: false) -l, --label &lt;label&gt; Optional metadata 'labels' in the format: key=value (required: false) Aliases add, new, c","keywords":"","version":"Next"},{"title":"otdfctl policy registered-resources values update","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/registered-resources/values/update","content":"otdfctl policy registered-resources values update update - Update a Registered Resource Value Synopsis otdfctl policy registered-resources values update [flags] Description Update any or all of the value, action attribute values, and metadata labels for a Registered Resource Value. If PEPs rely on this value, a value update could break access. Updating the action attribute values will remove and replace all existing action attribute values for this registered resource value. Make sure you know what you are doing. For more information about Registered Resource Values, see the manual for the values subcommand. Example​ otdfctl policy registered-resources values update --id 3c51a593-cbf8-419d-b7dc-b656d0bedfbb --value new_value --action-attribute-value &quot;74a3eade-ef6c-4422-b764-fe0471f5c6c1;405a35a7-2051-49a6-9645-3a667b4739f3&quot; --action-attribute-value &quot;create;https://example.com/attr/my_attribute/value/my_value&quot; Options -i, --id &lt;id&gt; ID of the registered resource value to update (required: false) -v, --value &lt;value&gt; Optional updated value of the registered resource value (must be unique within the Registered Resource) (required: false) -a, --action-attribute-value &lt;action-attribute-value&gt; Optional action attribute values in the format: &quot;&lt;action_id | action_name&gt;;&lt;attribute_value_id | attribute_value_fqn&gt;&quot; (required: false) -l, --label &lt;label&gt; Optional metadata 'labels' in the format: key=value (required: false) --force &lt;force&gt; Force update without interactive confirmation (required: false) Aliases u","keywords":"","version":"Next"},{"title":"otdfctl policy resource-mapping-groups delete","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/resource-mapping-groups/delete","content":"otdfctl policy resource-mapping-groups delete delete - Delete a resource mapping group Synopsis otdfctl policy resource-mapping-groups delete [flags] Description For more information about resource mapping groups, see the resource-mapping-groups subcommand. Examples​ otdfctl policy resource-mapping-groups delete --id=3ff446fb-8fb1-4c04-8023-47592c90370c Options --id &lt;id&gt; The ID of the resource mapping group to delete (required: false) --force &lt;force&gt; Force deletion without interactive confirmation (dangerous) (required: false)","keywords":"","version":"Next"},{"title":"otdfctl policy resource-mapping-groups get","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/resource-mapping-groups/get","content":"otdfctl policy resource-mapping-groups get get - Get a resource mapping group Synopsis otdfctl policy resource-mapping-groups get [flags] Description For more information about resource mapping groups, see the resource-mapping-groups subcommand. Examples​ otdfctl policy resource-mapping-groups get --id=3ff446fb-8fb1-4c04-8023-47592c90370c Options --id &lt;id&gt; The ID of the resource mapping group to get. (required: false) Aliases g","keywords":"","version":"Next"},{"title":"otdfctl policy resource-mapping-groups list","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/resource-mapping-groups/list","content":"otdfctl policy resource-mapping-groups list list - List resource mapping groups Synopsis otdfctl policy resource-mapping-groups list [flags] Description For more information about resource mapping groups, see the resource-mapping-groups subcommand. Examples​ otdfctl policy resource-mapping-groups list Options -l, --limit &lt;limit&gt; Limit retrieved count (required: false) -o, --offset &lt;offset&gt; Offset (page) quantity from start of the list (required: false) Aliases l","keywords":"","version":"Next"},{"title":"otdfctl policy resource-mapping-groups update","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/resource-mapping-groups/update","content":"otdfctl policy resource-mapping-groups update update - Update a resource mapping group Synopsis otdfctl policy resource-mapping-groups update [flags] Description Alter the namespace associated with a group, or update the group's name. For more information about resource mapping groups, see the resource-mapping-groups subcommand. Examples​ otdfctl policy resource-mapping-groups update --id=3ff446fb-8fb1-4c04-8023-47592c90370c --name new-name Options --id &lt;id&gt; The ID of the resource mapping group to update. (required: false) --namespace-id &lt;namespace-id&gt; The ID of the namespace of the group (required: false) --name &lt;name&gt; The name of the group (required: false) -l, --label &lt;label&gt; Optional metadata 'labels' in the format: key=value (required: false) --force-replace-labels &lt;force-replace-labels&gt; Destructively replace entire set of existing metadata 'labels' with any provided to this command (required: false) Aliases u","keywords":"","version":"Next"},{"title":"otdfctl policy resource-mappings","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/resource-mappings","content":"otdfctl policy resource-mappings resource-mappings - Manage resource mappings Synopsis otdfctl policy resource-mappings Description Resource mappings are used to map resources to their respective attribute values based on the terms that are related to the data. Alone, this service is not very useful, but when combined with a PEP or PDP that can use the resource mappings it becomes a powerful tool for automating access control. As an example, Tagging PDP uses resource mappings to map resources based on the terms found within the metadata and documents which are sent to it. Combined with the resource mappings it can then determine which attributes should be applied to the TDF and return those attributes to the PEP. Aliases resm, remap, resource-mapping","keywords":"","version":"Next"},{"title":"otdfctl policy resource-mappings create","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/resource-mappings/create","content":"otdfctl policy resource-mappings create create - Create a resource mapping Synopsis otdfctl policy resource-mappings create [flags] Description Associate an attribute value with a set of plaintext string terms. For more information about resource mappings, see the resource-mappings subcommand. Examples​ otdfctl policy resource-mappings create --attribute-value-id 891cfe85-b381-4f85-9699-5f7dbfe2a9ab --terms term1,term2 --group-id 3ff446fb-8fb1-4c04-8023-47592c90370c Options --attribute-value-id &lt;attribute-value-id&gt; The ID of the attribute value to map to the resource. (required: false) --terms &lt;terms&gt; The synonym terms to match for the resource mapping. (required: false) --group-id &lt;group-id&gt; The ID of the resource mapping group to assign this mapping to (required: false) -l, --label &lt;label&gt; Optional metadata 'labels' in the format: key=value (required: false) Aliases add, new, c","keywords":"","version":"Next"},{"title":"otdfctl policy resource-mappings get","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/resource-mappings/get","content":"otdfctl policy resource-mappings get get - Get a resource mapping Synopsis otdfctl policy resource-mappings get [flags] Description For more information about resource mappings, see the resource-mappings subcommand. Examples​ otdfctl policy resource-mappings get --id=3ff446fb-8fb1-4c04-8023-47592c90370c Options --id &lt;id&gt; The ID of the resource mapping to get. (required: false) Aliases g","keywords":"","version":"Next"},{"title":"otdfctl policy subject-condition-sets","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/subject-condition-sets","content":"otdfctl policy subject-condition-sets subject-condition-sets - Subject condition sets Synopsis otdfctl policy subject-condition-sets Description Subject Condition Sets (SCSs) are the logical resolvers of entitlement to attributes. An SCS contains AND/OR groups of conditions with IN/NOT_IN/CONTAINS logic to be applied against a Subject Entity Representation as either their OIDC Access Token claims or the platform's Entity Resolution Service (ERS). They are applied to Attribute Values via Subject Mappings to determine a Subject's entitlement to any given attribute on TDF'd data. For example structure and logical resolution, see create subcommand. For information about Subject Mappings, see the subject-mappings command. Aliases subcs, scs, subject-condition-set","keywords":"","version":"Next"},{"title":"otdfctl policy resource-mappings list","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/resource-mappings/list","content":"otdfctl policy resource-mappings list list - List resource mappings Synopsis otdfctl policy resource-mappings list [flags] Description For more information about resource mappings, see the resource-mappings subcommand. Examples​ otdfctl policy resource-mappings get --id=3ff446fb-8fb1-4c04-8023-47592c90370c Options -l, --limit &lt;limit&gt; Limit retrieved count (required: false) -o, --offset &lt;offset&gt; Offset (page) quantity from start of the list (required: false) Aliases l","keywords":"","version":"Next"},{"title":"otdfctl policy resource-mappings update","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/resource-mappings/update","content":"otdfctl policy resource-mappings update update - Update a resource mapping Synopsis otdfctl policy resource-mappings update [flags] Description Alter the attribute value associated with a resource mapping's terms, change its group, or fully replace the terms in a given resource mapping. For more information about resource mappings, see the resource-mappings subcommand. Examples​ otdfctl policy resource-mappings update --id=3ff446fb-8fb1-4c04-8023-47592c90370c --terms newterm1,newterm2 Options --id &lt;id&gt; The ID of the resource mapping to update. (required: false) --attribute-value-id &lt;attribute-value-id&gt; The ID of the attribute value to map to the resource. (required: false) --terms &lt;terms&gt; The synonym terms to match for the resource mapping. (required: false) --group-id &lt;group-id&gt; The ID of the resource mapping group to assign this mapping to (required: false) -l, --label &lt;label&gt; Optional metadata 'labels' in the format: key=value (required: false) --force-replace-labels &lt;force-replace-labels&gt; Destructively replace entire set of existing metadata 'labels' with any provided to this command (required: false) Aliases u","keywords":"","version":"Next"},{"title":"otdfctl policy resource-mappings delete","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/resource-mappings/delete","content":"otdfctl policy resource-mappings delete delete - Delete a resource mapping Synopsis otdfctl policy resource-mappings delete [flags] Description For more information about resource mappings, see the resource-mappings subcommand. Examples​ otdfctl policy resource-mappings delete --id=3ff446fb-8fb1-4c04-8023-47592c90370c Options --id &lt;id&gt; The ID of the resource mapping to delete (required: false) --force &lt;force&gt; Force deletion without interactive confirmation (dangerous) (required: false)","keywords":"","version":"Next"},{"title":"otdfctl policy subject-condition-sets delete","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/subject-condition-sets/delete","content":"otdfctl policy subject-condition-sets delete delete - Delete a Subject Condition Set Synopsis otdfctl policy subject-condition-sets delete [flags] Description For more information about subject condition sets, see the subject-condition-sets subcommand. Example​ otdfctl policy subject-condition-sets delete --id=bfade235-509a-4a6f-886a-812005c01db5 Options -i, --id &lt;id&gt; The ID of the subject condition set to delete (required: true) --force &lt;force&gt; Force deletion without interactive confirmation (dangerous) (required: false)","keywords":"","version":"Next"},{"title":"otdfctl policy subject-condition-sets prune","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/subject-condition-sets/prune","content":"otdfctl policy subject-condition-sets prune prune - Prune (delete all un-mapped Subject Condition Sets) Synopsis otdfctl policy subject-condition-sets prune [flags] Description This command will delete all Subject Condition Sets that are not utilized within any Subject Mappings and are therefore 'stranded'. For more information about subject condition sets, see the subject-condition-sets subcommand. Example​ otdfctl policy subject-condition-set prune Options --force &lt;force&gt; Force prune without interactive confirmation (dangerous) (required: false)","keywords":"","version":"Next"},{"title":"otdfctl policy subject-condition-sets get","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/subject-condition-sets/get","content":"otdfctl policy subject-condition-sets get get - Get a Subject Condition Set Synopsis otdfctl policy subject-condition-sets get [flags] Description For more information about subject condition sets, see the subject-condition-sets subcommand. Example​ otdfctl policy subject-condition-sets get --id=bfade235-509a-4a6f-886a-812005c01db5 Options -i, --id &lt;id&gt; The ID of the subject condition set to get (required: true) Aliases g","keywords":"","version":"Next"},{"title":"otdfctl policy subject-condition-sets list","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/subject-condition-sets/list","content":"otdfctl policy subject-condition-sets list list - List Subject Condition Set Synopsis otdfctl policy subject-condition-sets list [flags] Description For more information about subject condition sets, see the subject-condition-sets subcommand. Example​ otdfctl policy subject-condition-set list Options -l, --limit &lt;limit&gt; Limit retrieved count (required: false) -o, --offset &lt;offset&gt; Offset (page) quantity from start of the list (required: false) Aliases l","keywords":"","version":"Next"},{"title":"otdfctl policy subject-mappings","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/subject-mappings","content":"otdfctl policy subject-mappings subject-mappings - Subject mappings Synopsis otdfctl policy subject-mappings Description Subject Mappings are the policy mechanism used to entitle Entities to take Actions on Attribute Values. In a TDF flow, the resource data is associated to Attribute Values within the TDF manifest policy, and a Subject Mapping links a given entity (user, principal) to entitled Action(s) on an Attribute Value. A Subject Mapping (SM) relates: one Subject Condition Set (SCS, see subject-condition-sets command)one or more Actions (see actions command)one Attribute Value (see attributes values command) Within ABAC entitlement decisioning, the principal/agent/user/subject is known via an Entity Representation provided by the Entity Resolution Service and identity provider, and that Entity Representation is logically resolved against the Subject Mapping's contained Subject Condition set such that if it is logically true, the entity is considered entitled to the contained Actions on the contained Attribute Value. Aliases subm, sm, submap, subject-mapping","keywords":"","version":"Next"},{"title":"otdfctl policy subject-condition-sets create","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/subject-condition-sets/create","content":"otdfctl policy subject-condition-sets create create - Create a Subject Condition Set Synopsis otdfctl policy subject-condition-sets create [flags] Description Example Subject Condition Sets​ --subject-sets example input: [ { &quot;condition_groups&quot;: [ { &quot;conditions&quot;: [ { &quot;operator&quot;: 1, &quot;subject_external_values&quot;: [&quot;CoolTool&quot;, &quot;RadService&quot;, &quot;ShinyThing&quot;], &quot;subject_external_selector_value&quot;: &quot;.team.name&quot; }, { &quot;operator&quot;: 2, &quot;subject_external_values&quot;: [&quot;marketing&quot;], &quot;subject_external_selector_value&quot;: &quot;.org.name&quot; } ], &quot;boolean_operator&quot;: 1 } ] } ] ConditionGroup boolean_operator is driven through the API CONDITION_BOOLEAN_TYPE_ENUM definition: CONDITION_BOOLEAN_TYPE_ENUM\tindex value\tcomparisonAND\t1\tall conditions met OR\t2\tany one condition met Condition operator is driven through the API SUBJECT_MAPPING_OPERATOR_ENUM definition, and is evaluated by applying the subject_external_selector_value to the Subject entity representation (token or Entity Resolution Service response) and comparing the logical operator against the list of subject_external_values: SUBJECT_MAPPING_OPERATOR_ENUM\tindex value\tsubject value at selector MUSTIN\t1\tbe any of the values NOT_IN\t2\tnot be any of the values IN_CONTAINS\t3\tcontain one of the values In the example SCS above, the Subject entity MUST BE represented with a token claim or ERS response containing a field at .team.name identifying them as team name &quot;CoolTool&quot;, &quot;RadService&quot;, or &quot;ShinyThing&quot;, AND THEY MUST ALSO have a field org.name that is NOT &quot;marketing&quot;. This structure if their team name was &quot;CoolTool&quot; and they were entitled might look like: { &quot;team&quot;: { &quot;name&quot;: &quot;CoolTool&quot; // could alternatively be RadService or ShinyThing }, &quot;org&quot;: { &quot;name&quot;: &quot;sales&quot; } } If any condition in the group is not met (such as if .org.name were marketing instead), the condition set would not resolve to true, and the Subject would not be found to be entitled to the Attribute Value applicable to this Subject Condition Set via Subject Mapping between. For more information about subject condition sets, see the subject-condition-sets subcommand. Examples​ The following subject condition set would resolve to true if the field at .example.field.one ismyvalue or myothervalue1, or the field at .example.field.two is not equal to notpresentvalue. otdfctl policy subject-condition-set create --subject-sets '[ { &quot;condition_groups&quot;: [ { &quot;conditions&quot;: [ { &quot;operator&quot;: 1, &quot;subject_external_values&quot;: [&quot;myvalue&quot;, &quot;myothervalue&quot;], &quot;subject_external_selector_value&quot;: &quot;.example.field.one&quot; }, { &quot;operator&quot;: 2, &quot;subject_external_values&quot;: [&quot;notpresentvalue&quot;], &quot;subject_external_selector_value&quot;: &quot;.example.field.two&quot; } ], &quot;boolean_operator&quot;: 2 } ] } ]' You can perform the same action with the input contained in a file: otdfctl policy subject-condition-set create --subject-sets-file-json scs.json Options -s, --subject-sets &lt;subject-sets&gt; A JSON array of subject sets, containing a list of condition groups, each with one or more conditions (required: true) -j, --subject-sets-file-json &lt;subject-sets-file-json&gt; A JSON file with path from the current working directory containing an array of subject sets (required: false) -l, --label &lt;label&gt; Optional metadata 'labels' in the format: key=value (required: false) --force-replace-labels &lt;force-replace-labels&gt; Destructively replace entire set of existing metadata 'labels' with any provided to this command (required: false) Aliases c, add, new","keywords":"","version":"Next"},{"title":"otdfctl policy subject-condition-sets update","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/subject-condition-sets/update","content":"otdfctl policy subject-condition-sets update update - Update a Subject Condition Set Synopsis otdfctl policy subject-condition-sets update [flags] Description Replace the existing conditional logic within an SCS with new conditional logic, passing either JSON directly or a JSON file. For more information about subject condition sets, see the subject-condition-sets subcommand. Example​ This updates the boolean_operator of the subject condition set created in the create example. The following subject condition set would resolve to true if the field at .example.field.one ismyvalue or myothervalue AND the field at .example.field.two is not equal to notpresentvalue. otdfctl policy subject-condition-set update --id bfade235-509a-4a6f-886a-812005c01db5 --subject-sets '[ { &quot;condition_groups&quot;: [ { &quot;conditions&quot;: [ { &quot;operator&quot;: 1, &quot;subject_external_values&quot;: [&quot;myvalue&quot;, &quot;myothervalue&quot;], &quot;subject_external_selector_value&quot;: &quot;.example.field.one&quot; }, { &quot;operator&quot;: 2, &quot;subject_external_values&quot;: [&quot;notpresentvalue&quot;], &quot;subject_external_selector_value&quot;: &quot;.example.field.two&quot; } ], &quot;boolean_operator&quot;: 1 } ] } ]' Options -i, --id &lt;id&gt; The ID of the subject condition set to update (required: true) -s, --subject-sets &lt;subject-sets&gt; A JSON array of subject sets, containing a list of condition groups, each with one or more conditions (required: false) -j, --subject-sets-file-json &lt;subject-sets-file-json&gt; A JSON file with path from the current working directory containing an array of subject sets (required: false) -l, --label &lt;label&gt; Optional metadata 'labels' in the format: key=value (required: false) --force-replace-labels &lt;force-replace-labels&gt; Destructively replace entire set of existing metadata 'labels' with any provided to this command (required: false) Aliases u","keywords":"","version":"Next"},{"title":"otdfctl policy subject-mappings create","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/subject-mappings/create","content":"otdfctl policy subject-mappings create create - Create a new subject mapping Synopsis otdfctl policy subject-mappings create [flags] Description Create a Subject Mapping to entitle an entity (via an existing or new Subject Condition Set) to Action(s) on an Attribute Value. Subject Mappings may entitle Actions with standard names ('create', 'read', 'update', 'delete'), custom names, or by their stored 'id' within policy. If the referenced Action name does not already exist within policy, it will be created along with the new Subject Mapping. For more information about actions, see the actions subcommand. For more information about subject mappings, see the subject-mappings subcommand. For more information about subject condition sets, see the subject-condition-sets subcommand. Examples​ Create a subject mapping for a 'read' action linking to an existing subject condition set: otdfctl policy subject-mapping create --attribute-value-id 891cfe85-b381-4f85-9699-5f7dbfe2a9ab --action read --subject-condition-set-id 8dc98f65-5f0a-4444-bfd1-6a818dc7b447 Or you can create a mapping for 'read' or 'create' linking to a new subject condition set: otdfctl policy subject-mapping create --attribute-value-id 891cfe85-b381-4f85-9699-5f7dbfe2a9ab --action create --action update --subject-condition-set-new '[ { &quot;condition_groups&quot;: [ { &quot;conditions&quot;: [ { &quot;operator&quot;: 1, &quot;subject_external_values&quot;: [&quot;myvalue&quot;, &quot;myothervalue&quot;], &quot;subject_external_selector_value&quot;: &quot;.example.field.one&quot; }, { &quot;operator&quot;: 2, &quot;subject_external_values&quot;: [&quot;notpresentvalue&quot;], &quot;subject_external_selector_value&quot;: &quot;.example.field.two&quot; } ], &quot;boolean_operator&quot;: 2 } ] } ]' Options -a, --attribute-value-id &lt;attribute-value-id&gt; The ID of the attribute value to map to a subject condition set (required: true) --action &lt;action&gt; Each 'id' or 'name' of an Action to be entitled (i.e. 'create', 'read', 'update', 'delete') (required: false) --subject-condition-set-id &lt;subject-condition-set-id&gt; Known preexisting Subject Condition Set Id (required: false) --subject-condition-set-new &lt;subject-condition-set-new&gt; JSON array of Subject Sets to create a new Subject Condition Set associated with the created Subject Mapping (required: false) -l, --label &lt;label&gt; Optional metadata 'labels' in the format: key=value (required: false) -s, --action-standard &lt;action-standard&gt; Deprecated. Migrated to '--action'. (required: false) -c, --action-custom &lt;action-custom&gt; Deprecated. Migrated to '--action'. (required: false) Aliases new, add, c","keywords":"","version":"Next"},{"title":"otdfctl policy subject-mappings delete","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/subject-mappings/delete","content":"otdfctl policy subject-mappings delete delete - Delete a subject mapping by id Synopsis otdfctl policy subject-mappings delete [flags] Description Delete a Subject Mapping to remove entitlement of an entity (via Subject Condition Set) to an Attribute Value. For more information about subject mappings, see the subject-mappings subcommand. For more information about subject condition sets, see the subject-condition-sets subcommand. Example​ otdfctl policy subject-mappings delete --id d71c4028-ce64-453b-8aa7-6edb45fbb848 Options -i, --id &lt;id&gt; The ID of the subject mapping to delete (required: true) --force &lt;force&gt; Force deletion without interactive confirmation (dangerous) (required: false)","keywords":"","version":"Next"},{"title":"otdfctl policy subject-mappings get","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/subject-mappings/get","content":"otdfctl policy subject-mappings get get - Get a subject mapping Synopsis otdfctl policy subject-mappings get [flags] Description Retrieve the specifics of a Subject Mapping. For more information about subject mappings, see the subject-mappings subcommand. otdfctl policy subject-mappings get --id 39866dd2-368b-41f6-b292-b4b68c01888b Options -i, --id &lt;id&gt; The ID of the subject mapping to get (required: true) Aliases g","keywords":"","version":"Next"},{"title":"Core Components","type":0,"sectionRef":"#","url":"/pr-172/components/core","content":"Core Components The core components of the OpenTDF platform provide the fundamental building blocks for secure data access and control. These components implement the essential services and configurations that enable the platform's data-centric security capabilities. Key Components​ Authorization (AuthZ)​ The standard authorization configuration manages access control using Casbin and ConnectRPC. It provides role-based access control through predefined roles (admin, standard, unknown) and public endpoints, integrating with the platform's OIDC token system. Service Registration and Configuration​ Core services in the platform are designed to work together through standardized registration and configuration patterns. This includes: Service discovery and communicationStandard health checks and monitoringConfiguration management and validationSecurity and authentication setup Platform Integration Points​ The core components establish crucial integration points for: Identity Provider (IdP) integrationKey management and access controlPolicy enforcement pointsService-to-service communication Purpose​ The core components documentation provides essential information about: Standard configuration patternsService initialization and bootstrap processesSecurity configurations and best practicesIntegration guidelines for platform services These components form the foundation of the OpenTDF platform, ensuring consistent behavior, security, and interoperability across all platform services.","keywords":"","version":"Next"},{"title":"otdfctl policy subject-mappings list","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/subject-mappings/list","content":"otdfctl policy subject-mappings list list - List subject mappings Synopsis otdfctl policy subject-mappings list [flags] Description For more information about subject mappings, see the subject-mappings subcommand. Example​ otdfctl policy subject-mappings list Options -l, --limit &lt;limit&gt; Limit retrieved count (required: false) -o, --offset &lt;offset&gt; Offset (page) quantity from start of the list (required: false) Aliases l","keywords":"","version":"Next"},{"title":"otdfctl policy subject-mappings match","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/subject-mappings/match","content":"otdfctl policy subject-mappings match match - Match a subject or set of selectors to relevant subject mappings Synopsis otdfctl policy subject-mappings match [flags] Description This tool queries platform policies for relevant Subject Mappings using either an Entity Representation or specific selectors. If an Entity Representation is provided via --subject (such as an OIDC JWT or JSON response from an Entity Resolution Service), the tool parses all valid selectors and checks for matching Subject Condition Sets in Subject Mappings to Attribute Values. If selectors are provided directly with --selector, the tool searches for Subject Mappings with Subject Condition Sets that contain those selectors. Examples​ Various ways to invoke the match command to query Subject Mappings to Attribute Values with relevant Subject Condition Sets. # matches either org name or department selectors otdfctl policy subject-mappings match --selector '.org.name' --selector '.department' # parses subject entity representation as JSON and matches any selector (with this subject only '.emailAddress') otdfctl policy subject-mappings match --subject '{&quot;emailAddress&quot;:&quot;user@email.com&quot;}' # parses entity representation as JWT into all possicle claim selectors and matches any of them otdfctl policy subject-mappings match --subject 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c' [!NOTE] The values of the selectors and any IN/NOT_IN/IN_CONTAINS logic of Subject Condition Sets is irrelevant to this command. Evaluation of any matched conditions is handled by the Authorization Service to determine entitlements. This command is specifically for management of policy - to facilitate lookup of current conditions driven by known selectors as a precondition for administration of entitlement given the logical operators of the matched conditions and their relations. Options -s, --subject &lt;subject&gt; A Subject Entity Representation string (JSON or JWT, auto-detected) (required: false) -x, --selector &lt;selector&gt; Individual selectors (i.e. '.department' or '.realm_access.roles[]') that may be found in SubjectConditionSets (required: false)","keywords":"","version":"Next"},{"title":"otdfctl policy subject-mappings update","type":0,"sectionRef":"#","url":"/pr-172/components/cli/policy/subject-mappings/update","content":"otdfctl policy subject-mappings update update - Update a subject mapping Synopsis otdfctl policy subject-mappings update [flags] Description Update a Subject Mapping to alter entitlement of an entity to an Attribute Value. Actions are updated in place, destructively replacing the current set. If you want to add or remove actions, you must provide the full set of actions on update. At this time, creation of a new SCS during update of a subject mapping is not supported. For more information about subject mappings, see the subject-mappings subcommand. For more information about subject condition sets, see the subject-condition-sets subcommand. Example​ otdfctl policy subject-mappings update --id 39866dd2-368b-41f6-b292-b4b68c01888b --action read Options -i, --id &lt;id&gt; The ID of the subject mapping to update (required: true) --action &lt;action&gt; Each 'id' or 'name' of an Action to be entitled (i.e. 'create', 'read', 'update', 'delete') (required: false) -s, --action-standard &lt;action-standard&gt; Deprecated. Migrated to '--action'. (required: false) -c, --action-custom &lt;action-custom&gt; Deprecated. Migrated to '--action'. (required: false) --subject-condition-set-id &lt;subject-condition-set-id&gt; Known preexisting Subject Condition Set Id (required: false) -l, --label &lt;label&gt; Optional metadata 'labels' in the format: key=value (required: false) --force-replace-labels &lt;force-replace-labels&gt; Destructively replace entire set of existing metadata 'labels' with any provided to this command (required: false) Aliases u","keywords":"","version":"Next"},{"title":"Standard Authorization (AuthZ) Configuration for opentdf Platform","type":0,"sectionRef":"#","url":"/pr-172/components/core/authz","content":"Standard Authorization (AuthZ) Configuration for opentdf Platform The opentdf platform uses Casbin to manage authorization (AuthZ) for its routes, which are defined using ConnectRPC. This document outlines the standard AuthZ configuration, role mappings, and administrative responsibilities for managing and customizing the platform to meet specific security requirements. Default Authorization Roles and Policies​ By default, the platform provides three role mappings (admin, standard, and unknown) and a concept of public endpoints. These roles are tied to the realmsRole claim of the OIDC token issued by the Keycloak Identity Provider. Role Mappings and Their Permissions​ admin Description: Administrators of the platform.Permissions: Perform all actions.Modify and mutate policy data.Access private and public endpoints. Requirements: Must have a valid OIDC token with a claim mapping to the admin role. standard Description: Standard users of the platform.Permissions: Perform basic actions.Cannot modify policy data.Access private and public endpoints. Requirements: Must have a valid OIDC token with a claim mapping to the standard role. unknown Description: Users with valid OIDC tokens who are not mappable into the platform's predefined roles.Permissions: Can only perform public functions.Cannot access private endpoints. Requirements: Must have a valid OIDC token, but no mapping exists for the realmsRole claim. Public Endpoints​ Description: Certain routes are designated as public endpoints and bypass AuthZ entirely.Use Case: These routes are accessible to all users, regardless of their role or token validity. Responsibilities of Administrators​ It is critical to note that the opentdf platform provides a basic configuration for authorization. Administrators are fully responsible for customizing and managing authorization policies to align with their organization's security posture. This includes: Configuring the Platform for Security Posture: Review and customize the default Casbin policy to meet organizational needs.Ensure that sensitive routes are properly protected. Managing Role Mappings: Update and maintain the mappings for the realmsRole claim in Keycloak to ensure accurate role assignment.Ensure that users are correctly categorized into admin, standard, or custom roles as required. Monitoring and Updating Policies: Regularly review policy files to ensure compliance with evolving security requirements.Keep track of updates and changes in the Casbin model and policy files. Default Casbin Policy​ The platform leverages Casbin to enforce role-based access control (RBAC). Below is an outline of the default policy: Default Role Mapping​ admin → Full permissions to all resources and actions.standard → Limited permissions to basic resources and actions.unknown → Only permitted to access public functions. Casbin Access Control Model​ The Casbin model supports extensibility so that administrators can define custom access control logic to meet their specific needs. For example, administrators can override the default policy using custom mapping logic or additional claims. Example Configuration​ Here is an example of how the realmsRole claim in Keycloak maps to Casbin roles: server: auth: policy: csv: | p, role:admin, *, *, allow p, role:standard, /basic/*, GET|POST, allow p, role:unknown, /public/*, GET, allow g, opentdf-admin, role:admin g, opentdf-standard, role:standard Key Takeaways​ The opentdf platform provides a basic AuthZ configuration as a starting point.Administrators are responsible for ensuring the platform's configuration aligns with their security policies.It is the organization's responsibility to manage role mappings and to ensure that the realmsRole claim in Keycloak is configured correctly.By default, admin, standard, and unknown roles are provided, with respective permissions. Public endpoints bypass AuthZ entirely. For more advanced configurations, refer to the Casbin documentation for guidance on customizing policies and models.","keywords":"","version":"Next"},{"title":"Key Access Service","type":0,"sectionRef":"#","url":"/pr-172/components/key_access","content":"Key Access Service The Key Access Server (KAS) manages the lifecycle of cryptographic keys and provides access to these keys for the encryption and decryption of TDFs. KAS serves as an out-of-the-box Policy Enforcement Point (PEP) for the OpenTDF platform. RPC Methods​ KAS offers the following RPC methods: PublicKey - Retrieves a public key from KAS. It defaults to rsa:2048 and uses the currently active default key. The key is returned in PEM format by default. service/kas/kas.proto loading... service/kas/kas.proto loading... Rewrap - This method takes a key wrapped using a key retrieved from the PublicKey endpoint and rewraps it with a client key. The process succeeds only if the following conditions are met: The policy binding is validated.The authorization service confirms that the entity is allowed access to the TDF. service/kas/kas.proto loading... service/kas/kas.proto loading... How Rewrap Works​ TDF​ The client extracts two pieces of information from the TDF: Key Access Object (KAO): This contains the wrapped key and the policy binding.The Policy from the manifest. The client generates an ephemeral asymmetric key pair, used to wrap the KAO content (such as an AES encryption key that can access the TDF payload) from KAS. The client builds a RequestBody: { &quot;keyAccess&quot;: &quot;&lt;The Key Access Object&gt;&quot;, &quot;policy&quot;: &quot;&lt;The Policy from the Manifest&gt;&quot;, &quot;clientPublicKey&quot;: &quot;&lt;The public key created in step 2&gt;&quot; } With this RequestBody, the client creates a Signed Request Token, which is a JWT signed with the client's DPoP public key or Ephemeral Key Pair. note &quot;Demonstration of Proof of Possession&quot; is currently optional due to inconsistencies across identity providers. Body of JWT { &quot;requestBody&quot;: &quot;&lt;RequestBody&gt;&quot; } At this point, the client is ready to make the rewrap request. The following is an example request body. Signed Request Token { &quot;signedRequestToken&quot;: &quot;&lt;The JWT&gt;&quot; } KAS first verifies the policy binding against the policy passed in the RequestBody. To do this, KAS unwraps the key to retrieve the symmetric key used to sign the original policy. It then generates the HMAC of the policy and compares it to the policy binding in the KAO. If they match, the policy is valid. HMAC-SHA256(B64(POLICY), KEY) If the policy is valid and untampered, KAS calls the Authorization Service to confirm whether the entity is allowed access to the TDF. If authorized, KAS rewraps the symmetric key with the client's public key and returns the newly wrapped key for the client to use in decrypting the TDF.","keywords":"","version":"Next"},{"title":"Policy","type":0,"sectionRef":"#","url":"/pr-172/components/policy","content":"Policy Policy is the all-encompassing name for configuration of cryptographically-bound Attribute Based Access Control (ABAC) within the Platform. TDF creation and decryption are driven by the Policy within a Platform instance and the TDF manifest. In other words, on a TDF decryption request, the platform services (KAS, Authorization) compare attributes on the TDF against the requester's entitlements to make a decision to release the key or not. Components of Policy include: Attributes NamespacesDefinitionsValues ActionsSubject Mappings Subject Condition Sets Registered ResourcesResource MappingsKey Access Grants (KAS Grants)","keywords":"","version":"Next"},{"title":"Actions","type":0,"sectionRef":"#","url":"/pr-172/components/policy/actions","content":"Actions Actions are a set of standard and custom verbs at the core of an Access Decision. In the context of an entitlement decision, the Actions within Subject Mappings answer &quot;what can an Entity do to a Resource?&quot; Together with attribute definition rules, they drive the ABAC policy and decisioning of the platform. Standard Actions​ Standard Actions in Policy are comprised of the below, which come out of the box in the platform: createread (considered within all TDF decrypt flows)updatedelete Standard Actions may not be deleted, and only their metadata labels are mutable. Custom Actions​ Custom Actions known to Policy are admin-defined, globally unique (not namespaced), and will be lower cased when stored. They may contain underscores (_) or hyphens (-) if preceded or followed by an alphanumeric character. Examples: downloadqueue-to-printsend_email","keywords":"","version":"Next"},{"title":"Attributes","type":0,"sectionRef":"#","url":"/pr-172/components/policy/attributes","content":"Attributes Attributes are the logical structure used to control access to TDF data. Entities (people, machines, users) are &quot;entitled&quot; to attributes. Resource data is encrypted within a TDF that contains attributes, binding ABAC policy at the cryptographic level. Composition​ An attribute consists of three parts: A NamespaceA DefinitionA Value Platform Policy Attributes can contain multiple Namespaces, each with multiple Definitions, and each Definition can have multiple Values. Namespaces​ A Namespace is the parent container for a set of attributes. Consider the following example: Alice wants to control access in a platform instance based on Attribute Values of the Definitions color and order. She creates attribute definitions for each and assigns values to them. Bob agrees with this concept but wants to use different colors and drive order based on alphabetical indexes rather than word strings. These attributes will now be used to drive access decisions based on policies in the platform. Unsafe Actions​ Certain actions on policy attributes are considered &quot;unsafe&quot; because they may inadvertently affect access control, potentially granting or removing access unintentionally. Deactivating a Namespace, for example, cascades to deactivate its Definitions and their Values. Similarly, deactivating a Definition deactivates its Values. Unsafe actions on policy attributes include: Namespaces: Updating the namespace name (e.g., demo.com to example.org).Reactivation (does not cascade to reactivate attributes and their values).Deletion (permanently removes the namespace and all associated attributes and values). Attribute Definitions: Updating the attribute definition name.Changing the order of attribute values.Modifying the rule on a definition (e.g., from hierarchy to anyOf).Reactivation (does not cascade to values or bubble up to reactivate the namespace).Deletion (permanently removes the definition and its values). Attribute Values: Updating the value.Reactivation (does not bubble up to reactivate the definition or namespace).Deletion (permanently removes the value without affecting the parent definition or namespace). These mutations can retroactively change access to existing and new TDFs, making it crucial to handle them with caution.","keywords":"","version":"Next"},{"title":"Key Access Registry","type":0,"sectionRef":"#","url":"/pr-172/components/policy/key_access_registry","content":"Key Access Registry The Key Access Server (KAS) Registry within the platform policy is a store of known Key Access Servers. Within platform policy, a registered KAS instance has the following key attributes: URI: The location where the KAS is accessible. This must be unique among all KAS instances registered in the platform.Source Type: Indicates whether the KAS is managed by the organization or imported from an external party. (Defaults to unspecified)Name: A friendly name for the registered KAS. (Optional) important PublicKey is deprecated and no longer used as of v0.7.0 of service. Instead, import public keys with key management. The ability to assign grants was deprecated in v0.7.0 of service, in favor of key mappings.","keywords":"","version":"Next"},{"title":"Key Management","type":0,"sectionRef":"#","url":"/pr-172/components/policy/keymanagement","content":"Key Management Key management is the new way for managing key encryption keys for the platform. Asymmetric keys or a reference to a key will now be stored either within the platform database directly, or stored externally using a Key Management Provider or a Hardware Security Module (abstracted as a Key Manager). Those keys will then be used for TDF creation and decryption. How does everything work?​ note The key manager is a part of the key access server, but is called out specifically because it is a new concept for the platform. Read more about managers. The graphic above is a representation of a basic flow of how KAS now would perform a rewrap (decrypt) operation. KAS now needs to reach out to a third party to get the private key to rewrap the data encryption key that is sent in the rewrap request, which will then be unwrapped on the client and used to decrypt the payload of the TDF. In the example above, the KAS (key access server) reaches out to the platform to get a key, but it's totally possible with the new architecture that the platform database could only store a reference to the key. What this means is that the private key could be stored externally, say in a KMS or HSM, outside of the platform's control. The following is an example of how the code would work if you used a KMS, for all cryptographic operations: The primary difference is that the Key Manager needs to reach out to the KMS to perform the rewrap operation. To connect KAS to a specific external key provider you would need to use a provider configuration. To learn more about the following flow, read about key managers What is different with the new key architecture?​ Previously, when starting the platform users would be expected to populate the startup yaml file with asymmetric keys that would be used by KAS for and decryption. Now keys, or their reference, should be stored/registered with the platform via the kas-registry key endpoints.Endpoints for easier management of keys through the kas-registry. Create/Read/UpdateKey Rotation Grants are being deprecated for key mappings.Admins can now set a base key to be used as the default key when no key mappings/grants are found.Asymmetric keys can now be stored outside of a Key Access Server, by registering a key manager at startup and creating a provider configuration that is tied to the key manager.","keywords":"","version":"Next"},{"title":"Base Key","type":0,"sectionRef":"#","url":"/pr-172/components/policy/keymanagement/base_key","content":"Base Key A base key, or default key, is a key that will be used when no grants or key mappings are found from the attributes passed in. Base keys are set by an admin for the purpose of ensuring that insecure keys are not used by default when no mappings/grants are found. How to get/set a base key​ important You must have admin permission to use any key operations. When using the kas-registry proto and an active connection to the platform you can use the above base key rpcs to set and retrieve the base key. otdfctl base key provides documentation on how to set / get base keys with the OpenTDF CLI. Effects of using base key​ When a base key is specified the SDK will prefer to use it over the passed in kas info list. The SDK will overwrite the following information if a base key is registered with the platform: The passed in kas information listThe key algorithm If a base key is not present, the SDK will fallback to using the passed in kas information list and key algorithm. note In upcoming versions of the SDK, post v0.5.0, the SDK will prefer to error when no base key is set; instead of falling back.","keywords":"","version":"Next"},{"title":"Key Access Grants","type":0,"sectionRef":"#","url":"/pr-172/components/policy/key_access_grants","content":"Key Access Grants caution In v0.7.0 of the platform creating grants is now deprecated in favor ofkey mappings. Version 0.7.0 of the platform will error when attempting to assign key access servers to attributes. Key Access Grants (KAS Grants) are associations between a registered Key Access Server (KAS) and an Attribute. These grants can be applied at the namespace, definition, or value level of an attribute. KAS Grants enable key split behaviors on TDFs with attributes, facilitating various collaboration scenarios around shared policies. Grants follow the specificity matrix below, which determines the KAS public keys used for encryption in various KAS grant scenarios: Namespace KAS Grant\tAttribute Definition KAS Grant\tAttribute Value KAS Grant\tGranted Data Encryption Key Utilized in Splityes\tno\tno\tnamespace yes\tyes\tno\tattribute definition no\tyes\tno\tattribute definition yes\tyes\tyes\tvalue no\tyes\tyes\tvalue no\tno\tyes\tvalue no\tno\tno\tdefault KAS/platform key A KAS Grant in platform policy is straightforward, consisting of the attribute object ID (Namespace, Definition, Value) and the KAS Registry ID. note KAS Grants determine which keys are used during encryption and decryption based on the specific attributes of the TDF. Collaboration Scenarios​ AnyOf Split​ In an AnyOf split, multiple KAS Grants allow access if any one of the grants matches the attributes assigned. For example, if Bob and Alice want access to data encrypted with their respective public keys, either Bob's or Alice's key can be used to unlock the shared data. Definition: A\tValue: A\tDefinition: B\tValue: B\tSplitBob, Alice\t-\t-\t-\tOR Bob, Alice\t-\tBob, Alice\t-\tOR -\tBob\tAlice\t-\tOR -\t-\tBob, Alice\tOR AllOf Split​ In contrast to the AnyOf split, the AllOf split requires that both keys be present to decrypt the data. Bob and Alice can define KAS Grants such that data is encrypted with both of their public keys, ensuring that neither can decrypt the data independently. In this scenario, both Bob's and Alice's KAS must release the payload keys for the TDF, as the data is encrypted with attributes assigned KAS Grants to both KAS instances. Example attributes: Attribute A: https://conglomerate.com/attr/organization/value/acmecoAttribute B: https://conglomerate.com/attr/department/value/marketing Attribute\tNamespace\tDefinition\tValueA\tconglomerate.com\torganization\tacmeco B\tconglomerate.com\tdepartment\tmarketing Attribute KAS Grant Scenarios: Bob and Alice represent individual KAS Grants on data protected with TDF.Attributes A and B are in the same namespace but have different definitions. Definition: A\tValue: A\tDefinition: B\tValue: B\tSplitBob\t-\tAlice\t-\tAND Bob\t-\t-\tAlice\tAND -\tBob\t-\tAlice\tAND note Any KAS Grants on attributes of different definitions or namespaces will use AND splits. Migration to Key Mappings​ This section outlines the process for migrating from the legacy KAS grant system to the new key mapping system. warning Important: Once the first key mapping is created, all new encryption operations will start using key mappings instead of grants. Step 1: Create New KAS Keys for Existing Grants​ The first step is to create new keys for each existing KAS. Before the introduction of the new key management functionality, a KAS was associated with either a Remote or Cached public key. important If you own the registered Key Access Server and your specific KAS is using this instance of the platform, you should import your keys instead of creating a key of mode KEY_MODE_CONFIG_ROOT_KEY. You should only create keys of mode KEY_MODE_PUBLIC_KEY_ONLY for Key Access Servers that you either: Do not control, meaning it is external to your organization.The specific Key Access Server is meant to be external from this platform. Remote Key Example: &quot;public_key&quot;: { &quot;PublicKey&quot;: { &quot;Remote&quot;: &quot;https://kas1.com:8080&quot; } } Cached Key Example: &quot;public_key&quot;: { &quot;PublicKey&quot;: { &quot;Cached&quot;: { &quot;keys&quot;: [ { &quot;pem&quot;: &quot;-----BEGIN CERTIFICATE-----\\nMIIBzzCCAXWgAwIBAgIUORuV3avU9AE6zsB6ZxyllHpi5d4wCgYIKoZIzj0EAwIw\\nPTELMAkGA1UEBhMCdXMxCzAJBgNVBAgMAmN0MSEwHwYDVQQKDBhJbnRlcm5ldCBX\\naWRnaXRzIFB0eSBMdGQwHhcNMjQwMTAyMTY1NjU2WhcNMjUwMTAxMTY1NjU2WjA9\\nMQswCQYDVQQGEwJ1czELMAkGA1UECAwCY3QxITAfBgNVBAoMGEludGVybmV0IFdp\\nZGdpdHMgUHR5IEx0ZDBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IABLV9fCJHD/kc\\nrXrUHQwAZx0Mc0dPvLjsJ/ojEtMMn0ROdeOx8ygxgcQTFFAxyCtBuadhAdm/iVHt\\n8g2EMz5dO3WjUzBRMB0GA1UdDgQWBBQYNkuk+JIuRWyn+bE8sBhRw27OVTAfBgNV\\nHSMEGDAWgBQYNkuk+JIuRWyn+bE8sBhRw27OVTAPBgNVHRMBAf8EBTADAQH/MAoG\\nCCqGSM49BAMCA0gAMEUCIQCAB2jiYe8AY6MJ4ADPSQGE47+a3kWFLcGsJhoZbxtg\\nUwIgcfIIuPfh4fbcv8cTi2BlI3k7sWPuAmIFVriI2d3Ux5Q=\\n-----END CERTIFICATE-----&quot;, &quot;kid&quot;: &quot;r1&quot;, &quot;alg&quot;: 1 } ] } } } Algorithm Mapping​ Use the following table to map the integer algorithm value from a cached key to the --algorithm flag in otdfctl. alg Value\totdfctl Flag1\t--algorithm rsa:2048 2\t--algorithm rsa:4096 5\t--algorithm ec:secp256r1 6\t--algorithm ec:secp384r1 7\t--algorithm ec:secp521r1 The KasPublicKeyAlgEnum proto definition: enum KasPublicKeyAlgEnum { KAS_PUBLIC_KEY_ALG_ENUM_UNSPECIFIED = 0; KAS_PUBLIC_KEY_ALG_ENUM_RSA_2048 = 1; KAS_PUBLIC_KEY_ALG_ENUM_RSA_4096 = 2; KAS_PUBLIC_KEY_ALG_ENUM_EC_SECP256R1 = 5; KAS_PUBLIC_KEY_ALG_ENUM_EC_SECP384R1 = 6; KAS_PUBLIC_KEY_ALG_ENUM_EC_SECP521R1 = 7; } Key Creation Command​ Create a new key for each existing KAS grant, using the public key from the grant. ./otdfctl policy kas-registry key create \\ --kas https://kas1.com:8080 \\ --algorithm rsa:2048 \\ --mode public_key \\ --public-key-pem &lt;base64_encoded_pem&gt; Step 2: Migrate Grants to Key Mappings​ After creating the new keys, map them to the corresponding namespaces, attribute definitions, and attribute values. List Current KAS GrantsTo see all existing grants, run: ./otdfctl policy kas-grants list --json Create Key MappingsFor each grant, create a new key mapping using the appropriate command from the Assigning Keys to Policy Resources section. For a Namespace Grant: ./otdfctl policy attributes namespaces key assign --namespace https://demo.com --key-id &lt;newly_created_key_id&gt; For an Attribute Definition Grant: ./otdfctl policy attributes key assign --attribute https://demo.com/attr/key --key-id &lt;newly_created_key_id&gt; For an Attribute Value Grant: ./otdfctl policy attributes value key assign --value https://demo.com/attr/key/value/1 --key-id &lt;newly_created_key_id&gt; Once all grants have been migrated to key mappings, your system will have fine-grained control over which keys are used for policy resources.","keywords":"","version":"Next"},{"title":"Key Managers","type":0,"sectionRef":"#","url":"/pr-172/components/policy/keymanagement/key_managers","content":"Key Managers With the new key architecture OpenTDF has added the flexibility for an organization to store keys outside of a key access server or the platform. For example, if you want to use OpenTDF and your encryption keys are stored within AWS KMS, this is now totally possible through key managers. What is a key manager?​ A key manager is essentially a client that is used for either performing cryptographic operations or orchestrating the necessary procedures for retrieving the decrypted data encryption key, which can be used for decrypting the TDF. An example of a key manager can be found in the basic manager. The basic manager is the default manager, which expects the private key to be stored within the platform and the symmetric key that wraps the private key to be stored within KAS. How do I register a key manager?​ If you have written your own key manager, you can register it with KAS by providing its factory method with a server option (.so), during server startup. By providing a way to instantiate an object of your key manager type we will then use it when necessary. You will also need to configure KAS to use the new key manager. This is done through provider configuration file (.cfg). important As of Service v0.10.0 the use of the name field is not used for mapping a key to an implementation of that manager. Instead, the new manager field is used for this purpose. The name should now be treated as a friendly name. Provider configurations​ Provider configurations are a way of entangling a key to a specific manager. The key management proto provides specifics on what RPCs are available as well as what is expected within each call. One of the most important parts of the provider configuration is the manager field. The manager field is what KAS will look for when trying to instantiate a specific manager. If no manager with that name is found, KAS will attempt to use the default manager. The basic flow is as follows: note In the below example, r1 is just an example key id. Key managers are a part of KAS, and not external services although they can reach out to external services to perform needed operations. When creating your provider configuration and registering your key manager the name given in the manager factory, must match the manager field given to the provider configuration. For example, if you register a manager with name opentdf.io/aws you would need to create a provider configuration with opentdf.io/aws as the manager field and tie it to a key when creating the key. important If private keys are meant to be stored within the platform database, there should be no provider configuration added to the key. Since an empty provider configuration is assumed to be tied to the default manager. important Provider configuration names must be unique. You cannot delete provider configurations that are tied to keys. Helpful links​ key manager interface.NamedKeyManagerFactoryKeyManagerFactory","keywords":"","version":"Next"},{"title":"Key mappings","type":0,"sectionRef":"#","url":"/pr-172/components/policy/keymanagement/key_mappings","content":"Key mappings important Before leveraging Key Mappings make sure to migrate your existing KAS Grants. important v0.5.0 of the SDK will prefer key mappings over grants. Meaning if a key mapping shows up for an attribute the SDK will use the mapping and not the grant. You should migrate all grants over to mappings in one sitting important As of v0.7.0 of the OpenTDF platform, grants can no longer be assigned. Key mappings are now the replacement for key access server grants. The idea for mapping a key to an attribute definition/value/namespace is the same as grants, except now we separate the keys from key access servers. Previously an admin was expected to add a key directly to the KeyAccessServer object, as either remote or cached, and then assign a key access server to an attribute. That process is known as a grant. Now users should create a key, and assign that key to an attribute. How do I create a key mapping​ note The following example only shows how to create a mapping for attribute definitions, you can also create mappings for namespaces and attribute values. First you will need to create a key access server OpenTDF CLI otdfctl policy kas-registry create --uri http://example.com/kas --name example-kas Next, you will need to create a key OpenTDF CLI otdfctl key create --key-id &quot;rsa-key-1&quot; --algorithm &quot;rsa:2048&quot; --mode &quot;local&quot; --kas &quot;891cfe85-b381-4f85-9699-5f7dbfe2a9ab&quot; --wrapping-key-id &quot;virtru-stored-key&quot; --wrapping-key &quot;a8c4824daafcfa38ed0d13002e92b08720e6c4fcee67d52e954c1a6e045907d1&quot; create a namespace OpenTDF CLI otdfctl policy attributes namespaces create --name opentdf.io create an attribute OpenTDF CLI otdfctl policy attributes create --namespace 3d25d33e-2469-4990-a9ed-fdd13ce74436 --name myattribute --rule ANY_OF assign a key to an attribute OpenTDF CLI otdfctl policy attributes key assign --attribute 3d25d33e-2469-4990-a9ed-fdd13ce74436 --key-id 8f7e6d5c-4b3a-2d1e-9f8d-7c6b5a432f1d Now you have successfully created a key mapping.","keywords":"","version":"Next"},{"title":"Obligations","type":0,"sectionRef":"#","url":"/pr-172/components/policy/obligations","content":"Obligations Obligations are policy constructs that enable Policy Decision Point(PDP) - to - Policy Enforcement Point (PEP) directives that accompany a decision. They express additional controls the PEP should enforce—such as requiring MFA, applying watermarking, encrypting content, or limiting access by time. In effect, the PDP is saying “permit, provided these controls are enforced.” The PDP cannot compel or verify enforcement; it relies on the PEP to honor the obligations. If the PEP cannot or will not enforce an obligation, it should decline to grant access. Composition​ An obligation consists of: A NamespaceA DefinitionValuesTriggers Platform Policy Obligations can contain multiple Namespaces, each with multiple Definitions, and each Definition can have multiple Values. Each Value can have multiple Triggers. Each trigger can have an Action, Attribute Value, and PEP identifier (optional). Not specifying a PEP results in a global obligation that applies across all PEPs. Standard Obligations​ Standard Obligations are enforced by the Access PDP (Policy Decision Point) when validating whether an Entity of a specified Category can perform an Action on a given Resource. These obligations must be satisfied for access to be granted. A Standard Obligation includes: Action: The specific action being performed (READ, STORE, CREATE, UPDATE, DELETE)Resource Attribute Value: The data attribute for which this obligation is scopedObligation Value: The required obligation value that must be satisfied Examples of Standard Obligations:​ Watermarking​ Ensure document traceability: Obligation: https://example.com/obl/drm/value/watermarkingApplied to: sensitive documentsCondition: PEP must apply watermark Prevent Download​ Prevent download of plaintext content: Obligation: https://example.com/obl/drm/value/no-downloadApplied to: sensitive documentsCondition: PEP must not allow download FQN (Fully Qualified Name) Convention​ Obligations use a specific naming convention to distinguish them from attributes: Obligation Definition: &lt;namespace&gt;/obl/&lt;obligation_name&gt;Obligation Value: &lt;namespace&gt;/obl/&lt;obligation_name&gt;/value/&lt;obligation_value&gt; For example: https://example.com/obl/drm (definition)https://example.com/obl/drm/value/watermarking (value)","keywords":"","version":"Next"},{"title":"Quickstart for using the new key management architecture","type":0,"sectionRef":"#","url":"/pr-172/components/policy/keymanagement/quickstart","content":"Quickstart for using the new key management architecture important This quickstart is meant to aid users trying to test the new key management features, by standing up a new platform. This quickstart is not meant as a migration guide. Currently, while key management is experimental, we recommend to use key management with ONLY new deployments. Below is a guide to setting up platform to use the new key management features. Checklist: important You can spin KAS up without activating the key management features. This gives you time to create or migrate keys to the platform before KAS expects keys to come from the platform, which would be helpful for migrations. Key management is activated for KAS.A key has been created.Assign key mappings. (optional, but recommended)Base Key is set (optional, but recommended) Key management is activated for KAS​ To activate key management for KAS you will need to modify the key_management field within the opentdf.yaml file to be true. opentdf-dev.yaml.You will also need to set a root key to be used with the basic manager. The root key should be 32 bytes long. In addition, the root key should be hex encoded. Creating a key​ note You can also perform all key commands with the OpenTDF CLI You should already have created and registered a Key Access Server with the platform via the Create Key Access Server Endpoint.Once you have a Key Access Server registered you should then create a key for that registered KAS. The definition for creating a key can be found in the key_access_registry proto. Let's look at a valid request and dissect it: note These keys can be found within the policy_fixtures.yaml file located in opentdf. { &quot;kas_id&quot;: &quot;db740f79-cf85-41b2-a27f-663b0e2b169b&quot;, &quot;key_id&quot;: &quot;kas-key-1&quot;, &quot;key_algorithm&quot;: 1, &quot;key_mode&quot;: 1, &quot;public_key_ctx&quot;: { &quot;pem&quot;: &quot;LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUMvVENDQWVXZ0F3SUJBZ0lVRjA5QWpIallJOENSekVGSmpjVEREY2lkZEgwd0RRWUpLb1pJaHZjTkFRRUwKQlFBd0RqRU1NQW9HQTFVRUF3d0RhMkZ6TUI0WERUSTBNRFV3TmpFeU1UQXhNbG9YRFRJMU1EVXdOakV5TVRBeApNbG93RGpFTU1Bb0dBMVVFQXd3RGEyRnpNSUlCSWpBTkJna3Foa2lHOXcwQkFRRUZBQU9DQVE4QU1JSUJDZ0tDCkFRRUFsVEI5eks3dzF1MG1mOWI5bmg4U3p0K0t5ZFdvbjUyUDVNY2k4Z1YremFQWjlmM0picllHVWZWWG16RmEKbVErTjBmTjZRaDhVOWlzbzFPZ3VHWDB1eTRwV1k3em1XTXFtRjVpSk9INENBdTVnV2Vuc3I5R2FXM1lmeEtWRgpWUnpKcUx0U3pBT3lvQ0lhNVErSTJUdmdNeEZjSFYwSGN4OXU5ekdYdDdKNUdlV1pTM3I2OUg4MGRGUjdGc0lRCk1hTDZRUHhmUWNWOVJidW9weUFwOE43TktiU3p4OEZUZEJYUWE4QnVxTXNvNlZyK0crZC9oeVp6YlpVc1pEUzQKZ3RtNnJCQlUraE8zMEN6WnBaZHBETVNPdjljNGNZUXlpdElwRjBrbVdQcE02YitKUzRyN2hGUU5kY1BWVXBWeAovVGowRUFNaWsrcHpZQUxyalRLZjlHcmJkd0lEQVFBQm8xTXdVVEFkQmdOVkhRNEVGZ1FVa2RTM0JuWHNnZUtSCnVNL0hCNW9sM3lacVRvMHdId1lEVlIwakJCZ3dGb0FVa2RTM0JuWHNnZUtSdU0vSEI1b2wzeVpxVG8wd0R3WUQKVlIwVEFRSC9CQVV3QXdFQi96QU5CZ2txaGtpRzl3MEJBUXNGQUFPQ0FRRUFTZXoxQVZhNVhHVXBrNUg4THpySQp4U0VzUnRHUitSV2NJdGxMZVVLc3NPTTNzY01mUEZ6SnQyTldwd0NwSTRiY2FGQVgzeFlLR1lxVnZzVmpxbTFVCnRKYmh6dzFhUVBUT2ZvNDZlOXNGK2lxZGJpbEplRUlQZllDb0w2VXR0Rm96TC9LZ2k1eWFlSXBScTFiaHFwVjcKTVRmSm1CbHVIckZhdWNFaEFMTDJoK0tsQ1R6amJsQnBZN1hpVFZHc3JZc0V2MmF3NEh2b1pZVkZVV3IxQ1JXYgppcDB4dFZ1SXE5RFhha0ZJYWVQWlZnMHRCczVBejBzUGlpNUdUVjUzVXdmcjY4VjhBYXFRSE9yVGRQL2ZadkN3CmRXTWdKSnltc21VUis1cTJCTnJvZHlTWDd4RzZxenE0Mm5BV1ZwSlNvb0g5ZWdSYXZuZ0Q5UXRreWU5KzBuRW0KVGc9PQotLS0tLUVORCBDRVJUSUZJQ0FURS0tLS0tCg==&quot; }, &quot;private_key_ctx&quot;: { &quot;key_id&quot;: &quot;config&quot;, &quot;wrapped_key&quot;: &quot;lcbq682Gsii+jEkQ62sWIXkWWVJjgWPuvhmBt9KiYFJ/o3XClyRd4c0KDFtuohdBw2jvVGweFfspi9eWGMIzEl6bcERc52q5HviH5kcT9RcnJhUv3iN635RwHzNvjGEVKKUNBv4pfEN30w7opHPigz0KQ1VBMJNO3YD9FVA7UoHx0eJcF7ZQJJGXxwpQV0MtwlqmRpq4Q2U9vpYrj6787QHGf9hegIXNA+r0r3TCLpwc5Y3A9hHkyjw7QgXE8ueJILuMm87CerJpyZOCsrH3vAjiYAVv7/dEJqjX1AgaB84T7hxDFej9JKhIy9eKZNrNwMYmAsHpbA3jg5GEHB7E3fXEqhi1SNYaGVidtoJuS/3kVnILKNY6ifto6YLLBAuiPARc56UnUSKHYCWmNJ7BC8cHa7aHt9eQmeUTbqVf0h7h463qYCazD8XOALQ0nCyOCr9uLdWZ5A8Klqf3+j+728kZaBE7kJgR5PXtt1LLyXq8fHHOEsNYs3OtR8cwjEudjoUTI17ubBNb8XeM5zaZ/WfufCqjvPecDKzprUo7ejpkf6J8BtE+YHVQJ7M1bVoVeCKEMe/+zycfispsnflCVm6BMtYLvkU/23Edb9cM7PQGyELFNx32AtpQzLEE+5eZYaaQNYkxDiatsvd2D24ERMXfXjuah810NIZTe18q+F2+Y0KnMOKdzjWp2Qwo4uHorbvwQFL39vkTrfe23zXUcd67ZBNjIQCFsJk9nlFONF8ksnWW49hwqJ95urmhnsHdRfPkmW6HvtRuSrSw/ef8ft1Ff2VF1CJQp+Jw6bzJZdPK7lNlf7Qw7kkDKjHlgM5gjveeRWf19Cqji7G3QaI/NkqCtJeZYKffFSTmm+Hcz4mzLBJssxMth/RDZC5SiUI82agHtBByT/C+p64A7r6FxSovdMN/fMNYILw4dPWuqt6p6egMIr0SUapiPriN0bF3Z7gyGT1Avr0ugiOjAB7/zrl2Giaej1TWMXKO3wbx/EsQWi03VrlVjpHv9vcheZ7FO9bDBTRLJdr4BE8Ek4bFBk+qFFNAvWp/Fd1b6qb++DuNHj85WdwXMOiog5IRK7ceIMOLPcmxNq7axyZy+Nm2Cehr3yBONC1PFixScLHbYPBeMODhbGYz94EZbLG9bi/PyFBb4DXHiKzlk4KSgpXgQKPpRElziCbaPwZZ0eYcPHhjKU4t7ki7NTv2QXUMg+uvuVVj2mpjR12ynbbKlI42hPG1amEWBe3Rc6fxqnnBuRryLZ7DanpknvWKyQq7KZGHrFziZ0A7CURz1gOdxwlCAq/Fp1gj10jM0ZI+yhwTFrxBP2WtquKWADHF0pFnSVuJJRysPTvisRaS57wviVYBtBrtFbfaLpFs+pCebbO5+GQgopZVZH39sIgcGHcpxEMst0BwrnPfH3DQlbjVgkZQf6BbeJC5aA/kDU5RdSbQ2563BpdLEDDCwoiU95nKpMm8O3U210GQ0x/xWEaC1t2d9S6FUElTUJRXYVMePvgrZ2vFj9ya6o6nKUkxEp2iIdKgurDx0EMHvv5OtLFXNuWYWHSJ7s3DOrV66qQtXhqzUIlF4GXDUaJfgsmQ941M7yAj/tbn0GPad0ClEvVwnnpjg4Jhgf5vZBh/SpnMkhbkTHB+4j8kOWELwVsfCStSkFFtp1cUmER9EhjK8cJbw/aJU59fFfd2WGCzULHfA21DKrWzIl388kk/xqwT7Q9iOvcSR7ZstMtGTQXnxCX/Wp8Toj64H3dlGjzLhFx6uBNwXT114Rxl8efKuoUg7tdw1qWm9JeP/vMQzU9KwfyHLK6gCAIfZJgyY+rur7F+eSOEIDyidFrK3SVLQ7OYGFeWhTMKMGw7ZWenL/qX7APQ+vGh2jP52U7elOKx/TlNFyPrG/aYP3t04SueYRGvEp+zfdUM1nf/7v/DxssURKosAGGkRpo0KCsTSB8S8qu9M+07b0RDEWj/PtukegoEDu+6xk3tZdjrZVM21eDCh8q0OGm/Jx0HMeePqHco3xGS1JX1otAZwPHZiI2iccZK+WmJLLZIrXK4lHo/wYiB+NyIpd2VwgSuvnkxaNQyvlmukRi2BO35dGC5QZcUywiBfThK7sD/B22G46eQSGy7jy9IJbZ1xM+5Gquq97O8+V9R+xG2umY7H+Xot6PZF5OOHDFb6pETI8l42Ct5vlII2dfYqjedzXp/oWkuqnoaPz3gQN0KbFh9lk6oUuI1iLhpC1lHGo7zo1Wq441eQogKwaXSCplP414Qn8tQ4zW/E7cghKnzV185+iGupqNshY0eKUmK0vFLwvG+vw==&quot; }, } The kas_id should match the uuid generated by the database when the key access server was registered via the CreateKeyAccessServer request performed in step 1. (Required)The key_id can be any name you wish to associate with the key to be created, which will show up in the manifest of the TDF. (Required)The key_algorithm is the specific cipher bit/shape of the key and can be one of the following: (Required) Key Algorithm\talg Valuersa:2048\t1 rsa:4096\t2 ec:secp256r1\t3 ec:secp384r1\t4 ec:secp521r1\t5 The key_mode basically tells the KAS during a rewrap where to expect the key so that it can perform a decryption. Available modes are: (Required) Key Mode\tmode Value\tDescriptionKEY_MODE_CONFIG_ROOT_KEY\t1\tThe symmetric wrapping (root) key is stored with the platform configuration and the wrapped KAS key is stored in the platform database. KEY_MODE_PROVIDER_ROOT_KEY\t2\tThe symmetric wrapping (root) key is stored external to the platform using a KMS or HSM interface. The wrapped KAS key is stored in the platform's database. KEY_MODE_REMOTE\t3\tThe private portion of the asymmetric key is stored external to the platform using a KMS or HSM interface. This is also referred to as STRICT_MODE. No symmetric (root) key is required here since the platform is not storing any sensitive key material. KEY_MODE_PUBLIC_KEY_ONLY\t4\tNo private key information is stored. This is used when importing another org's policy information. The public_key_ctx holds the public key for the asymmetric key pair. (Required)The private_key_ctx holds the encrypted private key and a key_id specific to the symmetric key that is wrapping the private key. For keys of mode KEY_MODE_REMOTE, the key_id within private_key_ctx is used for identifying the remote private key. Our key managers use the key_id field present within the private_key_ctx when making requests to your external KMS/HSM instead of the key_id field at the root of the object. We do this to allow for larger key identifiers, which might be necessary for external providers. (Ex: arns with AWS) important Wrapped_Key is only required for KEY_MODE_CONFIG_ROOT_KEY and KEY_MODE_PROVIDER_ROOT_KEY. Key_Id is required for all key modes except KEY_MODE_PUBLIC_KEY_ONLY note You can also specify metadata for the key via a common metadata structure, but that is not covered here. The above JSON request covers registering a key where the asymmetric key pair will be stored within the platform's database, and the expected symmetric key that decrypts the private key will be stored within KAS. What if you want to only store a reference to a key and have that reference point to a key elsewhere? Say for a KMS, for example. That's where KEY_MODE_REMOTE is handy. { &quot;kas_id&quot;: &quot;db740f79-cf85-41b2-a27f-663b0e2b169b&quot;, &quot;key_id&quot;: &quot;aws-key-1&quot;, &quot;key_algorithm&quot;: 1, &quot;key_mode&quot;: 3, &quot;public_key_ctx&quot;: { &quot;pem&quot;: &quot;LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUMvVENDQWVXZ0F3SUJBZ0lVRjA5QWpIallJOENSekVGSmpjVEREY2lkZEgwd0RRWUpLb1pJaHZjTkFRRUwKQlFBd0RqRU1NQW9HQTFVRUF3d0RhMkZ6TUI0WERUSTBNRFV3TmpFeU1UQXhNbG9YRFRJMU1EVXdOakV5TVRBeApNbG93RGpFTU1Bb0dBMVVFQXd3RGEyRnpNSUlCSWpBTkJna3Foa2lHOXcwQkFRRUZBQU9DQVE4QU1JSUJDZ0tDCkFRRUFsVEI5eks3dzF1MG1mOWI5bmg4U3p0K0t5ZFdvbjUyUDVNY2k4Z1YremFQWjlmM0picllHVWZWWG16RmEKbVErTjBmTjZRaDhVOWlzbzFPZ3VHWDB1eTRwV1k3em1XTXFtRjVpSk9INENBdTVnV2Vuc3I5R2FXM1lmeEtWRgpWUnpKcUx0U3pBT3lvQ0lhNVErSTJUdmdNeEZjSFYwSGN4OXU5ekdYdDdKNUdlV1pTM3I2OUg4MGRGUjdGc0lRCk1hTDZRUHhmUWNWOVJidW9weUFwOE43TktiU3p4OEZUZEJYUWE4QnVxTXNvNlZyK0crZC9oeVp6YlpVc1pEUzQKZ3RtNnJCQlUraE8zMEN6WnBaZHBETVNPdjljNGNZUXlpdElwRjBrbVdQcE02YitKUzRyN2hGUU5kY1BWVXBWeAovVGowRUFNaWsrcHpZQUxyalRLZjlHcmJkd0lEQVFBQm8xTXdVVEFkQmdOVkhRNEVGZ1FVa2RTM0JuWHNnZUtSCnVNL0hCNW9sM3lacVRvMHdId1lEVlIwakJCZ3dGb0FVa2RTM0JuWHNnZUtSdU0vSEI1b2wzeVpxVG8wd0R3WUQKVlIwVEFRSC9CQVV3QXdFQi96QU5CZ2txaGtpRzl3MEJBUXNGQUFPQ0FRRUFTZXoxQVZhNVhHVXBrNUg4THpySQp4U0VzUnRHUitSV2NJdGxMZVVLc3NPTTNzY01mUEZ6SnQyTldwd0NwSTRiY2FGQVgzeFlLR1lxVnZzVmpxbTFVCnRKYmh6dzFhUVBUT2ZvNDZlOXNGK2lxZGJpbEplRUlQZllDb0w2VXR0Rm96TC9LZ2k1eWFlSXBScTFiaHFwVjcKTVRmSm1CbHVIckZhdWNFaEFMTDJoK0tsQ1R6amJsQnBZN1hpVFZHc3JZc0V2MmF3NEh2b1pZVkZVV3IxQ1JXYgppcDB4dFZ1SXE5RFhha0ZJYWVQWlZnMHRCczVBejBzUGlpNUdUVjUzVXdmcjY4VjhBYXFRSE9yVGRQL2ZadkN3CmRXTWdKSnltc21VUis1cTJCTnJvZHlTWDd4RzZxenE0Mm5BV1ZwSlNvb0g5ZWdSYXZuZ0Q5UXRreWU5KzBuRW0KVGc9PQotLS0tLUVORCBDRVJUSUZJQ0FURS0tLS0tCg==&quot; }, &quot;private_key_ctx&quot;: { &quot;key_id&quot;: &quot;arn:aws:kms:REGION:ACCOUNT-ID:key/KEY-ID&quot;, }, &quot;provider_config_id&quot;: &quot;948e8167-6f32-4eee-89b7-f0cd42ce70ea&quot; } The above is a valid request for registering a key with the platform where the private key is stored externally from the platform. The difference between the two requests is: The wrapped_key should not be within the private_key_ctx, in addition a provider configuration has been registered with the system. See details on provider configuration. In small detail, adding a provider configuration reference to a key tells KAS what key manager should be used to complete a rewrap operation. Assigning Key Mappings (Optional, but recommended)​ Follow the key mapping guide for creating mappings. Setting base key (Optional, but recommended)​ Follow the base key setup guide for setting a base key. Important additional comments​ As of version 0.7.0 of the OpenTDF platform, there is no way to delete a key. If you would like to deactivate a key, use the RotateKey rpc.When creating a key of mode KEY_MODE_CONFIG_ROOT_KEY the wrapped_key is expected to be base64 encoded.","keywords":"","version":"Next"},{"title":"Registered Resources","type":0,"sectionRef":"#","url":"/pr-172/components/policy/registered_resources","content":"Registered Resources Registered Resources are &quot;non-data&quot; resources (i.e. not a TDF data object) that are registered with the platform policy and may serve as the &quot;Entity&quot; or &quot;Resource&quot; in a decision request. Composition​ A Registered Resource consists of: A Registered ResourceA Registered Resource ValueOne or more Action Attribute Values A Registered Resource has a unique name and may contain multiple, unique Registered Resource Values. A Registered Resource Value is used to represent a specific instance of the Registered Resource and can be referenced by a FQN (Fully Qualified Name) in the form of https://reg_res/&lt;registered_resource.name&gt;/value/&lt;registered_resource_value.value&gt;. tip Registered Resource Values are not namespaced, so their FQNs cannot contain one. To address this, a prefix of https://reg_res/ has been chosen to identify a FQN as a Registered Resource Value. Registered Resource Values may contain multiple Action Attribute Values, which are unique mappings of an action to an attribute value. These mappings are used in Policy Decision Points for access control decisions. Examples As a Resource​ Alice is a cloud security architect. She needs to control user access to S3 buckets in her cloud environment. She defines a Registered Resource called s3_bucket with values like bucket1, bucket2, and bucket3. For the Registered Resource Value https://reg_res/s3_bucket/value/bucket1, she might define Action Attribute Values for actions such as read, create, and delete on attribute values such as https://demo.com/attr/classification/value/topsecret, https://demo.com/attr/classification/value/secret, and https://demo.com/attr/classification/value/unclassified to enforce the desired access control. In this case, Policy Decision Points would evaluate a user's attributes and subject mappings (acting as the entity) against the Action Attribute Values of the https://reg_res/s3_bucket/value/bucket1 Registered Resource Value (acting as the resource). As an Entity​ Bob is a network security administrator in a large organization. He needs to manage data communications across various networks that have different classification-based access controls. He defines a Registered Resource called network with values like private and public. For the Registered Resource Value https://reg_res/network/value/private, he might define Action Attribute Values for actions such as read and create on attribute values such as https://demo.com/attr/classification/value/topsecret and https://demo.com/attr/classification/value/secret. In this case, Policy Decision Points would evaluate the Action Attribute Values of the https://reg_res/network/value/private Registered Resource Value (acting as the entity) against either the Action Attribute Values of the https://reg_res/network/value/public Registered Resource Value or against a TDF's attributes (acting as the resource).","keywords":"","version":"Next"},{"title":"Entity Resolution Service","type":0,"sectionRef":"#","url":"/pr-172/components/entity_resolution","content":"Entity Resolution Service The entity resolution service is an IdP-specific service that interacts with the Identity Provider (IdP) to retrieve information about entities required by the Authorization service. As this service may vary between IdP, platform consumers must implement their own entity resolution service for the IdP they choose. It should follow the provided protos. Two versions of the EntityResolutionService are currently served simultaneously by the platform, with version 1 being deprecated soon: v2v1 v2 (latest)​ CreateEntityChainsFromTokens​ This endpoint takes JWT tokens (usually IdP access tokens) and converts them into entity chains. Steps: parse provided tokencategorize entities found within the token as either subject or environmentconstruct an entity chain for use within entitlement decisioning If Authorization Service (v2) requests are made with tokens representing the entities, this endpoint is utilized to break out subject and environment entities for decisioning. Below is an example request to CreateEntityChainsFromTokens, containing a list of tokens and their IDs: { &quot;tokens&quot;: [ { &quot;ephemeral_id&quot;: &quot;tok1&quot;, &quot;jwt&quot;: &quot;xxxxxxx....&quot; }, { &quot;ephemeral_id&quot;: &quot;tok2&quot;, &quot;jwt&quot;: &quot;yyyyyy.....&quot; } ] } An example response to this CreateEntityChainsFromTokens request: { &quot;entity_chains&quot;: [ { &quot;ephemeral_id&quot;: &quot;tok1&quot;, &quot;entities&quot;: [ { &quot;ephemeral_id&quot;: &quot;jwtentity-0&quot;, &quot;client_id&quot;: &quot;client1&quot;, &quot;category&quot;: &quot;CATEGORY_ENVIRONMENT&quot; }, { &quot;ephemeral_id&quot;: &quot;jwtentity-1&quot;, &quot;user_name&quot;: &quot;alice&quot;, &quot;category&quot;: &quot;CATEGORY_SUBJECT&quot; } ] }, { &quot;ephemeral_id&quot;: &quot;tok2&quot;, &quot;entities&quot;: [ { &quot;ephemeral_id&quot;: &quot;jwtentity-0&quot;, &quot;client_id&quot;: &quot;client2&quot;, &quot;category&quot;: &quot;CATEGORY_ENVIRONMENT&quot; }, { &quot;ephemeral_id&quot;: &quot;jwtentity-1&quot;, &quot;user_name&quot;: &quot;bob&quot;, &quot;category&quot;: &quot;CATEGORY_SUBJECT&quot; } ] } ] } ResolveEntities​ The ResolveEntities endpoint resolves a list of entities, using the IDs from a request to get further information about each entity from the IdP. An example request to ResolveEntities: { &quot;entities&quot;: [ { &quot;ephemeral_id&quot;: &quot;e1&quot;, &quot;user_name&quot;: &quot;alice&quot;, &quot;category&quot;: &quot;CATEGORY_SUBJECT&quot; }, { &quot;ephemeral_id&quot;: &quot;e2&quot;, &quot;client_id&quot;: &quot;client1&quot;, &quot;category&quot;: &quot;CATEGORY_ENVIRONMENT&quot; } ] } An example response to this ResolveEntities request: { &quot;entity_representations&quot;: [ { &quot;additional_props&quot;: [ { &quot;access&quot;: { &quot;impersonate&quot;: false, &quot;manage&quot;: false, &quot;manageGroupMembership&quot;: false, &quot;mapRoles&quot;: false, &quot;view&quot;: true }, &quot;createdTimestamp&quot;: 1716485083260, &quot;disableableCredentialTypes&quot;: [], &quot;emailVerified&quot;: false, &quot;enabled&quot;: true, &quot;id&quot;: &quot;09fb4171-9234-4707-ae57-d0088e0bc553&quot;, &quot;requiredActions&quot;: [], &quot;totp&quot;: false, &quot;username&quot;: &quot;alice&quot; } ], &quot;original_id&quot;: &quot;e1&quot; }, { &quot;additional_props&quot;: [ { &quot;access&quot;: { &quot;configure&quot;: false, &quot;manage&quot;: false, &quot;view&quot;: true }, &quot;adminUrl&quot;: &quot;&quot;, &quot;attributes&quot;: { &quot;backchannel.logout.revoke.offline.tokens&quot;: &quot;false&quot;, &quot;backchannel.logout.session.required&quot;: &quot;true&quot;, &quot;display.on.consent.screen&quot;: &quot;false&quot;, &quot;oauth2.device.authorization.grant.enabled&quot;: &quot;false&quot;, &quot;oidc.ciba.grant.enabled&quot;: &quot;false&quot; }, &quot;authenticationFlowBindingOverrides&quot;: {}, &quot;baseUrl&quot;: &quot;&quot;, &quot;bearerOnly&quot;: false, &quot;clientAuthenticatorType&quot;: &quot;client-secret&quot;, &quot;clientId&quot;: &quot;client1&quot;, &quot;consentRequired&quot;: false, &quot;defaultClientScopes&quot;: [ &quot;web-origins&quot;, &quot;acr&quot;, &quot;profile&quot;, &quot;roles&quot;, &quot;email&quot; ], &quot;description&quot;: &quot;&quot;, &quot;directAccessGrantsEnabled&quot;: true, &quot;enabled&quot;: true, &quot;frontchannelLogout&quot;: false, &quot;fullScopeAllowed&quot;: true, &quot;id&quot;: &quot;dea60e4e-05df-418e-a4a8-c5ae0b38855b&quot;, &quot;implicitFlowEnabled&quot;: false, &quot;name&quot;: &quot;client1&quot;, &quot;nodeReRegistrationTimeout&quot;: -1, &quot;notBefore&quot;: 0, &quot;optionalClientScopes&quot;: [ &quot;address&quot;, &quot;phone&quot;, &quot;offline_access&quot;, &quot;microprofile-jwt&quot; ], &quot;protocol&quot;: &quot;openid-connect&quot;, &quot;protocolMappers&quot;: [ { &quot;config&quot;: { &quot;access.token.claim&quot;: &quot;true&quot;, &quot;id.token.claim&quot;: &quot;true&quot;, &quot;included.custom.audience&quot;: &quot;http://localhost:8080&quot;, &quot;userinfo.token.claim&quot;: &quot;true&quot; }, &quot;consentRequired&quot;: false, &quot;id&quot;: &quot;4b44a437-ea88-4994-8533-af683cde90c5&quot;, &quot;name&quot;: &quot;audience-mapper&quot;, &quot;protocol&quot;: &quot;openid-connect&quot;, &quot;protocolMapper&quot;: &quot;oidc-audience-mapper&quot; }, ], &quot;publicClient&quot;: false, &quot;redirectUris&quot;: [], &quot;rootUrl&quot;: &quot;&quot;, &quot;secret&quot;: &quot;secret&quot;, &quot;serviceAccountsEnabled&quot;: true, &quot;standardFlowEnabled&quot;: true, &quot;surrogateAuthRequired&quot;: false, &quot;webOrigins&quot;: [] } ], &quot;original_id&quot;: &quot;e2&quot; } ] } In the above example, each entity in the request is resolved into its corresponding entity data. v1 (soon to be deprecated)​ CreateEntityChainFromJwtRequest​ This endpoint takes JWTs (usually IdP access tokens) and converts them into entity chains. As stated in the authorization documentation, multiple entities can be involved in a request. The token is parsed, the entities are categorized as either subjects or environments, and an entity chain is formed to ensure the relevant entities have the necessary entitlements. This endpoint is primarily used by the Key Access Server (KAS) to create an entity chain from the access token received during a rewrap request. Below is an example request to CreateEntityChainFromJwt, containing a list of tokens and their IDs: { &quot;tokens&quot;: [ { &quot;id&quot;: &quot;tok1&quot;, &quot;jwt&quot;: &quot;xxxxxxx....&quot; }, { &quot;id&quot;: &quot;tok2&quot;, &quot;jwt&quot;: &quot;yyyyyy.....&quot; } ] } An example response to this CreateEntityChainFromJwt request: { &quot;entity_chains&quot;: [ { &quot;id&quot;: &quot;tok1&quot;, &quot;entities&quot;: [ { &quot;id&quot;: &quot;jwtentity-0&quot;, &quot;client_id&quot;: &quot;client1&quot;, &quot;category&quot;: &quot;CATEGORY_ENVIRONMENT&quot; }, { &quot;id&quot;: &quot;jwtentity-1&quot;, &quot;user_name&quot;: &quot;alice&quot;, &quot;category&quot;: &quot;CATEGORY_SUBJECT&quot; } ] }, { &quot;id&quot;: &quot;tok2&quot;, &quot;entities&quot;: [ { &quot;id&quot;: &quot;jwtentity-0&quot;, &quot;client_id&quot;: &quot;client2&quot;, &quot;category&quot;: &quot;CATEGORY_ENVIRONMENT&quot; }, { &quot;id&quot;: &quot;jwtentity-1&quot;, &quot;user_name&quot;: &quot;bob&quot;, &quot;category&quot;: &quot;CATEGORY_SUBJECT&quot; } ] } ] } ResolveEntities​ The ResolveEntities endpoint resolves a list of entities, using the IDs from a request to get further information about each entity from the IdP. An example request to ResolveEntities: { &quot;entities&quot;: [ { &quot;id&quot;: &quot;e1&quot;, &quot;userName&quot;: &quot;alice&quot;, &quot;category&quot;: &quot;CATEGORY_SUBJECT&quot; }, { &quot;id&quot;: &quot;e2&quot;, &quot;clientId&quot;: &quot;client1&quot;, &quot;category&quot;: &quot;CATEGORY_ENVIRONMENT&quot; } ] } An example response to this ResolveEntities request: { &quot;entity_representations&quot;: [ { &quot;additional_props&quot;: [ { &quot;access&quot;: { &quot;impersonate&quot;: false, &quot;manage&quot;: false, &quot;manageGroupMembership&quot;: false, &quot;mapRoles&quot;: false, &quot;view&quot;: true }, &quot;createdTimestamp&quot;: 1716485083260, &quot;disableableCredentialTypes&quot;: [], &quot;emailVerified&quot;: false, &quot;enabled&quot;: true, &quot;id&quot;: &quot;09fb4171-9234-4707-ae57-d0088e0bc553&quot;, &quot;requiredActions&quot;: [], &quot;totp&quot;: false, &quot;username&quot;: &quot;alice&quot; } ], &quot;original_id&quot;: &quot;e1&quot; }, { &quot;additional_props&quot;: [ { &quot;access&quot;: { &quot;configure&quot;: false, &quot;manage&quot;: false, &quot;view&quot;: true }, &quot;adminUrl&quot;: &quot;&quot;, &quot;attributes&quot;: { &quot;backchannel.logout.revoke.offline.tokens&quot;: &quot;false&quot;, &quot;backchannel.logout.session.required&quot;: &quot;true&quot;, &quot;display.on.consent.screen&quot;: &quot;false&quot;, &quot;oauth2.device.authorization.grant.enabled&quot;: &quot;false&quot;, &quot;oidc.ciba.grant.enabled&quot;: &quot;false&quot; }, &quot;authenticationFlowBindingOverrides&quot;: {}, &quot;baseUrl&quot;: &quot;&quot;, &quot;bearerOnly&quot;: false, &quot;clientAuthenticatorType&quot;: &quot;client-secret&quot;, &quot;clientId&quot;: &quot;client1&quot;, &quot;consentRequired&quot;: false, &quot;defaultClientScopes&quot;: [ &quot;web-origins&quot;, &quot;acr&quot;, &quot;profile&quot;, &quot;roles&quot;, &quot;email&quot; ], &quot;description&quot;: &quot;&quot;, &quot;directAccessGrantsEnabled&quot;: true, &quot;enabled&quot;: true, &quot;frontchannelLogout&quot;: false, &quot;fullScopeAllowed&quot;: true, &quot;id&quot;: &quot;dea60e4e-05df-418e-a4a8-c5ae0b38855b&quot;, &quot;implicitFlowEnabled&quot;: false, &quot;name&quot;: &quot;client1&quot;, &quot;nodeReRegistrationTimeout&quot;: -1, &quot;notBefore&quot;: 0, &quot;optionalClientScopes&quot;: [ &quot;address&quot;, &quot;phone&quot;, &quot;offline_access&quot;, &quot;microprofile-jwt&quot; ], &quot;protocol&quot;: &quot;openid-connect&quot;, &quot;protocolMappers&quot;: [ { &quot;config&quot;: { &quot;access.token.claim&quot;: &quot;true&quot;, &quot;id.token.claim&quot;: &quot;true&quot;, &quot;included.custom.audience&quot;: &quot;http://localhost:8080&quot;, &quot;userinfo.token.claim&quot;: &quot;true&quot; }, &quot;consentRequired&quot;: false, &quot;id&quot;: &quot;4b44a437-ea88-4994-8533-af683cde90c5&quot;, &quot;name&quot;: &quot;audience-mapper&quot;, &quot;protocol&quot;: &quot;openid-connect&quot;, &quot;protocolMapper&quot;: &quot;oidc-audience-mapper&quot; }, ], &quot;publicClient&quot;: false, &quot;redirectUris&quot;: [], &quot;rootUrl&quot;: &quot;&quot;, &quot;secret&quot;: &quot;secret&quot;, &quot;serviceAccountsEnabled&quot;: true, &quot;standardFlowEnabled&quot;: true, &quot;surrogateAuthRequired&quot;: false, &quot;webOrigins&quot;: [] } ], &quot;original_id&quot;: &quot;e2&quot; } ] } In the above example, each entity in the request is resolved into its corresponding entity data.","keywords":"","version":"Next"},{"title":"Resource Mappings","type":0,"sectionRef":"#","url":"/pr-172/components/policy/resource_mappings","content":"Resource Mappings Resource Mappings associate various terms found within data to Attribute Values, serving as a mechanism for matching data tags to Attributes. A Resource Mapping contains: An associated attribute value.A set of related terms. The primary consumer of a Resource Mapping is a Policy Decision Point (PDP), which processes data, applies logic using the known terms, and relies on them to map the data to Attribute Values. By mapping a set of terms to a given attribute value, a Policy Enforcement Point (PEP) can properly apply the TDF to the resource data using the appropriate attribute values. Examples Alice is a system administrator. She defines an Attribute definition called color with values like red, green, blue, purple, etc. For the Attribute Value https://demo.com/attr/color/value/purple', she would define a Resource Mapping for processing data that may involve terms like indigo, lilac, plum, or lavender. Bob is a system administrator in the US Department of Defense (DoD). Bob defines a hierarchical attribute called classification with values of topsecret, secret, confidential, and unclassified. He needs to create a resource mapping that defines a normalization of the various short forms and acronyms that map to each of these classification levels. For the topsecret attribute value, he might include terms like ts, top secret, and top-secret. Whereas for unclassified he might include u, uc, or other variations.","keywords":"","version":"Next"},{"title":"Subject Mappings","type":0,"sectionRef":"#","url":"/pr-172/components/policy/subject_mappings","content":"Subject Mappings As data is bound to fully qualified Attribute Values when encrypted within a TDF, entities are associated with Attribute values through a mechanism called Subject Mappings. Entities (subjects, users, machines, etc.) are represented by their identity as determined from an identity provider (IdP). After an entity has securely authenticated with the IdP, the client's token (OIDC/OAUTH2) will include claims or attributes that describe that identity. Subject Mappings define how to map these identity attributes to actions on attribute values defined in the OpenTDF platform Policy. For more details on how the platform integrates with the IdP and how entities are resolved, refer to the Authorization documentation. Composition​ A Subject Mapping consists of: A mapped Attribute ValueA mapped Subject Condition SetOne or more policy Actions Actions on Attribute Value​ Subject Mappings link entities to one or more Actions they are allowed to take on Attribute Values, known as entitlements. For more information, see the Attribute Value and the Actions documentation. Subject Condition Set​ A Subject Condition Set is a logical structure to resolve a representation of the entity (an Access Token, EntityResolutionService response) to a boolean true or false. It contains multiple Subject Sets, each with Condition Groups, and each Condition Group contains Conditions. Each Subject Mapping links to one Attribute Value, but a Subject Condition Set can be reused across multiple Subject Mappings and Attribute Values. Examples​ Subject Mapping for Executives:​ Consider a flow where users with the idP role vice_president should be allowed to read data tagged https://example.org/attr/role_level/value/vice_president. The Subject Mapping would contain: Action: readAttribute Value: https://example.org/attr/role_level/value/vice_presidentA Subject Condition Set with this matching logic: subject_sets: - condition_groups: - boolean_operator: OR conditions: - subject_external_selector_value: '.role' operator: IN subject_external_values: - vice_president If the entity representation contains a field role: vice_president, the Subject Condition Set resolves true, so the Subject Mapping applies. The inverse also applies, where an entity representation containing role: &lt;anything else&gt;, or lacking the role field completely will resolve false, and the Subject Mapping would not apply (no entitlement). Subject Mapping for Contributors:​ Consider a flow where engineers with titles like staff, senior, junior, or intern should be able to create data tagged as https://example.org/attr/department_level/value/contributor. The Subject Mapping would contain: Action: createAttribute Value: https://example.org/attr/department_level/value/contributorA Subject Condition Set with this matching logic: subject_sets: - condition_groups: - boolean_operator: AND conditions: - subject_external_selector_value: '.title' operator: IN subject_external_values: - staff - senior - junior - intern - subject_external_selector_value: '.department' operator: IN subject_external_values: - engineering In plain language: If an entity's access token from the IdP or Entity Resolution Service (ERS) includes a title field with a value staff, senior, junior, or intern AND a department field with value engineering, then the Subject Mapping will apply to them, granting entitlement for the contained Action create on the Attribute Value of contributor.","keywords":"","version":"Next"},{"title":"Welcome to OpenTDF Docs","type":0,"sectionRef":"#","url":"/pr-172/introduction","content":"Welcome to OpenTDF Docs Find all the information you need to get started with OpenTDF. Quick Start This guide will walk you through setting up a new OpenTDF platform locally and walk you through some of the basic concepts within the OpenTDF platform. Learn more TDF The Trust Data Format (TDF) is an open standard that enables the cryptographic binding of attribute-based access control (ABAC) policy to a data object so that the policy travels with the data. Learn more Policy The OpenTDF Policy engine enables creation, enforcement, and subscription to policies. By using attribute-based access control (ABAC) policies, the OpenTDF Policy engine can enforce flexible, fine-grained access control based on entity entitlements. Learn more Authorization The OpenTDF Authorization service enables policy driven, access based decisions using attribute-based access control (ABAC) based on entity entitlements. These decisions are used to enforce both data privacy and application security, ensuring consistent policy enforcement across all policy enforcement points. Learn more Explore by Feature​ SDK Learn about the Trust Data Format (TDF) and how it enables the cryptographic binding of attribute-based access control (ABAC) policy to a data object. Learn more CLI Learn about the OpenTDF CLI tool (otdfctl) and how it can be used to manage the OpenTDF platform. Learn more","keywords":"","version":"Next"},{"title":"OpenAPI Clients","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients","content":"OpenAPI Clients OpenAPI client examples are available for platform endpoints. Expand each section in the navigation panel to access the OpenAPI documentation for each service.","keywords":"","version":"Next"},{"title":"GetDecisions","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/authorization/v1/authorization-authorization-service-get-decisions","content":"GetDecisions POST /v1/authorization GetDecisions Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"authorization","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/authorization/v1/authorization","content":"Version: v1 authorization 📄️ GetDecisionsByToken GetDecisionsByToken 📄️ GetDecisions GetDecisions 📄️ GetEntitlements GetEntitlements 📄️ authorization","keywords":"","version":"Next"},{"title":"GetDecisionsByToken","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/authorization/v1/authorization-authorization-service-get-decisions-by-token","content":"GetDecisionsByToken POST /v1/token/authorization GetDecisionsByToken Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"GetEntitlements","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/authorization/v1/authorization-authorization-service-get-entitlements","content":"GetEntitlements POST /v1/entitlements GetEntitlements Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"authorization.v2","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/authorization/v2/authorization-v-2","content":"Version: v1 authorization.v2 📄️ GetDecisionBulk GetDecisionBulk 📄️ GetDecisionMultiResource GetDecisionMultiResource 📄️ GetDecision GetDecision 📄️ GetEntitlements GetEntitlements 📄️ authorization.v2","keywords":"","version":"Next"},{"title":"GetDecision","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/authorization/v2/authorization-v-2-authorization-service-get-decision","content":"GetDecision POST /authorization.v2.AuthorizationService/GetDecision GetDecision Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"GetDecisionMultiResource","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/authorization/v2/authorization-v-2-authorization-service-get-decision-multi-resource","content":"GetDecisionMultiResource POST /authorization.v2.AuthorizationService/GetDecisionMultiResource GetDecisionMultiResource Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"GetDecisionBulk","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/authorization/v2/authorization-v-2-authorization-service-get-decision-bulk","content":"GetDecisionBulk POST /authorization.v2.AuthorizationService/GetDecisionBulk GetDecisionBulk Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"GetEntitlements","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/authorization/v2/authorization-v-2-authorization-service-get-entitlements","content":"GetEntitlements POST /authorization.v2.AuthorizationService/GetEntitlements GetEntitlements Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"entityresolution","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/entityresolution/v1/entityresolution","content":"Version: v1 entityresolution 📄️ CreateEntityChainFromJwt Deprecated: use v2 CreateEntityChainsFromTokens instead 📄️ ResolveEntities Deprecated: use v2 ResolveEntities instead 📄️ entityresolution","keywords":"","version":"Next"},{"title":"CreateEntityChainFromJwt","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/entityresolution/v1/entityresolution-entity-resolution-service-create-entity-chain-from-jwt","content":"CreateEntityChainFromJwt POST /entityresolution/entitychain Deprecated: use v2 CreateEntityChainsFromTokens instead Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"ResolveEntities","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/entityresolution/v1/entityresolution-entity-resolution-service-resolve-entities","content":"ResolveEntities POST /entityresolution/resolve Deprecated: use v2 ResolveEntities instead Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"entityresolution.v2","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/entityresolution/v2/entityresolution-v-2","content":"Version: v1 entityresolution.v2 📄️ CreateEntityChainsFromTokens CreateEntityChainsFromTokens 📄️ ResolveEntities ResolveEntities 📄️ entityresolution.v2","keywords":"","version":"Next"},{"title":"Platform Configuration","type":0,"sectionRef":"#","url":"/pr-172/getting-started/configuration","content":"Platform Configuration This guide provides details about the configuration setup for the platform, including the logger, services , and server configurations. The platform leverages viper to help load configuration. Platform Configuration Deployment Mode Service Negation SDK ConfigurationLogger ConfigurationServer Configuration CORS Configuration Additive ConfigurationProgrammatic Configuration Crypto ProviderTracing Configuration Database ConfigurationSecurity ConfigurationServices Configuration Key Access Server (KAS)Authorization Shared Keys (v1 &amp; v2)Authorization v1 OnlyAuthorization v2 OnlyExample: Authorization v1Example: Authorization v2 Entity Resolution Shared Keys (v1 &amp; v2)Entity Resolution v1 OnlyEntity Resolution v2 OnlyExample: Entity Resolution v1Example: Entity Resolution v2 PolicyCasbin Endpoint Authorization Key Aspects of Authorization ConfigurationConfiguration in opentdf-example.yamlRole PermissionsManaging Authorization Policy Cache Configuration Deployment Mode​ The platform is designed as a modular monolith, meaning that all services are built into and run from the same binary. However, these services can be grouped and run together based on specific needs. The available service groups are: all: Runs every service that is registered within the platform.core: Runs essential services, including policy, authorization, and wellknown services.kas: Runs the Key Access Server (KAS) service. Service Negation​ You can exclude specific services from any mode using the negation syntax -servicename: Syntax: mode: &lt;base-mode&gt;,-&lt;service1&gt;,-&lt;service2&gt;Constraint: At least one positive mode must be specified (negation-only modes like -kas will result in an error)Available services: policy, authorization, kas, entityresolution, wellknown Examples: # Run all services except Entity Resolution Service mode: all,-entityresolution # Run core services except Policy Service mode: core,-policy # Run all services except both KAS and Entity Resolution mode: all,-kas,-entityresolution Field\tDescription\tDefault\tEnvironment Variablemode\tDrives which services to run. Supported modes: all, core, kas. Use -servicename to exclude specific services (e.g., all,-entityresolution)\tall\tOPENTDF_MODE SDK Configuration​ The sdk configuration is used when operating the service in mode kas. When running in mode core or all an in-process communication is leveraged over an in-memory grpc server. Root level key sdk_config Field\tDescription\tDefault\tEnvironment Variablecore.endpoint\tThe core platform endpoint to connect to OPENTDF_SDK_CONFIG_ENDPOINT core.plaintext\tUse a plaintext grpc connection\tfalse\tOPENTDF_SDK_CONFIG_PLAINTEXT core.insecure\tUse an insecure tls connection\tfalse entityresolution.endpoint\tThe entityresolution endpoint to connect to entityresolution.plaintext\tUse a plaintext ERS grpc connection\tfalse entityresolution.insecure\tUse an insecure tls connection\tfalse client_id\tOAuth client id OPENTDF_SDK_CONFIG_CLIENT_ID client_secret\tThe clients credentials OPENTDF_SDK_CONFIG_CLIENT_SECRET Logger Configuration​ The logger configuration is used to define how the application logs its output. Root level key logger Field\tDescription\tDefault\tEnvironment Variablelevel\tThe logging level.\tinfo\tOPENTDF_LOGGER_LEVEL type\tThe format of the log output.\tjson\tOPENTDF_LOGGER_TYPE output\tStream output for logs, stderr or stdout\tstdout\tOPENTDF_LOGGER_OUTPUT Example: logger: level: debug type: text output: stderr Server Configuration​ The server configuration is used to define how the application runs its server. Root level key server Field\tDescription\tDefault\tEnvironment Variableauth.audience\tThe audience for the IDP. OPENTDF_SERVER_AUTH_AUDIENCE auth.issuer\tThe issuer for the IDP. OPENTDF_SERVER_AUTH_ISSUER auth.policy\tThe Casbin policy for enforcing authorization on endpoints. Described below auth.cache_refresh\tInterval in which the IDP jwks should be refreshed\t15m\tOPENTDF_SERVER_AUTH_CACHE_REFRESH auth.dpopskew\tThe amount of time drift allowed between when the client generated a dpop proof and the server time.\t1h\tOPENTDF_SERVER_AUTH auth.skew\tThe amount of time drift allowed between a tokens exp claim and the server time.\t1m\tOPENTDF_SERVER_AUTH_SKEW auth.public_client_id\t[DEPRECATED] The oidc client id. This is leveraged by otdfctl. OPENTDF_SERVER_AUTH_PUBLIC_CLIENT_ID auth.enforceDPoP\tIf true, DPoP bindings on Access Tokens are enforced.\tfalse\tOPENTDF_SERVER_AUTH_ENFORCEDPOP cryptoProvider\tA list of public/private keypairs and their use. Described below\tempty enable_pprof\tEnable golang performance profiling\tfalse\tOPENTDF_SERVER_ENABLE_PPROF grpc.reflection\tThe configuration for the grpc server.\ttrue\tOPENTDF_SERVER_GRPC_REFLECTION public_hostname\tThe public facing hostname for the server. OPENTDF_SERVER_PUBLIC_HOSTNAME host\tThe host address for the server.\t&quot;&quot;\tOPENTDF_SERVER_HOST port\tThe port number for the server.\t9000\tOPENTDF_SERVER_PORT tls.enabled\tEnable tls.\tfalse\tOPENTDF_SERVER_TLS_ENABLED tls.cert\tThe path to the tls certificate. OPENTDF_SERVER_TLS_CERT tls.key\tThe path to the tls key. OPENTDF_SERVER_TLS_KEY Example: server: grpc: reflection: true port: 8081 tls: enabled: true cert: /path/to/cert key: /path/to/key auth: enabled: true audience: https://example.com issuer: https://example.com cryptoProvider: standard: keys: - kid: r1 alg: rsa:2048 private: kas-private.pem cert: kas-cert.pem - kid: e1 alg: ec:secp256r1 private: kas-ec-private.pem cert: kas-ec-cert.pem CORS Configuration​ Root level key server.cors Field\tDescription\tDefault\tEnvironment Variableenabled\tEnable CORS for the server\ttrue\tOPENTDF_SERVER_CORS_ENABLED allowedorigins\tList of allowed origins (* for any)\t[]\tOPENTDF_SERVER_CORS_ALLOWEDORIGINS allowedmethods\tList of allowed HTTP methods\t[&quot;GET&quot;,&quot;POST&quot;,&quot;PATCH&quot;,&quot;DELETE&quot;,&quot;OPTIONS&quot;]\tOPENTDF_SERVER_CORS_ALLOWEDMETHODS allowedheaders\tList of allowed request headers\t[&quot;Accept&quot;,&quot;Accept-Encoding&quot;,&quot;Authorization&quot;,&quot;Connect-Protocol-Version&quot;,&quot;Content-Length&quot;,&quot;Content-Type&quot;,&quot;Dpop&quot;,&quot;X-CSRF-Token&quot;,&quot;X-Requested-With&quot;,&quot;X-Rewrap-Additional-Context&quot;]\tOPENTDF_SERVER_CORS_ALLOWEDHEADERS exposedheaders\tList of response headers browsers can access\t[]\tOPENTDF_SERVER_CORS_EXPOSEDHEADERS allowcredentials\tWhether credentials are included in CORS requests\ttrue\tOPENTDF_SERVER_CORS_ALLOWCREDENTIALS maxage\tMaximum age (seconds) of preflight cache\t3600\tOPENTDF_SERVER_CORS_MAXAGE additionalmethods\tAdditional methods to append to defaults\t[]\tOPENTDF_SERVER_CORS_ADDITIONALMETHODS additionalheaders\tAdditional headers to append to defaults\t[]\tOPENTDF_SERVER_CORS_ADDITIONALHEADERS additionalexposedheaders\tAdditional exposed headers to append\t[]\tOPENTDF_SERVER_CORS_ADDITIONALEXPOSEDHEADERS Additive Configuration​ The additional* fields allow operators to extend the default lists without replacing them entirely: server: cors: enabled: true # Add custom headers without copying all defaults additionalheaders: - X-Custom-Header - X-Another-Header To completely replace defaults, use the base fields directly: server: cors: allowedheaders: - Authorization - Content-Type # Only these headers will be allowed Programmatic Configuration​ For applications embedding the OpenTDF platform, CORS can also be configured programmatically using functional options. These are applied after YAML/environment configuration and follow the same additive semantics: import &quot;github.com/opentdf/platform/service/pkg/server&quot; err := server.Start( server.WithConfigFile(&quot;opentdf.yaml&quot;), // Add custom headers for your application server.WithAdditionalCORSHeaders(&quot;X-Custom-Header&quot;, &quot;X-App-Version&quot;), // Add custom methods if needed server.WithAdditionalCORSMethods(&quot;CUSTOM&quot;), // Expose additional response headers to browsers server.WithAdditionalCORSExposedHeaders(&quot;X-Request-Id&quot;, &quot;X-Trace-Id&quot;), ) Configuration Precedence: Defaults - Built-in default valuesYAML/Environment - Operator configuration via server.cors.* fieldsProgrammatic Options - Developer overlays via WithAdditionalCORS* functions All layers are additive. Deduplication is handled automatically (case-insensitive for headers per RFC 7230, case-sensitive for methods per RFC 7231). Crypto Provider​ To configure the Key Access Server, you must define a set of one or more public keypairs and a method for loading and using them. The crypto provider is implemented as an interface, allowing multiple implementations. Root level key cryptoProvider Environment Variable: OPENTDF_SERVER_CRYPTOPROVIDER_STANDARD='[{&quot;alg&quot;:&quot;rsa:2048&quot;,&quot;kid&quot;:&quot;k1&quot;,&quot;private&quot;:&quot;kas-private.pem&quot;,&quot;cert&quot;:&quot;kas-cert.pem&quot;}]' Field\tDescription\tDefaultcryptoProvider.type\tThe type of crypto provider to use.\tstandard cryptoProvider.standard.*.alg\tAn enum for the associated crypto type. E.g. rsa:2048 or ec:secp256r1 cryptoProvider.standard.*.kid\tA short, globally unique, stable identifier for this keypair. cryptoProvider.standard.*.private\tPath to the private key as a PEM file. cryptoProvider.standard.*.cert\t(Optional) Path to a public cert for the keypair. Tracing Configuration​ Root level key server.trace Field\tDescription\tDefault\tEnvironment Variableserver.trace.enabled\tEnable distributed tracing\tfalse\tOPENTDF_SERVER_TRACE_ENABLED server.trace.provider.name\tTracing provider (file or otlp)\totlp\tOPENTDF_SERVER_TRACE_PROVIDER_NAME For file provider: server.trace.provider.file.path: Path to trace file outputserver.trace.provider.file.prettyPrint: Enable pretty-printed JSONserver.trace.provider.file.maxSize: Maximum file size in MBserver.trace.provider.file.maxBackups: Maximum number of backup filesserver.trace.provider.file.maxAge: Maximum age of files in daysserver.trace.provider.file.compress: Enable compression of trace files For OTLP provider: server.trace.provider.otlp.protocol: Protocol to use (grpc or http/protobuf)server.trace.provider.otlp.endpoint: Endpoint URL for the collectorserver.trace.provider.otlp.insecure: Whether to use an insecure connectionserver.trace.provider.otlp.headers: Headers to include in OTLP requests Example: server: trace: enabled: true provider: name: otlp otlp: protocol: grpc endpoint: &quot;localhost:4317&quot; insecure: true Database Configuration​ The database configuration is used to define how the application connects to its database. Root level key db Field\tDescription\tDefault\tEnvironment Variableshost\tThe host address for the database.\tlocalhost\tOPENTDF_DB_HOST port\tThe port number for the database.\t5432\tOPENTDF_DB_PORT database\tThe name of the database.\topentdf\tOPENTDF_DB_DATABASE user\tThe username for the database.\tpostgres\tOPENTDF_DB_USER password\tThe password for the database.\tchangeme\tOPENTDF_DB_PASSWORD sslmode\tThe ssl mode for the database\tprefer\tOPENTDF_DB_SSLMODE schema\tThe schema for the database.\topentdf\tOPENTDF_DB_SCHEMA runMigration\tWhether to run the database migration or not.\ttrue\tOPENTDF_DB_RUNMIGRATION connect_timeout_seconds\tConnection timeout duration (seconds).\t15\tOPENTDF_DB_CONNECT_TIMEOUT_SECONDS pool\tPool configuration settings. pool.max_connection_count\tMaximum number of connections per pool.\t4\tOPENTDF_DB_POOL_MAX_CONNECTION_COUNT pool.min_connection_count\tMinimum number of connections per pool.\t0\tOPENTDF_DB_POOL_MIN_CONNECTION_COUNT pool.max_connection_lifetime_seconds\tMaximum seconds per connection lifetime.\t3600\tOPENTDF_DB_POOL_MAX_CONNECTION_LIFETIME_SECONDS pool.min_idle_connections_count\tMinimum number of idle connections per pool.\t0\tOPENTDF_DB_POOL_MIN_IDLE_CONNECTIONS_COUNT pool.max_connection_idle_seconds\tMaximum seconds allowed for idle connection.\t1800\tOPENTDF_DB_POOL_MAX_CONNECTION_IDLE_SECONDS pool.health_check_period_seconds\tInterval seconds per health check.\t60\tOPENTDF_DB_POOL_HEALTH_CHECK_PERIOD_SECONDS Example: db: host: localhost port: 5432 database: opentdf user: postgres password: changeme sslmode: require schema: opentdf runMigration: false connect_timeout_seconds: 15 pool: max_connection_count: 4 min_connection_count: 0 max_connection_lifetime_seconds: 3600 min_idle_connections_count: 0 max_connection_idle_seconds: 1800 health_check_period_seconds: 60 Security Configuration​ Root level key security Field\tDescription\tDefaultunsafe.clock_skew\tPlatform-wide maximum tolerated clock skew for token verification (Go duration, use cautiously)\t1m Warning: Increasing unsafe.clock_skew weakens token freshness guarantees. Only raise this value temporarily while you correct clock drift. Services Configuration​ Root level key services Key Access Server (KAS)​ Root level key kas Environment Variable: OPENTDF_SERVICES_KAS_KEYRING='[{&quot;kid&quot;:&quot;k1&quot;,&quot;alg&quot;:&quot;rsa:2048&quot;},{&quot;kid&quot;:&quot;k2&quot;,&quot;alg&quot;:&quot;ec:secp256r1&quot;}]' Field\tDescription\tDefaultkeyring.*.kid\tWhich key id this is binding keyring.*.alg\t(Optional) Associated algorithm. (Allows reusing KID with different algorithms) keyring.*.legacy\tIndicates this may be used for TDFs with no key ID; default if all unspecified.\tinferred preview.ec_tdf_enabled\tWhether tdf based ecc support is enabled.\tfalse preview.key_management\tWhether new key management features are enabled.\tfalse root_key\tKey needed when new key_management functionality is enabled. Example: security: unsafe: # Increase only when diagnosing clock drift issues # clock_skew: 90s services: kas: keyring: - kid: e2 alg: ec:secp256r1 - kid: e1 alg: ec:secp256r1 legacy: true - kid: r2f alg: rsa:2048 - kid: r1 alg: rsa:2048 legacy: true Authorization​ Root level key authorization Note: Both Authorization v1 and v2 use the same configuration section, but some keys are version-specific. See below for details. Shared Keys (v1 &amp; v2)​ Field\tDescription\tDefault\tEnvironment Variables(none currently; all keys are version-specific) Authorization v1 Only​ Field\tDescription\tDefault\tEnvironment Variablesrego.path\tPath to rego policy file\tLeverages embedded rego policy\tOPENTDF_SERVICES_AUTHORIZATION_REGO_PATH rego.query\tRego query to execute\tdata.opentdf.entitlements.attributes\tOPENTDF_SERVICES_AUTHORIZATION_REGO_QUERY Authorization v2 Only​ Field\tDescription\tDefault\tEnvironment Variablesentitlement_policy_cache.enabled\tEnable the entitlement policy cache\tfalse entitlement_policy_cache.refresh_interval\tHow often to refresh the entitlement policy cache (e.g. 30s) Example: Authorization v1​ services: authorization: rego: path: /path/to/policy.rego query: data.opentdf.entitlements.attributes Example: Authorization v2​ services: authorization: entitlement_policy_cache: enabled: false refresh_interval: 30s Entity Resolution​ Root level key entityresolution Note: Both Entity Resolution v1 and v2 use the same configuration section. All configuration keys are shared between v1 and v2, except cache_expiration, which is only used in v2. Shared Keys (v1 &amp; v2)​ Field\tDescription\tDefault\tEnvironment Variablemode\tThe mode in which to run ERS (keycloak or claims)\tkeycloak\tOPENTDF_SERVICES_ENTITYRESOLUTION_MODE url\tEndpoint URL for the entity resolution service (specific to keycloak mode)\t&quot;&quot;\tOPENTDF_SERVICES_ENTITYRESOLUTION_URL clientid\tKeycloak client ID for authentication (specific to keycloak mode)\t&quot;&quot;\tOPENTDF_SERVICES_ENTITYRESOLUTION_CLIENTID clientsecret\tKeycloak client secret for authentication(specific to keycloak mode)\t&quot;&quot;\tOPENTDF_SERVICES_ENTITYRESOLUTION_CLIENTSECRET realm\tKeycloak realm for authentication (specific to keycloak mode) OPENTDF_SERVICES_ENTITYRESOLUTION_REALM legacykeycloak\tEnables legacy Keycloak compatibility (/auth as base endpoint) (specific to keycloak mode)\tfalse\tOPENTDF_SERVICES_ENTITYRESOLUTION_LEGACYKEYCLOAK inferid.from.email\tInfer entity IDs from email addresses (specific to keycloak mode)\tfalse\tOPENTDF_SERVICES_ENTITYRESOLUTION_INFERID_FROM_EMAIL inferid.from.username\tInfer entity IDs from usernames (specific to keycloak mode)\tfalse\tOPENTDF_SERVICES_ENTITYRESOLUTION_INFERID_FROM_USERNAME inferid.from.clientid\tInfer entity IDs from client IDs (specific to keycloak mode)\tfalse\tOPENTDF_SERVICES_ENTITYRESOLUTION_INFERID_FROM_CLIENTID Entity Resolution v1 Only​ Field\tDescription\tDefault\tEnvironment Variables(none currently) Entity Resolution v2 Only​ Field\tDescription\tDefault\tEnvironment Variablecache_expiration\tCache duration for entity resolution results (e.g., 30s). Disabled if not set or zero. (specific to keycloak mode)\tdisabled Example: Entity Resolution v1​ services: entityresolution: url: http://localhost:8888/auth clientid: &quot;tdf-entity-resolution&quot; clientsecret: &quot;secret&quot; realm: &quot;opentdf&quot; legacykeycloak: true inferid: from: email: true username: true Example: Entity Resolution v2​ services: entityresolution: url: http://localhost:8888/auth clientid: &quot;tdf-entity-resolution&quot; clientsecret: &quot;secret&quot; realm: &quot;opentdf&quot; legacykeycloak: true inferid: from: email: true username: true cache_expiration: 30s Policy​ Root level key policy Field\tDescription\tDefault\tEnvironment Variableslist_request_limit_default\tPolicy List request limit default when not provided\t1000\tOPENTDF_SERVICES_POLICY_LIST_REQUEST_LIMIT_DEFAULT list_request_limit_max\tPolicy List request limit maximum enforced by services\t2500\tOPENTDF_SERVICES_POLICY_LIST_REQUEST_LIMIT_MAX Example: services: policy: list_request_limit_default: 1000 list_request_limit_max: 2500 Casbin Endpoint Authorization​ OpenTDF uses Casbin to manage authorization policies. This document provides an overview of how to configure and manage the default authorization policy in OpenTDF. Key Aspects of Authorization Configuration​ Username Claim: The claim in the OIDC token that should be used to extract a username.Group Claim: The claim in the OIDC token that should be used to find the group claims.Map (Deprecated): Mapping between policy roles and IdP roles.Extension: Policy that will extend the builtin policyCSV: The authorization policy in CSV format. This will override the builtin policy.Model: The Casbin policy model. This should only be set if you have a deep understanding of how casbin works. Configuration in opentdf-example.yaml​ Below is an example configuration snippet from opentdf-example.yaml: server: auth: enabled: true enforceDPoP: false # public_client_id: 'opentdf-public' # DEPRECATED audience: 'http://localhost:8080' issuer: http://keycloak:8888/auth/realms/opentdf policy: ## Deprecated ## Dot notation is used to access nested claims (i.e. realm_access.roles) claim: &quot;realm_access.roles&quot; ## Dot notation is used to access the username claim username_claim: &quot;email&quot; ## Dot notation is used to access the groups claim group_claim: &quot;realm_access.roles&quot; # Dot notation is used to access the claim the represents the idP client ID client_id_claim: # azp ## Deprecated: Use standard casbin policy groupings (g, &lt;user/group&gt;, &lt;role&gt;) ## Maps the external role to the OpenTDF role ## Note: left side is used in the policy, right side is the external role map: standard: opentdf-standard admin: opentdf-admin ## Policy that will extend the builtin policy. extension: | p, role:admin, *, *, allow p, role:standard, policy:attributes, read, allow p, role:standard, policy:subject-mappings, read, allow g, opentdf-admin, role:admin g, alice@opentdf.io, role:standard ## Custom policy (see examples https://github.com/casbin/casbin/tree/master/examples) ## This will overwrite the builtin policy. Use with caution. csv: | p, role:admin, *, *, allow p, role:standard, policy:attributes, read, allow p, role:standard, policy:subject-mappings, read, allow p, role:standard, policy:resource-mappings, read, allow p, role:standard, policy:kas-registry, read, allow p, role:unknown, entityresolution.EntityResolutionService.ResolveEntities, write, allow p, role:unknown, kas.AccessService/Rewrap, *, allow ## Custom model (see https://casbin.org/docs/syntax-for-models/) ## Avoid setting this unless you have a deep understanding of how casbin works. model: | [request_definition] r = sub, res, act, obj [policy_definition] p = sub, res, act, obj, eft [role_definition] g = _, _ [policy_effect] e = some(where (p.eft == allow)) &amp;&amp; !some(where (p.eft == deny)) [matchers] m = g(r.sub, p.sub) &amp;&amp; globOrRegexMatch(r.res, p.res) &amp;&amp; globOrRegexMatch(r.act, p.act) &amp;&amp; globOrRegexMatch(r.obj, p.obj) Role Permissions​ Admin: Can perform all operations.Standard User: Can read.Public Endpoints: Accessible without specific roles. Managing Authorization Policy​ Admins can manage the authorization policy directly in the YAML configuration file. For detailed configuration options, refer to the Casbin documentation. Cache Configuration​ The platform supports a cache manager to improve performance for frequently accessed data. You can configure the cache backend and its resource usage. Root level key cache Field\tDescription\tDefaultristretto.max_cost\tMaximum cost for the cache (e.g. 100mb, 1gb)\t1gb Example: cache: ristretto: max_cost: 1gb # Maximum cost (i.e. 1mb, 1gb) for the cache (default: 1gb) ","keywords":"","version":"Next"},{"title":"ResolveEntities","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/entityresolution/v2/entityresolution-v-2-entity-resolution-service-resolve-entities","content":"ResolveEntities POST /entityresolution.v2.EntityResolutionService/ResolveEntities ResolveEntities Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"CreateEntityChainsFromTokens","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/entityresolution/v2/entityresolution-v-2-entity-resolution-service-create-entity-chains-from-tokens","content":"CreateEntityChainsFromTokens POST /entityresolution.v2.EntityResolutionService/CreateEntityChainsFromTokens CreateEntityChainsFromTokens Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"PublicKey","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/kas/kas-access-service-public-key","content":"PublicKey GET /kas/v2/kas_public_key PublicKey Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"Rewrap","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/kas/kas-access-service-rewrap","content":"Rewrap POST /kas/v2/rewrap Rewrap Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"LegacyPublicKey","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/kas/kas-access-service-legacy-public-key","content":"LegacyPublicKey GET /kas/kas_public_key Endpoint intended for gRPC Gateway's REST endpoint to provide v1 compatibility with older TDF clients This endpoint is not recommended for use in new applications, prefer the v2 endpoint ('PublicKey') instead. buf:lint:ignore RPC_RESPONSE_STANDARD_NAME Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"kas","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/kas/kas","content":"Version: v1 kas 📄️ LegacyPublicKey Endpoint intended for gRPC Gateway's REST endpoint to provide v1 compatibility with older TDF clients 📄️ PublicKey PublicKey 📄️ Rewrap Rewrap 📄️ kas","keywords":"","version":"Next"},{"title":"DeleteAction","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/actions/policy-actions-action-service-delete-action","content":"DeleteAction POST /policy.actions.ActionService/DeleteAction DeleteAction Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"policy.actions","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/actions/policy-actions","content":"Version: v1 policy.actions 📄️ CreateAction CreateAction 📄️ DeleteAction DeleteAction 📄️ GetAction GetAction 📄️ ListActions ListActions 📄️ UpdateAction UpdateAction 📄️ policy.actions","keywords":"","version":"Next"},{"title":"GetAction","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/actions/policy-actions-action-service-get-action","content":"GetAction POST /policy.actions.ActionService/GetAction GetAction Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"CreateAction","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/actions/policy-actions-action-service-create-action","content":"CreateAction POST /policy.actions.ActionService/CreateAction CreateAction Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"UpdateAction","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/actions/policy-actions-action-service-update-action","content":"UpdateAction POST /policy.actions.ActionService/UpdateAction UpdateAction Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"ListActions","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/actions/policy-actions-action-service-list-actions","content":"ListActions POST /policy.actions.ActionService/ListActions ListActions Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"policy.attributes","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/attributes/policy-attributes","content":"Version: v1 policy.attributes 📄️ AssignKeyAccessServerToAttribute Deprecated: utilize AssignPublicKeyToAttribute 📄️ AssignKeyAccessServerToValue Deprecated: utilize AssignPublicKeyToValue 📄️ AssignPublicKeyToAttribute AssignPublicKeyToAttribute 📄️ AssignPublicKeyToValue AssignPublicKeyToValue 📄️ CreateAttributeValue CreateAttributeValue 📄️ CreateAttribute CreateAttribute 📄️ DeactivateAttributeValue DeactivateAttributeValue 📄️ DeactivateAttribute DeactivateAttribute 📄️ GetAttributeValue --------------------------------------* 📄️ GetAttributeValuesByFqns GetAttributeValuesByFqns 📄️ GetAttribute GetAttribute 📄️ ListAttributeValues ListAttributeValues 📄️ ListAttributes --------------------------------------* 📄️ RemoveKeyAccessServerFromAttribute Deprecated: utilize RemovePublicKeyFromAttribute 📄️ RemoveKeyAccessServerFromValue Deprecated: utilize RemovePublicKeyFromValue 📄️ RemovePublicKeyFromAttribute RemovePublicKeyFromAttribute 📄️ RemovePublicKeyFromValue RemovePublicKeyFromValue 📄️ UpdateAttributeValue UpdateAttributeValue 📄️ UpdateAttribute UpdateAttribute 📄️ policy.attributes","keywords":"","version":"Next"},{"title":"AssignKeyAccessServerToValue","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/attributes/policy-attributes-attributes-service-assign-key-access-server-to-value","content":"AssignKeyAccessServerToValue POST /policy.attributes.AttributesService/AssignKeyAccessServerToValue deprecated This endpoint has been deprecated and may be replaced or removed in future versions of the API. Deprecated: utilize AssignPublicKeyToValue Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"AssignKeyAccessServerToAttribute","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/attributes/policy-attributes-attributes-service-assign-key-access-server-to-attribute","content":"AssignKeyAccessServerToAttribute POST /policy.attributes.AttributesService/AssignKeyAccessServerToAttribute deprecated This endpoint has been deprecated and may be replaced or removed in future versions of the API. Deprecated: utilize AssignPublicKeyToAttribute Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"AssignPublicKeyToValue","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/attributes/policy-attributes-attributes-service-assign-public-key-to-value","content":"AssignPublicKeyToValue POST /policy.attributes.AttributesService/AssignPublicKeyToValue AssignPublicKeyToValue Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"CreateAttribute","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/attributes/policy-attributes-attributes-service-create-attribute","content":"CreateAttribute POST /policy.attributes.AttributesService/CreateAttribute CreateAttribute Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"Getting Started","type":0,"sectionRef":"#","url":"/pr-172/getting-started","content":"Getting Started This guide will walk you through setting up a new platform locally and walk you through some of the basic concepts within the OpenTDF platform. Pre-requisites​ A copy of the otdfctl CLI. Download the latest release A tool to run the compose file. PodmanDocker Compose Update /etc/hosts​ In order for the services to communicate correctly you will need to update your /etc/hosts file. echo -e &quot;127.0.0.1 platform.opentdf.local\\n127.0.0.1 keycloak.opentdf.local&quot; | sudo tee -a /etc/hosts Getting the Platform Running​ The first step is to get the platform running locally. You can use the following docker compose file to get the platform running. This docker compose file will start a local instance of the platform, Keycloak, and a Postgres database. warning Not for production use. Download docker-compose.yamlDocker Compose networks: default: name: opentdf_platform configs: caddy_config: content: | { log { level INFO output stdout } } https://keycloak.opentdf.local:9443 { tls internal reverse_proxy keycloak:8888 } https://platform.opentdf.local:8443 { tls internal reverse_proxy { to h2c://platform:8080 transport http { versions h2c 2 1.1 # Enable gRPC proxying } } } services: caddy: image: caddy:2.8.4-alpine command: ['caddy','run', '--config', '/etc/caddy/Caddyfile'] configs: - source: caddy_config target: /etc/caddy/Caddyfile ports: - &quot;8443:8443&quot; - &quot;9443:9443&quot; - &quot;2019:2019&quot; volumes: - caddy_data:/data depends_on: ensure-permissions: condition: service_completed_successfully healthcheck: test: [&quot;CMD&quot;, &quot;wget&quot;, &quot;--spider&quot;, &quot;-q&quot;, &quot;http://127.0.0.1:2019/metrics&quot;] interval: 5s timeout: 5s retries: 3 restart: unless-stopped check-certs: image: alpine:3.23 volumes: - type: volume source: caddy_data target: /etc/ssl/certs volume: subpath: caddy/certificates/local/keycloak.opentdf.local/ command: - sh - -c - | echo &quot;Checking certificates&quot; ls -alh /etc/ssl/certs cat /etc/ssl/certs/keycloak.opentdf.local.crt depends_on: caddy: condition: service_healthy ensure-permissions: condition: service_completed_successfully restart: &quot;no&quot; ensure-permissions: image: alpine:3.23 command: - 'sh' - '-c' - | chmod -R 755 /data volumes: - caddy_data:/data restart: &quot;no&quot; keycloak: volumes: - keys:/keys:ro image: keycloak/keycloak:25.0 restart: always depends_on: fix-keys-permissions: condition: service_completed_successfully command: - &quot;start-dev&quot; - &quot;--verbose&quot; - &quot;-Djavax.net.ssl.trustStorePassword=password&quot; - &quot;-Djavax.net.ssl.HostnameVerifier=AllowAll&quot; - &quot;-Djavax.net.ssl.trustStore=/keys/ca.jks&quot; - &quot;--spi-truststore-file-hostname-verification-policy=ANY&quot; environment: KC_PROXY: edge KC_HTTP_RELATIVE_PATH: /auth KC_HOSTNAME_STRICT: &quot;false&quot; KC_HOSTNAME_STRICT_BACKCHANNEL: &quot;false&quot; KC_HOSTNAME_STRICT_HTTPS: &quot;false&quot; KC_HTTP_ENABLED: &quot;true&quot; KC_HTTP_PORT: &quot;8888&quot; KC_HTTPS_PORT: &quot;8443&quot; KC_HTTP_MANAGEMENT_PORT: &quot;9001&quot; KEYCLOAK_ADMIN: admin KEYCLOAK_ADMIN_PASSWORD: changeme #KC_HOSTNAME_URL: http://localhost:8888/auth KC_FEATURES: &quot;preview,token-exchange&quot; KC_HEALTH_ENABLED: &quot;true&quot; KC_HTTPS_KEY_STORE_PASSWORD: &quot;password&quot; KC_HTTPS_KEY_STORE_FILE: &quot;/keys/ca.jks&quot; KC_HTTPS_CERTIFICATE_FILE: &quot;/keys/localhost.crt&quot; KC_HTTPS_CERTIFICATE_KEY_FILE: &quot;/keys/localhost.key&quot; KC_HTTPS_CLIENT_AUTH: &quot;request&quot; ### # The following environment variable resolves SIGILL with Code 134 when running Java processes on Apple M4 chips # # On Apple Silicon (M4 chip): # export JAVA_OPTS_APPEND=&quot;-XX:UseSVE=0&quot; # docker-compose up # # On other architectures: # export JAVA_OPTS_APPEND=&quot;&quot; # docker-compose up # # Or set directly: JAVA_OPTS_APPEND=&quot;-XX:UseSVE=0&quot; docker-compose up JAVA_OPTS_APPEND: &quot;${JAVA_OPTS_APPEND:-}&quot; ### # ports: # - &quot;${KC_EXPOSE_PORT:-8443}:8443&quot; # - &quot;${KC_EXPOSE_PORT_HTTP:-8888}:8888&quot; # - &quot;${KC_EXPOSE_PORT_MGMT:-9001}:9001&quot; healthcheck: test: - CMD-SHELL - | [ -f /tmp/HealthCheck.java ] || echo &quot;public class HealthCheck { public static void main(String[] args) throws java.lang.Throwable { javax.net.ssl.HttpsURLConnection.setDefaultHostnameVerifier((hostname, session) -&gt; true); javax.net.ssl.SSLContext sc = javax.net.ssl.SSLContext.getInstance(\\&quot;SSL\\&quot;); sc.init(null, new javax.net.ssl.TrustManager[]{ new javax.net.ssl.X509TrustManager() { public java.security.cert.X509Certificate[] getAcceptedIssuers() { return null; } public void checkClientTrusted(java.security.cert.X509Certificate[] certs, String authType) {} public void checkServerTrusted(java.security.cert.X509Certificate[] certs, String authType) {} } }, new java.security.SecureRandom()); javax.net.ssl.HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory()); java.net.HttpURLConnection conn = (java.net.HttpURLConnection)new java.net.URL(args[0]).openConnection(); System.exit(java.net.HttpURLConnection.HTTP_OK == conn.getResponseCode() ? 0 : 1); } }&quot; &gt; /tmp/HealthCheck.java &amp;&amp; java ${JAVA_OPTS_APPEND} /tmp/HealthCheck.java http://localhost:8888/auth 2&gt;/dev/null interval: 10s timeout: 10s retries: 10 start_period: 3m opentdfdb: image: postgres:15-alpine restart: always user: postgres environment: POSTGRES_USER: postgres POSTGRES_PASSWORD: changeme POSTGRES_DB: opentdf healthcheck: test: [&quot;CMD-SHELL&quot;, &quot;pg_isready&quot;] interval: 5s timeout: 5s retries: 10 jaeger: image: jaegertracing/all-in-one:latest environment: COLLECTOR_OTLP_ENABLED: &quot;true&quot; ports: - &quot;16686:16686&quot; # Web UI - &quot;4317:4317&quot; # OTLP gRPC - &quot;4318:4318&quot; # OTLP HTTP - &quot;14250:14250&quot; # Model/collector gRPC profiles: - tracing restart: always # Provision Keycloak with initial configuration platform-provision-keycloak: image: registry.opentdf.io/platform:nightly command: [&quot;provision&quot;, &quot;keycloak&quot;, &quot;-e&quot;, &quot;https://keycloak.opentdf.local:9443/auth&quot;, &quot;-f&quot;, &quot;/configs/keycloak_data.yaml&quot;] depends_on: keycloak: condition: service_healthy opentdfdb: condition: service_healthy patch-platform-config: condition: service_completed_successfully download-keycloak-data: condition: service_completed_successfully generate-keys: condition: service_completed_successfully volumes: - configs:/configs:ro - keys:/keys:ro environment: - OPENTDF_CONFIG_FILE=/configs/opentdf.yaml restart: &quot;no&quot; extra_hosts: - &quot;keycloak.opentdf.local:host-gateway&quot; # Prepare fixtures directory structure - create symlink to expected location prepare-fixtures: image: alpine:3.23 volumes: - configs:/configs depends_on: download-fixtures: condition: service_completed_successfully command: - sh - -c - | mkdir -p /configs/service/internal/fixtures cd /configs ln -sf /configs/service/internal/fixtures ./service restart: &quot;no&quot; # Add sample attributes and metadata platform-provision-fixtures: image: registry.opentdf.io/platform:nightly command: [&quot;provision&quot;, &quot;fixtures&quot;, &quot;--config-file&quot;, &quot;/configs/opentdf.yaml&quot;] working_dir: /configs depends_on: platform-provision-keycloak: condition: service_completed_successfully opentdfdb: condition: service_healthy prepare-fixtures: condition: service_completed_successfully generate-keys: condition: service_completed_successfully volumes: - configs:/configs:ro - keys:/keys:ro restart: &quot;no&quot; # Prepare CA certificates bundle with Caddy cert prepare-ca-certs: image: alpine:3.23 volumes: - type: volume source: caddy_data target: /caddy-certs read_only: true volume: subpath: caddy/certificates/local/keycloak.opentdf.local - platform_certs:/etc/ssl/certs depends_on: caddy: condition: service_healthy command: - sh - -c - | # Install ca-certificates package apk add --no-cache ca-certificates # Copy Caddy certificate to CA bundle cp /caddy-certs/keycloak.opentdf.local.crt /usr/local/share/ca-certificates/ update-ca-certificates # Copy the updated CA bundle to shared volume cp -r /etc/ssl/certs/* /etc/ssl/certs/ echo &quot;CA certificates prepared successfully&quot; restart: &quot;no&quot; # Main OpenTDF Platform server platform: image: registry.opentdf.io/platform:nightly command: [&quot;start&quot;, &quot;--config-file&quot;, &quot;/configs/opentdf.yaml&quot;] depends_on: platform-provision-fixtures: condition: service_completed_successfully keycloak: condition: service_healthy opentdfdb: condition: service_healthy generate-keys: condition: service_completed_successfully prepare-ca-certs: condition: service_completed_successfully ports: - &quot;8080:8080&quot; volumes: - configs:/configs:ro - keys:/keys:ro - platform_certs:/etc/ssl/certs:ro extra_hosts: - &quot;keycloak.opentdf.local:host-gateway&quot; restart: unless-stopped # Initialize volume permissions init-volumes: image: alpine:3.23 volumes: - configs:/configs - keys:/keys command: - sh - -c - | chmod 777 /configs /keys mkdir -p /configs/service/internal/fixtures chmod -R 777 /configs restart: &quot;no&quot; # Fix keys permissions after generation fix-keys-permissions: image: alpine:3.23 volumes: - keys:/keys depends_on: generate-keys: condition: service_completed_successfully command: - sh - -c - | chmod -R 755 /keys chmod 644 /keys/* restart: &quot;no&quot; # Download platform configuration file download-platform-config: image: alpine:3.23 volumes: - configs:/configs depends_on: init-volumes: condition: service_completed_successfully command: ['wget', '-O', '/configs/opentdf.yaml', 'https://raw.githubusercontent.com/opentdf/platform/main/opentdf-example.yaml'] restart: &quot;no&quot; # Patch platform configuration to use keycloak.opentdf.local:9443 patch-platform-config: image: alpine:3.23 volumes: - configs:/configs depends_on: download-platform-config: condition: service_completed_successfully command: - sh - -c - | apk add --no-cache sed sed -i 's|http://keycloak:8888|https://keycloak.opentdf.local:9443|g' /configs/opentdf.yaml echo &quot;Patched opentdf.yaml to use keycloak.opentdf.local:9443&quot; restart: &quot;no&quot; # Download Keycloak provisioning data download-keycloak-data: image: alpine:3.23 volumes: - configs:/configs depends_on: init-volumes: condition: service_completed_successfully entrypoint: /bin/sh command: - -c - | URL='https://raw.githubusercontent.com/opentdf/platform/main/service/cmd/keycloak_data.yaml' OUTPUT='/configs/keycloak_data.yaml' MAX_ATTEMPTS=3 for i in $$(seq 1 $$MAX_ATTEMPTS); do echo &quot;Attempt $$i of $$MAX_ATTEMPTS: Downloading keycloak_data.yaml...&quot; if wget -O &quot;$$OUTPUT&quot; &quot;$$URL&quot;; then echo &quot;Download successful&quot; # Validate the downloaded file if [ -f &quot;$$OUTPUT&quot; ] &amp;&amp; [ -s &quot;$$OUTPUT&quot; ]; then if head -1 &quot;$$OUTPUT&quot; | grep -q -E '^(---|\\w+:)'; then echo &quot;Validation passed: File exists, non-empty, and appears to be valid YAML&quot; exit 0 else echo &quot;Validation failed: File does not appear to be valid YAML&quot; rm -f &quot;$$OUTPUT&quot; fi else echo &quot;Validation failed: File is missing or empty&quot; fi else echo &quot;Download failed (attempt $$i)&quot; fi if [ $$i -lt $$MAX_ATTEMPTS ]; then echo &quot;Retrying in 2 seconds...&quot; sleep 2 fi done echo &quot;ERROR: Failed to download and validate keycloak_data.yaml after $$MAX_ATTEMPTS attempts&quot; exit 1 restart: &quot;no&quot; # Download fixtures data download-fixtures: image: alpine:3.23 volumes: - configs:/configs depends_on: init-volumes: condition: service_completed_successfully command: ['wget', '-O', '/configs/service/internal/fixtures/policy_fixtures.yaml', 'https://raw.githubusercontent.com/opentdf/platform/main/service/internal/fixtures/policy_fixtures.yaml'] restart: &quot;no&quot; # Download init-temp-keys script download-init-script: image: alpine:3.23 volumes: - configs:/configs depends_on: init-volumes: condition: service_completed_successfully entrypoint: /bin/sh command: - -c - | URL='https://raw.githubusercontent.com/opentdf/platform/main/.github/scripts/init-temp-keys.sh' OUTPUT='/configs/init-temp-keys.sh' MAX_ATTEMPTS=3 for i in $$(seq 1 $$MAX_ATTEMPTS); do echo &quot;Attempt $$i of $$MAX_ATTEMPTS: Downloading init-temp-keys.sh...&quot; if wget -O &quot;$$OUTPUT&quot; &quot;$$URL&quot;; then echo &quot;Download successful&quot; # Validate the downloaded file if [ -f &quot;$$OUTPUT&quot; ] &amp;&amp; [ -s &quot;$$OUTPUT&quot; ]; then if head -1 &quot;$$OUTPUT&quot; | grep -q '^#!/'; then echo &quot;Validation passed: File exists, non-empty, and appears to be a shell script&quot; exit 0 else echo &quot;Validation failed: File does not appear to be a valid shell script&quot; rm -f &quot;$$OUTPUT&quot; fi else echo &quot;Validation failed: File is missing or empty&quot; fi else echo &quot;Download failed (attempt $$i)&quot; fi if [ $$i -lt $$MAX_ATTEMPTS ]; then echo &quot;Retrying in 2 seconds...&quot; sleep 2 fi done echo &quot;ERROR: Failed to download and validate init-temp-keys.sh after $$MAX_ATTEMPTS attempts&quot; exit 1 restart: &quot;no&quot; # Generate keys without Docker dependency generate-keys: image: alpine:3.23 volumes: - configs:/configs - keys:/keys depends_on: download-init-script: condition: service_completed_successfully init-volumes: condition: service_completed_successfully entrypoint: /bin/sh command: - -c - | apk add --no-cache openssl openjdk11-jre bash cd /keys # Generate KAS RSA private key openssl genpkey -algorithm RSA -out /keys/kas-private.pem -pkeyopt rsa_keygen_bits:2048 openssl rsa -in /keys/kas-private.pem -pubout -out /keys/kas-cert.pem # Generate ECC Key openssl ecparam -name prime256v1 &gt; /tmp/ecparams.tmp openssl req -x509 -nodes -newkey ec:/tmp/ecparams.tmp -subj &quot;/CN=kas&quot; -keyout /keys/kas-ec-private.pem -out /keys/kas-ec-cert.pem -days 365 # Generate CA openssl req -x509 -nodes -newkey RSA:2048 -subj &quot;/CN=ca&quot; -keyout /keys/keycloak-ca-private.pem -out /keys/keycloak-ca.pem -days 365 # Generate localhost certificate printf &quot;subjectAltName=DNS:localhost,IP:127.0.0.1&quot; &gt; /tmp/sanX509.conf printf &quot;[req]\\ndistinguished_name=req_distinguished_name\\n[req_distinguished_name]\\n[alt_names]\\nDNS.1=localhost\\nIP.1=127.0.0.1&quot; &gt; /tmp/req.conf openssl req -new -nodes -newkey rsa:2048 -keyout /keys/localhost.key -out /tmp/localhost.req -batch -subj &quot;/CN=localhost&quot; -config /tmp/req.conf openssl x509 -req -in /tmp/localhost.req -CA /keys/keycloak-ca.pem -CAkey /keys/keycloak-ca-private.pem -CAcreateserial -out /keys/localhost.crt -days 3650 -sha256 -extfile /tmp/sanX509.conf # Generate sample user certificate openssl req -new -nodes -newkey rsa:2048 -keyout /keys/sampleuser.key -out /tmp/sampleuser.req -batch -subj &quot;/CN=sampleuser&quot; openssl x509 -req -in /tmp/sampleuser.req -CA /keys/keycloak-ca.pem -CAkey /keys/keycloak-ca-private.pem -CAcreateserial -out /keys/sampleuser.crt -days 3650 # Convert to PKCS12 openssl pkcs12 -export -in /keys/keycloak-ca.pem -inkey /keys/keycloak-ca-private.pem -out /keys/ca.p12 -nodes -passout pass:password # Convert PKCS12 to JKS using keytool (no Docker needed) keytool -importkeystore \\ -srckeystore /keys/ca.p12 \\ -srcstoretype PKCS12 \\ -destkeystore /keys/ca.jks \\ -deststoretype JKS \\ -srcstorepass &quot;password&quot; \\ -deststorepass &quot;password&quot; \\ -noprompt echo &quot;Keys generated successfully&quot; environment: JAVA_OPTS_APPEND: &quot;${JAVA_OPTS_APPEND:-}&quot; restart: &quot;no&quot; volumes: keys: name: opentdf_keys configs: name: opentdf_configs caddy_data: platform_certs: name: opentdf_platform_certs Save the Docker Compose File​ Click the download button above to save the docker-compose.yaml file to your local machine. If you prefer to copy the content manually, save it as docker-compose.yaml. Start the Platform​ Once you have the docker-compose.yaml file saved, start the platform using the following command: # If running on Apple M4 chip JAVA_OPTS_APPEND=&quot;-XX:UseSVE=0&quot; docker compose --file docker-compose.yaml up -d # Or on other architectures docker compose --file docker-compose.yaml up -d Note for Apple M4 chip users: The JAVA_OPTS_APPEND=&quot;-XX:UseSVE=0&quot; environment variable resolves SIGILL with Code 134 errors when running Java processes (such as Keycloak). Trust Self Signed Certificates​ After starting the platform, caddy will generate self-signed certificates during the bootstrapping process. You will either need to trust these certificates on your system or use the --tls-no-verify flag on every command. If using the --tls-no-verify command it will disable profiles and require that you pass in the host and authentication into each command. First, extract the certificates from the container: mkdir -p ./opentdf-certs docker compose cp caddy:/data/caddy/certificates/local/keycloak.opentdf.local/keycloak.opentdf.local.crt ./opentdf-certs docker compose cp caddy:/data/caddy/certificates/local/platform.opentdf.local/platform.opentdf.local.crt ./opentdf-certs Import and Trust Certificates by Operating System​ macOS Import certificates to Keychain: # Import both certificates to the System keychain sudo security add-trusted-cert -d -r trustRoot -k /Library/Keychains/System.keychain ./opentdf-certs/keycloak.opentdf.local.crt sudo security add-trusted-cert -d -r trustRoot -k /Library/Keychains/System.keychain ./opentdf-certs/platform.opentdf.local.crt Alternative: Using Keychain Access GUI: Open Keychain Access (Applications → Utilities → Keychain Access)Drag and drop both .crt files into the System keychainDouble-click each certificate and set Trust → When using this certificate to Always TrustEnter your admin password when prompted Verify certificates are trusted: security verify-cert -c ./opentdf-certs/keycloak.opentdf.local.crt security verify-cert -c ./opentdf-certs/platform.opentdf.local.crt References: Add certificates to a keychainChange trust settings of a certificate Windows Import certificates using PowerShell (Run as Administrator): # Import to Trusted Root Certification Authorities Import-Certificate -FilePath &quot;.\\opentdf-certs\\keycloak.opentdf.local.crt&quot; -CertStoreLocation Cert:\\LocalMachine\\Root Import-Certificate -FilePath &quot;.\\opentdf-certs\\platform.opentdf.local.crt&quot; -CertStoreLocation Cert:\\LocalMachine\\Root Alternative: Using Certificate Manager GUI: Press Win + R, type certmgr.msc, and press EnterNavigate to Trusted Root Certification Authorities → CertificatesRight-click and select All Tasks → ImportFollow the wizard to import both .crt filesChoose Place all certificates in the following store → Trusted Root Certification Authorities Alternative: Using MMC (Microsoft Management Console): Press Win + R, type mmc, and press EnterGo to File → Add/Remove Snap-inAdd Certificates snap-in for Local ComputerNavigate to Certificates (Local Computer) → Trusted Root Certification Authorities → CertificatesRight-click and import both certificates Linux (Ubuntu/Debian) Copy certificates to system certificate directory: # Copy certificates to the ca-certificates directory sudo cp ./opentdf-certs/keycloak.opentdf.local.crt /usr/local/share/ca-certificates/ sudo cp ./opentdf-certs/platform.opentdf.local.crt /usr/local/share/ca-certificates/ # Update the certificate store sudo update-ca-certificates Verify certificates are installed: # Check if certificates are in the trusted store awk -v cmd='openssl x509 -noout -subject' '/BEGIN/{close(cmd)};{print | cmd}' &lt; /etc/ssl/certs/ca-certificates.crt | grep opentdf Linux (RHEL/CentOS/Fedora) Copy certificates to system certificate directory: # Copy certificates to the ca-trust directory sudo cp ./opentdf-certs/keycloak.opentdf.local.crt /etc/pki/ca-trust/source/anchors/ sudo cp ./opentdf-certs/platform.opentdf.local.crt /etc/pki/ca-trust/source/anchors/ # Update the certificate store sudo update-ca-trust Verify certificates are installed: # Check if certificates are trusted trust list | grep &quot;opentdf.local&quot; Linux (Arch Linux) Copy certificates to system certificate directory: # Copy certificates to the ca-certificates directory sudo cp ./opentdf-certs/keycloak.opentdf.local.crt /etc/ca-certificates/trust-source/anchors/ sudo cp ./opentdf-certs/platform.opentdf.local.crt /etc/ca-certificates/trust-source/anchors/ # Update the certificate store sudo trust extract-compat Browser-specific Certificate Installation Some browsers (like Firefox) maintain their own certificate stores. If you continue to see certificate warnings in your browser after following the OS-specific steps above, you may need to import the certificates directly into your browser's certificate store. Certificate Validity These self-signed certificates are only valid for local development. Never use self-signed certificates in production environments. Create a Profile​ Creating a profile allows us to store the host we want to connect to and then to tie our credentials to it when we login. otdfctl profile create platform-otdf-local https://platform.opentdf.local:8443 Login to the Platform​ During the provisioning of the platform, a few test clients were created in Keycloak. You can use the following credentials to login to the platform. This will cache those credentials locally for the otdfctl CLI. You can also pass in the flags --with-client-creds and --with-client-creds-file on every command to authenticate with the platform. otdfctl --profile platform-otdf-local auth client-credentials opentdf secret Create A Namespace​ In this first step you are going to create a new namespace. A namespace is a way to organize your attributes within the platform. You will see an empty list of namespaces when you first start the platform. otdfctl --profile platform-otdf-local policy attributes namespaces list SUCCESS Found namespaces list ┌─────────────────────────┬───────────────────────────┬─────────────────────────────┬────────────────────────────┬────────────────────────────────┬────────────────────────────────┐ │Id │Name │Active │Labels │Created At │Updated At │ ├─────────────────────────┼───────────────────────────┼─────────────────────────────┼────────────────────────────┼────────────────────────────────┼────────────────────────────────┤ └─────────────────────────┴───────────────────────────┴─────────────────────────────┴────────────────────────────┴────────────────────────────────┴────────────────────────────────┘ NOTE Use 'namespaces get --id=&lt;id&gt; --json' to see all properties Create a new namespace​ otdfctl --profile platform-otdf-local policy attributes namespaces create --name opentdf.io SUCCESS Created namespaces: 7650f02a-be00-4faa-a1d1-37cded5e23dc ┌────────────────────────────────────────────────────────────────────────────┬─────────────────────────────────────────────────────────────────────────────────────────────────────┐ │Property │Value │ ├────────────────────────────────────────────────────────────────────────────┼─────────────────────────────────────────────────────────────────────────────────────────────────────┤ │Name │opentdf.io │ │Id │7650f02a-be00-4faa-a1d1-37cded5e23dc │ │Created At │Mon Jun 24 11:02:00 UTC 2024 │ │Updated At │Mon Jun 24 11:02:00 UTC 2024 │ └────────────────────────────────────────────────────────────────────────────┴─────────────────────────────────────────────────────────────────────────────────────────────────────┘ NOTE Use 'namespaces get --id=7650f02a-be00-4faa-a1d1-37cded5e23dc --json' to see all properties List the namespaces​ With that namespace created we should be able to see it in the list of namespaces as well as get the details of the namespace. otdfctl --profile platform-otdf-local policy attributes namespaces list SUCCESS Found namespaces list ┌──────────────────────────────────────────────┬────────────────────┬────────────────┬────────────────┬──────────────────────────────────────┬─────────────────────────────────────┐ │Id │Name │Active │Labels │Created At │Updated At │ ├──────────────────────────────────────────────┼────────────────────┼────────────────┼────────────────┼──────────────────────────────────────┼─────────────────────────────────────┤ │7650f02a-be00-4faa-a1d1-37cded5e23dc │opentdf.io │true │[] │Mon Jun 24 11:02:00 UTC 2024 │Mon Jun 24 11:02:00 UTC 2024 │ └──────────────────────────────────────────────┴────────────────────┴────────────────┴────────────────┴──────────────────────────────────────┴─────────────────────────────────────┘ NOTE Use 'namespaces get --id=&lt;id&gt; --json' to see all properties Let's export the namespace id for later use. export NAMESPACE_ID=&lt;id&gt; Get the details of the namespace​ otdfctl --profile platform-otdf-local policy attributes namespaces get --id=$NAMESPACE_ID SUCCESS Found namespaces: 7650f02a-be00-4faa-a1d1-37cded5e23dc ┌────────────────────────────────────────────────────────────────────────────┬─────────────────────────────────────────────────────────────────────────────────────────────────────┐ │Property │Value │ ├────────────────────────────────────────────────────────────────────────────┼─────────────────────────────────────────────────────────────────────────────────────────────────────┤ │Id │7650f02a-be00-4faa-a1d1-37cded5e23dc │ │Name │opentdf.io │ │Created At │Mon Jun 24 11:02:00 UTC 2024 │ │Updated At │Mon Jun 24 11:02:00 UTC 2024 │ └────────────────────────────────────────────────────────────────────────────┴─────────────────────────────────────────────────────────────────────────────────────────────────────┘ NOTE Use 'namespaces get --id=7650f02a-be00-4faa-a1d1-37cded5e23dc --json' to see all properties Create an Attribute​ Now that we have a namespace we can create a new attribute. An attribute is a way to define a classification for your data. It consists of two main parts: A definition which describes how an entities entitlements and resource attributes are compared. ANY_OF: The entity must have at least one of the values in the list. This is your typical OR operation.ALL_OF: The entity must have all of the values in the list. This is your typical AND operation.HIERARCHY: This is an ordered list of values. The entity must have an equal or greater value in the list. A list of values warning Attribute name and values are case insensitive. This means ROLE is equal to role. tip You can also create values at the same time when creating the definition. This is useful when you know the values you want to use. (e.g. --value admin --value developer --value guest) Create attribute definition​ otdfctl --profile platform-otdf-local policy attributes create --name role -s $NAMESPACE_ID -r ANY_OF SUCCESS Created attributes: bd02d7ab-564d-4b6c-95c4-3d4a8a259000 ┌────────────────────────────────────────────────────────────────────────────────┬─────────────────────────────────────────────────────────────────────────────────────────────────┐ │Property │Value │ ├────────────────────────────────────────────────────────────────────────────────┼─────────────────────────────────────────────────────────────────────────────────────────────────┤ │Name │role │ │Rule │ANY_OF │ │Values │[] │ │Namespace │opentdf.io │ │Created At │Mon Jun 24 11:09:39 UTC 2024 │ │Updated At │Mon Jun 24 11:09:39 UTC 2024 │ └────────────────────────────────────────────────────────────────────────────────┴─────────────────────────────────────────────────────────────────────────────────────────────────┘ NOTE Use 'attributes get --id=bd02d7ab-564d-4b6c-95c4-3d4a8a259000 --json' to see all properties Let's export the attribute id for later use. export ATTRIBUTE_ID=&lt;id&gt; Create attribute values​ # Create admin value otdfctl --profile platform-otdf-local policy attributes values create -a $ATTRIBUTE_ID --value admin SUCCESS Created values: 0fe7e8d0-a3ff-485f-ac24-a54d85904712 ┌──────────────────────────────────────────────────────────────────────────┬───────────────────────────────────────────────────────────────────────────────────────────────────────┐ │Property │Value │ ├──────────────────────────────────────────────────────────────────────────┼───────────────────────────────────────────────────────────────────────────────────────────────────────┤ │Id │0fe7e8d0-a3ff-485f-ac24-a54d85904712 │ │FQN │https://opentdf.io/attr/role/value/admin │ │Value │admin │ │Created At │Mon Jun 24 11:11:15 UTC 2024 │ │Updated At │Mon Jun 24 11:11:15 UTC 2024 │ └──────────────────────────────────────────────────────────────────────────┴───────────────────────────────────────────────────────────────────────────────────────────────────────┘ NOTE Use 'values get --id=0fe7e8d0-a3ff-485f-ac24-a54d85904712 --json' to see all properties Export the admin value id for later use. export ADMIN_VALUE_ID=&lt;id&gt; # Create developer value otdfctl --profile platform-otdf-local policy attributes values create -a $ATTRIBUTE_ID --value developer SUCCESS Created values: dbfcbe15-7392-4e35-9e1d-3d06918472be ┌────────────────────────────────────────────────────────────────────────┬─────────────────────────────────────────────────────────────────────────────────────────────────────────┐ │Property │Value │ ├────────────────────────────────────────────────────────────────────────┼─────────────────────────────────────────────────────────────────────────────────────────────────────────┤ │Id │dbfcbe15-7392-4e35-9e1d-3d06918472be │ │FQN │https://opentdf.io/attr/role/value/developer │ │Value │developer │ │Created At │Mon Jun 24 11:12:45 UTC 2024 │ │Updated At │Mon Jun 24 11:12:45 UTC 2024 │ └────────────────────────────────────────────────────────────────────────┴─────────────────────────────────────────────────────────────────────────────────────────────────────────┘ NOTE Use 'values get --id=dbfcbe15-7392-4e35-9e1d-3d06918472be --json' to see all properties Export the developer value id for later use. export DEVELOPER_VALUE_ID=&lt;id&gt; # Create guest value otdfctl --profile platform-otdf-local policy attributes values create -a $ATTRIBUTE_ID --value guest SUCCESS Created values: 654f0877-2c0b-4a62-a9c3-87ed42bf77ac ┌──────────────────────────────────────────────────────────────────────────┬───────────────────────────────────────────────────────────────────────────────────────────────────────┐ │Property │Value │ ├──────────────────────────────────────────────────────────────────────────┼───────────────────────────────────────────────────────────────────────────────────────────────────────┤ │Id │654f0877-2c0b-4a62-a9c3-87ed42bf77ac │ │FQN │https://opentdf.io/attr/role/value/guest │ │Value │guest │ │Created At │Mon Jun 24 11:14:22 UTC 2024 │ │Updated At │Mon Jun 24 11:14:22 UTC 2024 │ └──────────────────────────────────────────────────────────────────────────┴───────────────────────────────────────────────────────────────────────────────────────────────────────┘ NOTE Use 'values get --id=654f0877-2c0b-4a62-a9c3-87ed42bf77ac --json' to see all properties Export the guest value id for later use. export GUEST_VALUE_ID=&lt;id&gt; Get the attribute details​ Now that we have listed values for the attribute, we can get the details of the attribute. You should see the added values in the list now. otdfctl --profile platform-otdf-local policy attributes get --id=$ATTRIBUTE_ID SUCCESS Found attributes: bd02d7ab-564d-4b6c-95c4-3d4a8a259000 ┌────────────────────────────────────────────────────────────────────────────┬─────────────────────────────────────────────────────────────────────────────────────────────────────┐ │Property │Value │ ├────────────────────────────────────────────────────────────────────────────┼─────────────────────────────────────────────────────────────────────────────────────────────────────┤ │Id │bd02d7ab-564d-4b6c-95c4-3d4a8a259000 │ │Name │role │ │Rule │ANY_OF │ │Values │[admin, developer, guest] │ │Namespace │opentdf.io │ │Created At │Mon Jun 24 11:09:39 UTC 2024 │ │Updated At │Mon Jun 24 11:14:22 UTC 2024 │ └────────────────────────────────────────────────────────────────────────────┴─────────────────────────────────────────────────────────────────────────────────────────────────────┘ NOTE Use 'attributes get --id=bd02d7ab-564d-4b6c-95c4-3d4a8a259000 --json' to see all properties Create a Subject Mapping​ A subject mapping is a way to define how a user or entity is mapped to an attribute in the OpenTDF Platform. An attribute that is mapped to an entity is considered an entitlement. An entitlement is a way to define what tdf resources an entity can access. With subject mappings there is a sub-resource called subject condition sets. These are a set of conditions that must be met for the subject mapping to be applied. Create a Subject Condition Set​ Download the example subject condition set. You can use this file to create a new condition set. otdfctl --profile platform-otdf-local policy subject-condition-sets create -j &lt;path to file&gt;/subject_condition_set.json SUCCESS Created subject-condition-sets: 74bf521f-5a79-48fe-acb8-b4b63ee7950b ┌──────────────┬───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐ │Property │Value │ ├──────────────┼───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┤ │Id │74bf521f-5a79-48fe-acb8-b4b63ee7950b │ │SubjectSets │[{&quot;condition_groups&quot;:[{&quot;conditions&quot;:[{&quot;subject_external_selector_value&quot;:&quot;.clientId&quot;,&quot;operator&quot;:1,&quot;subject_external_values&quot;:[&quot;opentdf&quot;]}],&quot;boolean_operator&quot;:1}]}] │ │Created At │Mon Jun 24 11:33:28 UTC 2024 │ │Updated At │Mon Jun 24 11:33:28 UTC 2024 │ └──────────────┴───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘ NOTE Use 'subject-condition-sets get --id=74bf521f-5a79-48fe-acb8-b4b63ee7950b --json' to see all properties Let's export the subject condition set id for later use. export SUBJECT_CONDITION_SET_ID=&lt;id&gt; Create a Subject Mapping​ With the condition set created we can now create a new subject mapping that is tied to the subject condition set. otdfctl --profile platform-otdf-local policy subject-mappings create --action read --attribute-value-id $DEVELOPER_VALUE_ID --subject-condition-set-id $SUBJECT_CONDITION_SET_ID SUCCESS Created subject-mappings: 751054f8-14da-44c0-9341-5dab36b8256d ┌─────────────────────────┬────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐ │Property │Value │ ├─────────────────────────┼────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┤ │Id │751054f8-14da-44c0-9341-5dab36b8256d │ │Subject AttrVal: Id │dbfcbe15-7392-4e35-9e1d-3d06918472be │ │Actions │[{&quot;Value&quot;:{&quot;Standard&quot;:1}}] │ │Subject Condition Set: I…│74bf521f-5a79-48fe-acb8-b4b63ee7950b │ │Subject Condition Set │[{&quot;condition_groups&quot;:[{&quot;conditions&quot;:[{&quot;subject_external_selector_value&quot;:&quot;.clientId&quot;,&quot;operator&quot;:1,&quot;subject_external_values&quot;:[&quot;opentdf&quot;]}],&quot;boolean_opera…│ │Attribute Value Id │dbfcbe15-7392-4e35-9e1d-3d06918472be │ │Created At │Mon Jun 24 11:35:13 UTC 2024 │ │Updated At │Mon Jun 24 11:35:13 UTC 2024 │ └─────────────────────────┴────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘ NOTE Use 'subject-mappings get --id=751054f8-14da-44c0-9341-5dab36b8256d --json' to see all properties Let's export the subject mapping id for later use. export SUBJECT_MAPPING_ID=&lt;id&gt; Encrypt Some Data With TDF​ Now that we have a few basic resources in place we can show you how to control access to data using the OpenTDF Platform. Encrypt Data Without Attributes​ Within the otdfctl CLI there is basic functionality to interact with zTDF. Example zTDF encryption​ echo 'my first encrypted tdf' | otdfctl encrypt --profile platform-otdf-local -o example.tdf --tdf-type tdf3 Decrypt Data Without Attributes​ Because we didn't add any attributes to the data we encrypted, we should be able to decrypt the data without any issues. otdfctl decrypt --profile platform-otdf-local --tdf-type tdf3 example.tdf # Output my first encrypted tdf Encrypt Data With Attributes​ In this example we will encrypt the data with the attribute https://opentdf.io/attr/role/value/guest. First cleanup any existing tdf files from before. rm example.tdf Example zTDF encryption with attributes​ echo 'my first encrypted tdf' | otdfctl encrypt --profile platform-otdf-local -o example.tdf --tdf-type tdf3 --attr https://opentdf.io/attr/role/value/guest Decrypt Data With Attributes​ In this first example we will try to decrypt the data but it will fail because we shouldn't be assigned the entitlement of https://opentdf.io/attr/role/value/guest at this point. Example zTDF failed decryption​ otdfctl decrypt --profile platform-otdf-local --tdf-type tdf3 example.tdf # Output ERROR Failed to decrypt file: reader.WriteTo failed: doPayloadKeyUnwrap splitKey.rewrap failed: error making request to kas: error making rewrap request: rpc error: code = PermissionDenied desc = request error rpc error: code = PermissionDenied desc = forbidden What we have to do now is assign the entitlement of https://opentdf.io/attr/role/value/guest to the entity by creating a new subject mapping for the condition set we created earlier. Create a new subject mapping​ otdfctl --profile platform-otdf-local policy subject-mappings create --action read --attribute-value-id $GUEST_VALUE_ID --subject-condition-set-id $SUBJECT_CONDITION_SET_ID SUCCESS Created subject-mappings: f6bf9fc7-e23b-4276-9dfc-7a61f359edfd ┌─────────────────────────┬────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐ │Property │Value │ ├─────────────────────────┼────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┤ │Id │f6bf9fc7-e23b-4276-9dfc-7a61f359edfd │ │Subject AttrVal: Id │654f0877-2c0b-4a62-a9c3-87ed42bf77ac │ │Actions │[{&quot;Value&quot;:{&quot;Standard&quot;:1}}] │ │Subject Condition Set: I…│74bf521f-5a79-48fe-acb8-b4b63ee7950b │ │Subject Condition Set │[{&quot;condition_groups&quot;:[{&quot;conditions&quot;:[{&quot;subject_external_selector_value&quot;:&quot;.clientId&quot;,&quot;operator&quot;:1,&quot;subject_external_values&quot;:[&quot;opentdf&quot;]}],&quot;boolean_opera…│ │Attribute Value Id │654f0877-2c0b-4a62-a9c3-87ed42bf77ac │ │Created At │Mon Jun 24 13:28:22 UTC 2024 │ │Updated At │Mon Jun 24 13:28:22 UTC 2024 │ └─────────────────────────┴────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘ NOTE Use 'subject-mappings get --id=f6bf9fc7-e23b-4276-9dfc-7a61f359edfd --json' to see all properties Now that we have the subject mapping in place we should be able to decrypt the data. Example zTDF successful decryption​ otdfctl decrypt --profile platform-otdf-local --tdf-type tdf3 example.tdf # Output my first encrypted tdf Takeaways and Next Steps​ In this document you have learned how to create a namespace, attribute, subject mapping, and encrypt/decrypt data with the OpenTDF Platform.","keywords":"","version":"Next"},{"title":"AssignPublicKeyToAttribute","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/attributes/policy-attributes-attributes-service-assign-public-key-to-attribute","content":"AssignPublicKeyToAttribute POST /policy.attributes.AttributesService/AssignPublicKeyToAttribute AssignPublicKeyToAttribute Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"DeactivateAttribute","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/attributes/policy-attributes-attributes-service-deactivate-attribute","content":"DeactivateAttribute POST /policy.attributes.AttributesService/DeactivateAttribute DeactivateAttribute Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"CreateAttributeValue","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/attributes/policy-attributes-attributes-service-create-attribute-value","content":"CreateAttributeValue POST /policy.attributes.AttributesService/CreateAttributeValue CreateAttributeValue Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"DeactivateAttributeValue","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/attributes/policy-attributes-attributes-service-deactivate-attribute-value","content":"DeactivateAttributeValue POST /policy.attributes.AttributesService/DeactivateAttributeValue DeactivateAttributeValue Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"GetAttributeValue","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/attributes/policy-attributes-attributes-service-get-attribute-value","content":"GetAttributeValue POST /policy.attributes.AttributesService/GetAttributeValue --------------------------------------* Value RPCs​ Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"GetAttribute","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/attributes/policy-attributes-attributes-service-get-attribute","content":"GetAttribute POST /policy.attributes.AttributesService/GetAttribute GetAttribute Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"GetAttributeValuesByFqns","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/attributes/policy-attributes-attributes-service-get-attribute-values-by-fqns","content":"GetAttributeValuesByFqns GET /attributes/*/fqn GetAttributeValuesByFqns Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"ListAttributes","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/attributes/policy-attributes-attributes-service-list-attributes","content":"ListAttributes POST /policy.attributes.AttributesService/ListAttributes --------------------------------------* Attribute RPCs​ Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"ListAttributeValues","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/attributes/policy-attributes-attributes-service-list-attribute-values","content":"ListAttributeValues POST /policy.attributes.AttributesService/ListAttributeValues ListAttributeValues Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"RemovePublicKeyFromAttribute","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/attributes/policy-attributes-attributes-service-remove-public-key-from-attribute","content":"RemovePublicKeyFromAttribute POST /policy.attributes.AttributesService/RemovePublicKeyFromAttribute RemovePublicKeyFromAttribute Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"RemoveKeyAccessServerFromValue","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/attributes/policy-attributes-attributes-service-remove-key-access-server-from-value","content":"RemoveKeyAccessServerFromValue POST /policy.attributes.AttributesService/RemoveKeyAccessServerFromValue deprecated This endpoint has been deprecated and may be replaced or removed in future versions of the API. Deprecated: utilize RemovePublicKeyFromValue Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"RemovePublicKeyFromValue","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/attributes/policy-attributes-attributes-service-remove-public-key-from-value","content":"RemovePublicKeyFromValue POST /policy.attributes.AttributesService/RemovePublicKeyFromValue RemovePublicKeyFromValue Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"RemoveKeyAccessServerFromAttribute","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/attributes/policy-attributes-attributes-service-remove-key-access-server-from-attribute","content":"RemoveKeyAccessServerFromAttribute POST /policy.attributes.AttributesService/RemoveKeyAccessServerFromAttribute deprecated This endpoint has been deprecated and may be replaced or removed in future versions of the API. Deprecated: utilize RemovePublicKeyFromAttribute Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"UpdateAttribute","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/attributes/policy-attributes-attributes-service-update-attribute","content":"UpdateAttribute POST /policy.attributes.AttributesService/UpdateAttribute UpdateAttribute Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"policy.kasregistry","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/kasregistry/policy-kasregistry","content":"Version: v1 policy.kasregistry 📄️ CreateKeyAccessServer CreateKeyAccessServer 📄️ CreateKey KAS Key Management 📄️ DeleteKeyAccessServer DeleteKeyAccessServer 📄️ GetBaseKey Get Default kas keys 📄️ GetKeyAccessServer GetKeyAccessServer 📄️ GetKey Request to retrieve a key from the Key Access Service. 📄️ ListKeyAccessServerGrants Deprecated 📄️ ListKeyAccessServers ListKeyAccessServers 📄️ ListKeyMappings Request to list key mappings in the Key Access Service. 📄️ ListKeys Request to list keys in the Key Access Service. 📄️ RotateKey Request to rotate a key in the Key Access Service. 📄️ SetBaseKey Request to set the default a default kas key. 📄️ UpdateKeyAccessServer UpdateKeyAccessServer 📄️ UpdateKey Request to update a key in the Key Access Service. 📄️ policy.kasregistry","keywords":"","version":"Next"},{"title":"UpdateAttributeValue","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/attributes/policy-attributes-attributes-service-update-attribute-value","content":"UpdateAttributeValue POST /policy.attributes.AttributesService/UpdateAttributeValue UpdateAttributeValue Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"CreateKeyAccessServer","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/kasregistry/policy-kasregistry-key-access-server-registry-service-create-key-access-server","content":"CreateKeyAccessServer POST /policy.kasregistry.KeyAccessServerRegistryService/CreateKeyAccessServer CreateKeyAccessServer Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"DeleteKeyAccessServer","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/kasregistry/policy-kasregistry-key-access-server-registry-service-delete-key-access-server","content":"DeleteKeyAccessServer POST /policy.kasregistry.KeyAccessServerRegistryService/DeleteKeyAccessServer DeleteKeyAccessServer Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"GetKey","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/kasregistry/policy-kasregistry-key-access-server-registry-service-get-key","content":"GetKey POST /policy.kasregistry.KeyAccessServerRegistryService/GetKey Request to retrieve a key from the Key Access Service. Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"GetKeyAccessServer","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/kasregistry/policy-kasregistry-key-access-server-registry-service-get-key-access-server","content":"GetKeyAccessServer POST /policy.kasregistry.KeyAccessServerRegistryService/GetKeyAccessServer GetKeyAccessServer Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"CreateKey","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/kasregistry/policy-kasregistry-key-access-server-registry-service-create-key","content":"CreateKey POST /policy.kasregistry.KeyAccessServerRegistryService/CreateKey KAS Key Management Request to create a new key in the Key Access Service. Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"ListKeyAccessServerGrants","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/kasregistry/policy-kasregistry-key-access-server-registry-service-list-key-access-server-grants","content":"ListKeyAccessServerGrants POST /policy.kasregistry.KeyAccessServerRegistryService/ListKeyAccessServerGrants deprecated This endpoint has been deprecated and may be replaced or removed in future versions of the API. Deprecated Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"GetBaseKey","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/kasregistry/policy-kasregistry-key-access-server-registry-service-get-base-key","content":"GetBaseKey POST /policy.kasregistry.KeyAccessServerRegistryService/GetBaseKey Get Default kas keys Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"ListKeyAccessServers","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/kasregistry/policy-kasregistry-key-access-server-registry-service-list-key-access-servers","content":"ListKeyAccessServers GET /key-access-servers ListKeyAccessServers Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"SetBaseKey","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/kasregistry/policy-kasregistry-key-access-server-registry-service-set-base-key","content":"SetBaseKey POST /policy.kasregistry.KeyAccessServerRegistryService/SetBaseKey Request to set the default a default kas key. Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"ListKeys","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/kasregistry/policy-kasregistry-key-access-server-registry-service-list-keys","content":"ListKeys POST /policy.kasregistry.KeyAccessServerRegistryService/ListKeys Request to list keys in the Key Access Service. Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"RotateKey","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/kasregistry/policy-kasregistry-key-access-server-registry-service-rotate-key","content":"RotateKey POST /policy.kasregistry.KeyAccessServerRegistryService/RotateKey Request to rotate a key in the Key Access Service. Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"ListKeyMappings","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/kasregistry/policy-kasregistry-key-access-server-registry-service-list-key-mappings","content":"ListKeyMappings POST /policy.kasregistry.KeyAccessServerRegistryService/ListKeyMappings Request to list key mappings in the Key Access Service. Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"UpdateKey","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/kasregistry/policy-kasregistry-key-access-server-registry-service-update-key","content":"UpdateKey POST /policy.kasregistry.KeyAccessServerRegistryService/UpdateKey Request to update a key in the Key Access Service. Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"UpdateKeyAccessServer","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/kasregistry/policy-kasregistry-key-access-server-registry-service-update-key-access-server","content":"UpdateKeyAccessServer POST /policy.kasregistry.KeyAccessServerRegistryService/UpdateKeyAccessServer UpdateKeyAccessServer Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"policy.keymanagement","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/keymanagement/policy-keymanagement","content":"Version: v1 policy.keymanagement 📄️ CreateProviderConfig Key Management 📄️ DeleteProviderConfig DeleteProviderConfig 📄️ GetProviderConfig GetProviderConfig 📄️ ListProviderConfigs ListProviderConfigs 📄️ UpdateProviderConfig UpdateProviderConfig 📄️ policy.keymanagement","keywords":"","version":"Next"},{"title":"CreateProviderConfig","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/keymanagement/policy-keymanagement-key-management-service-create-provider-config","content":"CreateProviderConfig POST /policy.keymanagement.KeyManagementService/CreateProviderConfig Key Management Provider Management Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"DeleteProviderConfig","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/keymanagement/policy-keymanagement-key-management-service-delete-provider-config","content":"DeleteProviderConfig POST /policy.keymanagement.KeyManagementService/DeleteProviderConfig DeleteProviderConfig Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"ListProviderConfigs","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/keymanagement/policy-keymanagement-key-management-service-list-provider-configs","content":"ListProviderConfigs POST /policy.keymanagement.KeyManagementService/ListProviderConfigs ListProviderConfigs Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"UpdateProviderConfig","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/keymanagement/policy-keymanagement-key-management-service-update-provider-config","content":"UpdateProviderConfig POST /policy.keymanagement.KeyManagementService/UpdateProviderConfig UpdateProviderConfig Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"GetProviderConfig","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/keymanagement/policy-keymanagement-key-management-service-get-provider-config","content":"GetProviderConfig POST /policy.keymanagement.KeyManagementService/GetProviderConfig GetProviderConfig Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"policy.namespaces","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/namespaces/policy-namespaces","content":"Version: v1 policy.namespaces 📄️ AssignCertificateToNamespace Namespace &lt;&gt; Certificate RPCs 📄️ AssignKeyAccessServerToNamespace Deprecated: utilize AssignPublicKeyToNamespace 📄️ AssignPublicKeyToNamespace --------------------------------------* 📄️ CreateNamespace CreateNamespace 📄️ DeactivateNamespace DeactivateNamespace 📄️ GetNamespace GetNamespace 📄️ ListNamespaces ListNamespaces 📄️ RemoveCertificateFromNamespace RemoveCertificateFromNamespace 📄️ RemoveKeyAccessServerFromNamespace Deprecated: utilize RemovePublicKeyFromNamespace 📄️ RemovePublicKeyFromNamespace RemovePublicKeyFromNamespace 📄️ UpdateNamespace UpdateNamespace 📄️ policy.namespaces","keywords":"","version":"Next"},{"title":"AssignCertificateToNamespace","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/namespaces/policy-namespaces-namespace-service-assign-certificate-to-namespace","content":"AssignCertificateToNamespace POST /policy.namespaces.NamespaceService/AssignCertificateToNamespace Namespace &lt;&gt; Certificate RPCs Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"AssignKeyAccessServerToNamespace","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/namespaces/policy-namespaces-namespace-service-assign-key-access-server-to-namespace","content":"AssignKeyAccessServerToNamespace POST /policy.namespaces.NamespaceService/AssignKeyAccessServerToNamespace deprecated This endpoint has been deprecated and may be replaced or removed in future versions of the API. Deprecated: utilize AssignPublicKeyToNamespace Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"AssignPublicKeyToNamespace","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/namespaces/policy-namespaces-namespace-service-assign-public-key-to-namespace","content":"AssignPublicKeyToNamespace POST /policy.namespaces.NamespaceService/AssignPublicKeyToNamespace --------------------------------------* Namespace &lt;&gt; Key RPCs​ Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"CreateNamespace","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/namespaces/policy-namespaces-namespace-service-create-namespace","content":"CreateNamespace POST /policy.namespaces.NamespaceService/CreateNamespace CreateNamespace Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"DeactivateNamespace","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/namespaces/policy-namespaces-namespace-service-deactivate-namespace","content":"DeactivateNamespace POST /policy.namespaces.NamespaceService/DeactivateNamespace DeactivateNamespace Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"GetNamespace","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/namespaces/policy-namespaces-namespace-service-get-namespace","content":"GetNamespace POST /policy.namespaces.NamespaceService/GetNamespace GetNamespace Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"ListNamespaces","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/namespaces/policy-namespaces-namespace-service-list-namespaces","content":"ListNamespaces POST /policy.namespaces.NamespaceService/ListNamespaces ListNamespaces Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"RemoveCertificateFromNamespace","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/namespaces/policy-namespaces-namespace-service-remove-certificate-from-namespace","content":"RemoveCertificateFromNamespace POST /policy.namespaces.NamespaceService/RemoveCertificateFromNamespace RemoveCertificateFromNamespace Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"RemoveKeyAccessServerFromNamespace","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/namespaces/policy-namespaces-namespace-service-remove-key-access-server-from-namespace","content":"RemoveKeyAccessServerFromNamespace POST /policy.namespaces.NamespaceService/RemoveKeyAccessServerFromNamespace deprecated This endpoint has been deprecated and may be replaced or removed in future versions of the API. Deprecated: utilize RemovePublicKeyFromNamespace Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"UpdateNamespace","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/namespaces/policy-namespaces-namespace-service-update-namespace","content":"UpdateNamespace POST /policy.namespaces.NamespaceService/UpdateNamespace UpdateNamespace Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"RemovePublicKeyFromNamespace","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/namespaces/policy-namespaces-namespace-service-remove-public-key-from-namespace","content":"RemovePublicKeyFromNamespace POST /policy.namespaces.NamespaceService/RemovePublicKeyFromNamespace RemovePublicKeyFromNamespace Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"policy.obligations","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/obligations/policy-obligations","content":"Version: v1 policy.obligations 📄️ AddObligationTrigger AddObligationTrigger 📄️ CreateObligationValue CreateObligationValue 📄️ CreateObligation CreateObligation 📄️ DeleteObligationValue DeleteObligationValue 📄️ DeleteObligation DeleteObligation 📄️ GetObligationValue GetObligationValue 📄️ GetObligationValuesByFQNs GetObligationValuesByFQNs 📄️ GetObligation GetObligation 📄️ GetObligationsByFQNs GetObligationsByFQNs 📄️ ListObligationTriggers ListObligationTriggers 📄️ ListObligations ListObligations 📄️ RemoveObligationTrigger RemoveObligationTrigger 📄️ UpdateObligationValue UpdateObligationValue 📄️ UpdateObligation UpdateObligation 📄️ policy.obligations","keywords":"","version":"Next"},{"title":"CreateObligation","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/obligations/policy-obligations-service-create-obligation","content":"CreateObligation POST /policy.obligations.Service/CreateObligation CreateObligation Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"AddObligationTrigger","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/obligations/policy-obligations-service-add-obligation-trigger","content":"AddObligationTrigger POST /policy.obligations.Service/AddObligationTrigger AddObligationTrigger Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"CreateObligationValue","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/obligations/policy-obligations-service-create-obligation-value","content":"CreateObligationValue POST /policy.obligations.Service/CreateObligationValue CreateObligationValue Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"DeleteObligation","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/obligations/policy-obligations-service-delete-obligation","content":"DeleteObligation POST /policy.obligations.Service/DeleteObligation DeleteObligation Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"DeleteObligationValue","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/obligations/policy-obligations-service-delete-obligation-value","content":"DeleteObligationValue POST /policy.obligations.Service/DeleteObligationValue DeleteObligationValue Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"GetObligation","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/obligations/policy-obligations-service-get-obligation","content":"GetObligation POST /policy.obligations.Service/GetObligation GetObligation Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"GetObligationValue","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/obligations/policy-obligations-service-get-obligation-value","content":"GetObligationValue POST /policy.obligations.Service/GetObligationValue GetObligationValue Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"GetObligationValuesByFQNs","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/obligations/policy-obligations-service-get-obligation-values-by-fq-ns","content":"GetObligationValuesByFQNs POST /policy.obligations.Service/GetObligationValuesByFQNs GetObligationValuesByFQNs Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"ListObligationTriggers","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/obligations/policy-obligations-service-list-obligation-triggers","content":"ListObligationTriggers POST /policy.obligations.Service/ListObligationTriggers ListObligationTriggers Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"GetObligationsByFQNs","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/obligations/policy-obligations-service-get-obligations-by-fq-ns","content":"GetObligationsByFQNs POST /policy.obligations.Service/GetObligationsByFQNs GetObligationsByFQNs Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"ListObligations","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/obligations/policy-obligations-service-list-obligations","content":"ListObligations POST /policy.obligations.Service/ListObligations ListObligations Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"RemoveObligationTrigger","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/obligations/policy-obligations-service-remove-obligation-trigger","content":"RemoveObligationTrigger POST /policy.obligations.Service/RemoveObligationTrigger RemoveObligationTrigger Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"UpdateObligation","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/obligations/policy-obligations-service-update-obligation","content":"UpdateObligation POST /policy.obligations.Service/UpdateObligation UpdateObligation Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"UpdateObligationValue","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/obligations/policy-obligations-service-update-obligation-value","content":"UpdateObligationValue POST /policy.obligations.Service/UpdateObligationValue UpdateObligationValue Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"policy","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/policy","content":"Version: v1 policy 🗃️ actions 6 items 🗃️ attributes 20 items 🗃️ kasregistry 15 items 🗃️ keymanagement 6 items 🗃️ namespaces 12 items 🗃️ obligations 15 items 📄️ policy 🗃️ registeredresources 12 items 🗃️ resourcemapping 12 items 🗃️ subjectmapping 13 items 🗃️ unsafe 11 items","keywords":"","version":"Next"},{"title":"CreateRegisteredResource","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/registeredresources/policy-registeredresources-registered-resources-service-create-registered-resource","content":"CreateRegisteredResource POST /policy.registeredresources.RegisteredResourcesService/CreateRegisteredResource CreateRegisteredResource Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"policy.registeredresources","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/registeredresources/policy-registeredresources","content":"Version: v1 policy.registeredresources 📄️ CreateRegisteredResourceValue CreateRegisteredResourceValue 📄️ CreateRegisteredResource CreateRegisteredResource 📄️ DeleteRegisteredResourceValue DeleteRegisteredResourceValue 📄️ DeleteRegisteredResource DeleteRegisteredResource 📄️ GetRegisteredResourceValue GetRegisteredResourceValue 📄️ GetRegisteredResourceValuesByFQNs GetRegisteredResourceValuesByFQNs 📄️ GetRegisteredResource GetRegisteredResource 📄️ ListRegisteredResourceValues ListRegisteredResourceValues 📄️ ListRegisteredResources ListRegisteredResources 📄️ UpdateRegisteredResourceValue UpdateRegisteredResourceValue 📄️ UpdateRegisteredResource UpdateRegisteredResource 📄️ policy.registeredresources","keywords":"","version":"Next"},{"title":"CreateRegisteredResourceValue","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/registeredresources/policy-registeredresources-registered-resources-service-create-registered-resource-value","content":"CreateRegisteredResourceValue POST /policy.registeredresources.RegisteredResourcesService/CreateRegisteredResourceValue CreateRegisteredResourceValue Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"DeleteRegisteredResource","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/registeredresources/policy-registeredresources-registered-resources-service-delete-registered-resource","content":"DeleteRegisteredResource POST /policy.registeredresources.RegisteredResourcesService/DeleteRegisteredResource DeleteRegisteredResource Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"DeleteRegisteredResourceValue","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/registeredresources/policy-registeredresources-registered-resources-service-delete-registered-resource-value","content":"DeleteRegisteredResourceValue POST /policy.registeredresources.RegisteredResourcesService/DeleteRegisteredResourceValue DeleteRegisteredResourceValue Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"GetRegisteredResourceValue","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/registeredresources/policy-registeredresources-registered-resources-service-get-registered-resource-value","content":"GetRegisteredResourceValue POST /policy.registeredresources.RegisteredResourcesService/GetRegisteredResourceValue GetRegisteredResourceValue Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"GetRegisteredResource","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/registeredresources/policy-registeredresources-registered-resources-service-get-registered-resource","content":"GetRegisteredResource POST /policy.registeredresources.RegisteredResourcesService/GetRegisteredResource GetRegisteredResource Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"GetRegisteredResourceValuesByFQNs","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/registeredresources/policy-registeredresources-registered-resources-service-get-registered-resource-values-by-fq-ns","content":"GetRegisteredResourceValuesByFQNs POST /policy.registeredresources.RegisteredResourcesService/GetRegisteredResourceValuesByFQNs GetRegisteredResourceValuesByFQNs Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"ListRegisteredResourceValues","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/registeredresources/policy-registeredresources-registered-resources-service-list-registered-resource-values","content":"ListRegisteredResourceValues POST /policy.registeredresources.RegisteredResourcesService/ListRegisteredResourceValues ListRegisteredResourceValues Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"ListRegisteredResources","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/registeredresources/policy-registeredresources-registered-resources-service-list-registered-resources","content":"ListRegisteredResources POST /policy.registeredresources.RegisteredResourcesService/ListRegisteredResources ListRegisteredResources Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"UpdateRegisteredResource","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/registeredresources/policy-registeredresources-registered-resources-service-update-registered-resource","content":"UpdateRegisteredResource POST /policy.registeredresources.RegisteredResourcesService/UpdateRegisteredResource UpdateRegisteredResource Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"UpdateRegisteredResourceValue","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/registeredresources/policy-registeredresources-registered-resources-service-update-registered-resource-value","content":"UpdateRegisteredResourceValue POST /policy.registeredresources.RegisteredResourcesService/UpdateRegisteredResourceValue UpdateRegisteredResourceValue Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"policy.resourcemapping","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/resourcemapping/policy-resourcemapping","content":"Version: v1 policy.resourcemapping 📄️ CreateResourceMappingGroup CreateResourceMappingGroup 📄️ CreateResourceMapping CreateResourceMapping 📄️ DeleteResourceMappingGroup DeleteResourceMappingGroup 📄️ DeleteResourceMapping DeleteResourceMapping 📄️ GetResourceMappingGroup GetResourceMappingGroup 📄️ GetResourceMapping GetResourceMapping 📄️ ListResourceMappingGroups ListResourceMappingGroups 📄️ ListResourceMappingsByGroupFqns ListResourceMappingsByGroupFqns 📄️ ListResourceMappings ListResourceMappings 📄️ UpdateResourceMappingGroup UpdateResourceMappingGroup 📄️ UpdateResourceMapping UpdateResourceMapping 📄️ policy.resourcemapping","keywords":"","version":"Next"},{"title":"CreateResourceMapping","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/resourcemapping/policy-resourcemapping-resource-mapping-service-create-resource-mapping","content":"CreateResourceMapping POST /policy.resourcemapping.ResourceMappingService/CreateResourceMapping CreateResourceMapping Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"CreateResourceMappingGroup","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/resourcemapping/policy-resourcemapping-resource-mapping-service-create-resource-mapping-group","content":"CreateResourceMappingGroup POST /policy.resourcemapping.ResourceMappingService/CreateResourceMappingGroup CreateResourceMappingGroup Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"DeleteResourceMappingGroup","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/resourcemapping/policy-resourcemapping-resource-mapping-service-delete-resource-mapping-group","content":"DeleteResourceMappingGroup POST /policy.resourcemapping.ResourceMappingService/DeleteResourceMappingGroup DeleteResourceMappingGroup Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"DeleteResourceMapping","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/resourcemapping/policy-resourcemapping-resource-mapping-service-delete-resource-mapping","content":"DeleteResourceMapping POST /policy.resourcemapping.ResourceMappingService/DeleteResourceMapping DeleteResourceMapping Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"GetResourceMapping","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/resourcemapping/policy-resourcemapping-resource-mapping-service-get-resource-mapping","content":"GetResourceMapping POST /policy.resourcemapping.ResourceMappingService/GetResourceMapping GetResourceMapping Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"GetResourceMappingGroup","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/resourcemapping/policy-resourcemapping-resource-mapping-service-get-resource-mapping-group","content":"GetResourceMappingGroup POST /policy.resourcemapping.ResourceMappingService/GetResourceMappingGroup GetResourceMappingGroup Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"ListResourceMappingGroups","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/resourcemapping/policy-resourcemapping-resource-mapping-service-list-resource-mapping-groups","content":"ListResourceMappingGroups POST /policy.resourcemapping.ResourceMappingService/ListResourceMappingGroups ListResourceMappingGroups Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"ListResourceMappings","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/resourcemapping/policy-resourcemapping-resource-mapping-service-list-resource-mappings","content":"ListResourceMappings POST /policy.resourcemapping.ResourceMappingService/ListResourceMappings ListResourceMappings Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"ListResourceMappingsByGroupFqns","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/resourcemapping/policy-resourcemapping-resource-mapping-service-list-resource-mappings-by-group-fqns","content":"ListResourceMappingsByGroupFqns POST /policy.resourcemapping.ResourceMappingService/ListResourceMappingsByGroupFqns ListResourceMappingsByGroupFqns Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"UpdateResourceMapping","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/resourcemapping/policy-resourcemapping-resource-mapping-service-update-resource-mapping","content":"UpdateResourceMapping POST /policy.resourcemapping.ResourceMappingService/UpdateResourceMapping UpdateResourceMapping Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"UpdateResourceMappingGroup","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/resourcemapping/policy-resourcemapping-resource-mapping-service-update-resource-mapping-group","content":"UpdateResourceMappingGroup POST /policy.resourcemapping.ResourceMappingService/UpdateResourceMappingGroup UpdateResourceMappingGroup Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"policy.subjectmapping","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/subjectmapping/policy-subjectmapping","content":"Version: v1 policy.subjectmapping 📄️ CreateSubjectConditionSet CreateSubjectConditionSet 📄️ CreateSubjectMapping CreateSubjectMapping 📄️ DeleteAllUnmappedSubjectConditionSets DeleteAllUnmappedSubjectConditionSets 📄️ DeleteSubjectConditionSet DeleteSubjectConditionSet 📄️ DeleteSubjectMapping DeleteSubjectMapping 📄️ GetSubjectConditionSet GetSubjectConditionSet 📄️ GetSubjectMapping GetSubjectMapping 📄️ ListSubjectConditionSets ListSubjectConditionSets 📄️ ListSubjectMappings ListSubjectMappings 📄️ MatchSubjectMappings Find matching Subject Mappings for a given Subject 📄️ UpdateSubjectConditionSet UpdateSubjectConditionSet 📄️ UpdateSubjectMapping UpdateSubjectMapping 📄️ policy.subjectmapping","keywords":"","version":"Next"},{"title":"CreateSubjectMapping","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/subjectmapping/policy-subjectmapping-subject-mapping-service-create-subject-mapping","content":"CreateSubjectMapping POST /policy.subjectmapping.SubjectMappingService/CreateSubjectMapping CreateSubjectMapping Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"CreateSubjectConditionSet","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/subjectmapping/policy-subjectmapping-subject-mapping-service-create-subject-condition-set","content":"CreateSubjectConditionSet POST /policy.subjectmapping.SubjectMappingService/CreateSubjectConditionSet CreateSubjectConditionSet Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"DeleteAllUnmappedSubjectConditionSets","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/subjectmapping/policy-subjectmapping-subject-mapping-service-delete-all-unmapped-subject-condition-sets","content":"DeleteAllUnmappedSubjectConditionSets POST /policy.subjectmapping.SubjectMappingService/DeleteAllUnmappedSubjectConditionSets DeleteAllUnmappedSubjectConditionSets Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"DeleteSubjectConditionSet","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/subjectmapping/policy-subjectmapping-subject-mapping-service-delete-subject-condition-set","content":"DeleteSubjectConditionSet POST /policy.subjectmapping.SubjectMappingService/DeleteSubjectConditionSet DeleteSubjectConditionSet Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"DeleteSubjectMapping","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/subjectmapping/policy-subjectmapping-subject-mapping-service-delete-subject-mapping","content":"DeleteSubjectMapping POST /policy.subjectmapping.SubjectMappingService/DeleteSubjectMapping DeleteSubjectMapping Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"GetSubjectConditionSet","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/subjectmapping/policy-subjectmapping-subject-mapping-service-get-subject-condition-set","content":"GetSubjectConditionSet POST /policy.subjectmapping.SubjectMappingService/GetSubjectConditionSet GetSubjectConditionSet Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"GetSubjectMapping","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/subjectmapping/policy-subjectmapping-subject-mapping-service-get-subject-mapping","content":"GetSubjectMapping POST /policy.subjectmapping.SubjectMappingService/GetSubjectMapping GetSubjectMapping Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"ListSubjectConditionSets","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/subjectmapping/policy-subjectmapping-subject-mapping-service-list-subject-condition-sets","content":"ListSubjectConditionSets POST /policy.subjectmapping.SubjectMappingService/ListSubjectConditionSets ListSubjectConditionSets Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"ListSubjectMappings","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/subjectmapping/policy-subjectmapping-subject-mapping-service-list-subject-mappings","content":"ListSubjectMappings POST /policy.subjectmapping.SubjectMappingService/ListSubjectMappings ListSubjectMappings Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"UpdateSubjectConditionSet","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/subjectmapping/policy-subjectmapping-subject-mapping-service-update-subject-condition-set","content":"UpdateSubjectConditionSet POST /policy.subjectmapping.SubjectMappingService/UpdateSubjectConditionSet UpdateSubjectConditionSet Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"UpdateSubjectMapping","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/subjectmapping/policy-subjectmapping-subject-mapping-service-update-subject-mapping","content":"UpdateSubjectMapping POST /policy.subjectmapping.SubjectMappingService/UpdateSubjectMapping UpdateSubjectMapping Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"MatchSubjectMappings","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/subjectmapping/policy-subjectmapping-subject-mapping-service-match-subject-mappings","content":"MatchSubjectMappings POST /policy.subjectmapping.SubjectMappingService/MatchSubjectMappings Find matching Subject Mappings for a given Subject Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"policy.unsafe","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/unsafe/policy-unsafe","content":"Version: v1 policy.unsafe 📄️ UnsafeDeleteAttributeValue UnsafeDeleteAttributeValue 📄️ UnsafeDeleteAttribute UnsafeDeleteAttribute 📄️ UnsafeDeleteKasKey --------------------------------------* 📄️ UnsafeDeleteNamespace UnsafeDeleteNamespace 📄️ UnsafeReactivateAttributeValue UnsafeReactivateAttributeValue 📄️ UnsafeReactivateAttribute UnsafeReactivateAttribute 📄️ UnsafeReactivateNamespace UnsafeReactivateNamespace 📄️ UnsafeUpdateAttributeValue --------------------------------------* 📄️ UnsafeUpdateAttribute --------------------------------------* 📄️ UnsafeUpdateNamespace --------------------------------------* 📄️ policy.unsafe","keywords":"","version":"Next"},{"title":"UnsafeDeleteAttribute","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/unsafe/policy-unsafe-unsafe-service-unsafe-delete-attribute","content":"UnsafeDeleteAttribute POST /policy.unsafe.UnsafeService/UnsafeDeleteAttribute UnsafeDeleteAttribute Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"UnsafeDeleteNamespace","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/unsafe/policy-unsafe-unsafe-service-unsafe-delete-namespace","content":"UnsafeDeleteNamespace POST /policy.unsafe.UnsafeService/UnsafeDeleteNamespace UnsafeDeleteNamespace Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"UnsafeDeleteAttributeValue","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/unsafe/policy-unsafe-unsafe-service-unsafe-delete-attribute-value","content":"UnsafeDeleteAttributeValue POST /policy.unsafe.UnsafeService/UnsafeDeleteAttributeValue UnsafeDeleteAttributeValue Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"UnsafeDeleteKasKey","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/unsafe/policy-unsafe-unsafe-service-unsafe-delete-kas-key","content":"UnsafeDeleteKasKey POST /policy.unsafe.UnsafeService/UnsafeDeleteKasKey --------------------------------------* Kas Key RPCs​ Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"UnsafeReactivateAttribute","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/unsafe/policy-unsafe-unsafe-service-unsafe-reactivate-attribute","content":"UnsafeReactivateAttribute POST /policy.unsafe.UnsafeService/UnsafeReactivateAttribute UnsafeReactivateAttribute Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"UnsafeReactivateAttributeValue","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/unsafe/policy-unsafe-unsafe-service-unsafe-reactivate-attribute-value","content":"UnsafeReactivateAttributeValue POST /policy.unsafe.UnsafeService/UnsafeReactivateAttributeValue UnsafeReactivateAttributeValue Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"UnsafeReactivateNamespace","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/unsafe/policy-unsafe-unsafe-service-unsafe-reactivate-namespace","content":"UnsafeReactivateNamespace POST /policy.unsafe.UnsafeService/UnsafeReactivateNamespace UnsafeReactivateNamespace Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"UnsafeUpdateAttribute","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/unsafe/policy-unsafe-unsafe-service-unsafe-update-attribute","content":"UnsafeUpdateAttribute POST /policy.unsafe.UnsafeService/UnsafeUpdateAttribute --------------------------------------* Attribute RPCs​ Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"UnsafeUpdateAttributeValue","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/unsafe/policy-unsafe-unsafe-service-unsafe-update-attribute-value","content":"UnsafeUpdateAttributeValue POST /policy.unsafe.UnsafeService/UnsafeUpdateAttributeValue --------------------------------------* Value RPCs​ Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"UnsafeUpdateNamespace","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/policy/unsafe/policy-unsafe-unsafe-service-unsafe-update-namespace","content":"UnsafeUpdateNamespace POST /policy.unsafe.UnsafeService/UnsafeUpdateNamespace --------------------------------------* Namespace RPCs​ Request​ Responses​ 200default Success","keywords":"","version":"Next"},{"title":"wellknownconfiguration","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/wellknownconfiguration/wellknownconfiguration","content":"Version: v1 wellknownconfiguration 📄️ GetWellKnownConfiguration GetWellKnownConfiguration 📄️ wellknownconfiguration","keywords":"","version":"Next"},{"title":"GetWellKnownConfiguration","type":0,"sectionRef":"#","url":"/pr-172/OpenAPI-clients/wellknownconfiguration/wellknownconfiguration-well-known-service-get-well-known-configuration","content":"GetWellKnownConfiguration GET /.well-known/opentdf-configuration GetWellKnownConfiguration Responses​ 200default Success","keywords":"","version":"Next"},{"title":"Release Notes","type":0,"sectionRef":"#","url":"/pr-172/release-notes","content":"Release Notes PlatformCLI (otdfctl)Go SDKJava SDKWeb SDK Loading releases...","keywords":"","version":"Next"},{"title":"Overview","type":0,"sectionRef":"#","url":"/pr-172/sdks/overview","content":"Overview OpenTDF supports native SDKs in the Go, Java and JavaScript languages. Please refer to the SDK Feature Matrix in the Appendix for the supported features in each SDK. Repositories​ GoJavaJavaScript Install​ GoJavaJavaScript go get github.com/opentdf/platform/sdk@latest ","keywords":"","version":"Next"},{"title":"Getting Started","type":0,"sectionRef":"#","url":"/pr-172/quickstart","content":"Getting Started This guide will walk you through encrypting and decrypting data using OpenTDF tools. We'll help you set up a sandbox OpenTDF platform locally with attribute based access controls (ABAC) to demonstrate the basic concepts of OpenTDF. The Scenario​ Let's follow a real-world example: Jen Moneybanks, CFO at a company, creates a highly sensitive financial strategy document for next year. Preston Price (an accountant) and Jack Vascript (an engineer) both try to access it, but are denied. Recognizing the need for wider collaboration, Jen creates a derivative version that removes executive-only details but keeps relevant financial information. Now Preston can access the derivative document, while Jack remains locked out. We'll use OpenTDF to implement this exact scenario with: Departments: finance, engineeringClearance levels: executive, standardTwo documents: Executive strategy (requires executive clearance) and derivative report (requires finance department access) Pre-requisites​ macOS, Linux, or Windows (WSL2)Docker Desktop or Docker Engine installed and running4GB+ RAM available10GB+ free disk space Getting the Platform Running​ The OpenTDF Platform is the core service that enforces attribute-based access control for encrypted data. It handles: Defining and managing attributes (like department, clearance level)Enforcing access policies when data is encrypted or decryptedManaging cryptographic keys through the Key Access Server (KAS)Validating user entitlements before granting access to data We'll run a local instance using Docker. This includes the Platform, Keycloak (for user authentication), and PostgreSQL (for storing attributes and policies). warning Not for production use. Run Pre-flight Check (Optional)​ Verify your system meets the requirements: curl -fsSL https://opentdf.io/check.sh | bash Or download and run locally: curl -fsSL https://docs.opentdf.io/quickstart/check.sh -o check.sh chmod +x check.sh ./check.sh Install OpenTDF​ Run the automated installer: curl -fsSL https://opentdf.io/install.sh | bash Or download and run locally: curl -fsSL https://docs.opentdf.io/quickstart/install.sh -o install.sh chmod +x install.sh ./install.sh What this does: Downloads and installs the otdfctl CLIVerifies Docker is runningAdds entries to /etc/hosts (requires sudo)Downloads and starts all services (Platform, Keycloak, PostgreSQL, Caddy)Imports SSL certificates (requires sudo)Takes 3-5 minutes on first run You'll be prompted for your password twice: To add entries to /etc/hostsTo import the SSL certificate Add otdfctl to Your PATH (Optional)​ Choose one option: Option A: Add to shell profile (recommended) echo 'export PATH=&quot;$HOME/.opentdf/bin:$PATH&quot;' &gt;&gt; ~/.bashrc source ~/.bashrc Or for zsh: echo 'export PATH=&quot;$HOME/.opentdf/bin:$PATH&quot;' &gt;&gt; ~/.zshrc source ~/.zshrc Option B: Create system-wide symlink sudo ln -sf ~/.opentdf/bin/otdfctl /usr/local/bin/otdfctl Option C: Use full path (no setup needed) ~/.opentdf/bin/otdfctl --version Verify Installation​ otdfctl --version Should display: otdfctl version 0.28.0 ... You can verify that the platform and keycloak are running at the following locations https://platform.opentdf.local:8443/healthzhttps://keycloak.opentdf.local:9443/ Create an otdfctl Profile​ A profile stores your platform connection details: otdfctl profile create platform-otdf-local https://platform.opentdf.local:8443 Authenticate​ Login using the pre-configured test credentials: otdfctl --profile platform-otdf-local auth client-credentials opentdf secret Credentials: Client ID: opentdfClient Secret: secret These are test credentials provisioned automatically during installation. To verify authentication, list namespaces to confirm you're connected: otdfctl --profile platform-otdf-local policy attributes namespaces list Should return an empty list [] (no namespaces created yet). Encrypt and Decrypt with the CLI​ Let's start with a simple encryption example: echo 'my first encrypted tdf' | otdfctl encrypt --profile platform-otdf-local -o example.tdf This creates an encrypted file called example.tdf. Now decrypt it: otdfctl decrypt --profile platform-otdf-local example.tdf # Output my first encrypted tdf That's it! You're encrypting and decrypting data. But encryption alone isn't very useful without access controls, so let's get into the details of our scenario. Create A Namespace​ A namespace is how you organize your attributes within the platform. Think of it as your organization's domain - for our scenario, this will be the company where Jen, Preston, and Jack work. Let's check if there are any existing namespaces: otdfctl --profile platform-otdf-local policy attributes namespaces list SUCCESS Found namespaces list ┌─────────────────────────┬───────────────────────────┬─────────────────────────────┬────────────────────────────┬────────────────────────────────┬────────────────────────────────┐ │Id │Name │Active │Labels │Created At │Updated At │ ├─────────────────────────┼───────────────────────────┼─────────────────────────────┼────────────────────────────┼────────────────────────────────┼────────────────────────────────┤ └─────────────────────────┴───────────────────────────┴─────────────────────────────┴────────────────────────────┴────────────────────────────────┴────────────────────────────────┘ NOTE Use 'namespaces get --id=&lt;id&gt; --json' to see all properties Create a new namespace​ We'll create a namespace representing our company domain: otdfctl --profile platform-otdf-local policy attributes namespaces create --name opentdf.io SUCCESS Created namespaces: 7650f02a-be00-4faa-a1d1-37cded5e23dc ┌────────────────────────────────────────────────────────────────────────────┬─────────────────────────────────────────────────────────────────────────────────────────────────────┐ │Property │Value │ ├────────────────────────────────────────────────────────────────────────────┼─────────────────────────────────────────────────────────────────────────────────────────────────────┤ │Name │opentdf.io │ │Id │7650f02a-be00-4faa-a1d1-37cded5e23dc │ │Created At │Mon Jun 24 11:02:00 UTC 2024 │ │Updated At │Mon Jun 24 11:02:00 UTC 2024 │ └────────────────────────────────────────────────────────────────────────────┴─────────────────────────────────────────────────────────────────────────────────────────────────────┘ NOTE Use 'namespaces get --id=7650f02a-be00-4faa-a1d1-37cded5e23dc --json' to see all properties List the namespaces​ With that namespace created we should be able to see it in the list of namespaces as well as get the details of the namespace. otdfctl --profile platform-otdf-local policy attributes namespaces list SUCCESS Found namespaces list ┌──────────────────────────────────────────────┬────────────────────┬────────────────┬────────────────┬──────────────────────────────────────┬─────────────────────────────────────┐ │Id │Name │Active │Labels │Created At │Updated At │ ├──────────────────────────────────────────────┼────────────────────┼────────────────┼────────────────┼──────────────────────────────────────┼─────────────────────────────────────┤ │7650f02a-be00-4faa-a1d1-37cded5e23dc │opentdf.io │true │[] │Mon Jun 24 11:02:00 UTC 2024 │Mon Jun 24 11:02:00 UTC 2024 │ └──────────────────────────────────────────────┴────────────────────┴────────────────┴────────────────┴──────────────────────────────────────┴─────────────────────────────────────┘ NOTE Use 'namespaces get --id=&lt;id&gt; --json' to see all properties Let's export the namespace id for later use. export NAMESPACE_ID=&lt;id&gt; Get the details of the namespace​ otdfctl --profile platform-otdf-local policy attributes namespaces get --id=$NAMESPACE_ID SUCCESS Found namespaces: 7650f02a-be00-4faa-a1d1-37cded5e23dc ┌────────────────────────────────────────────────────────────────────────────┬─────────────────────────────────────────────────────────────────────────────────────────────────────┐ │Property │Value │ ├────────────────────────────────────────────────────────────────────────────┼─────────────────────────────────────────────────────────────────────────────────────────────────────┤ │Id │7650f02a-be00-4faa-a1d1-37cded5e23dc │ │Name │opentdf.io │ │Created At │Mon Jun 24 11:02:00 UTC 2024 │ │Updated At │Mon Jun 24 11:02:00 UTC 2024 │ └────────────────────────────────────────────────────────────────────────────┴─────────────────────────────────────────────────────────────────────────────────────────────────────┘ NOTE Use 'namespaces get --id=7650f02a-be00-4faa-a1d1-37cded5e23dc --json' to see all properties Create Attributes​ An attribute defines how to classify data. For our scenario, we need two types of attributes: Department - Which department can access the data (finance, engineering)Clearance - What clearance level is required (executive, standard) Each attribute has: A definition - Describes how entitlements and resource attributes are compared: ANY_OF: Entity needs at least one value (OR operation) - perfect for departmentsALL_OF: Entity needs all values (AND operation) - useful for combined requirementsHIERARCHY: Ordered list where higher values grant lower access - perfect for clearance levels A list of values - The specific options (e.g., finance, engineering, executive, standard) tip You can create values when creating the definition: --value finance --value engineering Create Department Attribute​ First, let's create an attribute for departments. We'll use ANY_OF since a person typically belongs to one department: otdfctl --profile platform-otdf-local policy attributes create --name department -s $NAMESPACE_ID -r ANY_OF SUCCESS Created attributes: bd02d7ab-564d-4b6c-95c4-3d4a8a259000 ┌────────────────────────────────────────────────────────────────────────────────┬─────────────────────────────────────────────────────────────────────────────────────────────────┐ │Property │Value │ ├────────────────────────────────────────────────────────────────────────────────┼─────────────────────────────────────────────────────────────────────────────────────────────────┤ │Name │department │ │Rule │ANY_OF │ │Values │[] │ │Namespace │opentdf.io │ │Created At │Mon Jun 24 11:09:39 UTC 2024 │ │Updated At │Mon Jun 24 11:09:39 UTC 2024 │ └────────────────────────────────────────────────────────────────────────────────┴─────────────────────────────────────────────────────────────────────────────────────────────────┘ NOTE Use 'attributes get --id=bd02d7ab-564d-4b6c-95c4-3d4a8a259000 --json' to see all properties Save the department attribute ID: export DEPT_ATTRIBUTE_ID=&lt;id&gt; Add Department Values​ Now add the specific departments. Preston works in finance, and Jack works in engineering: # Finance department (Preston's department) otdfctl --profile platform-otdf-local policy attributes values create -a $DEPT_ATTRIBUTE_ID --value finance SUCCESS Created values: 0fe7e8d0-a3ff-485f-ac24-a54d85904712 ┌──────────────────────────────────────────────────────────────────────────┬───────────────────────────────────────────────────────────────────────────────────────────────────────┐ │Property │Value │ ├──────────────────────────────────────────────────────────────────────────┼───────────────────────────────────────────────────────────────────────────────────────────────────────┤ │Id │0fe7e8d0-a3ff-485f-ac24-a54d85904712 │ │FQN │https://opentdf.io/attr/department/value/finance │ │Value │finance │ │Created At │Mon Jun 24 11:11:15 UTC 2024 │ │Updated At │Mon Jun 24 11:11:15 UTC 2024 │ └──────────────────────────────────────────────────────────────────────────┴───────────────────────────────────────────────────────────────────────────────────────────────────────┘ NOTE Use 'values get --id=0fe7e8d0-a3ff-485f-ac24-a54d85904712 --json' to see all properties Save the finance value ID: export FINANCE_VALUE_ID=&lt;id&gt; # Engineering department (Jack's department) otdfctl --profile platform-otdf-local policy attributes values create -a $DEPT_ATTRIBUTE_ID --value engineering SUCCESS Created values: dbfcbe15-7392-4e35-9e1d-3d06918472be ┌────────────────────────────────────────────────────────────────────────┬─────────────────────────────────────────────────────────────────────────────────────────────────────────┐ │Property │Value │ ├────────────────────────────────────────────────────────────────────────┼─────────────────────────────────────────────────────────────────────────────────────────────────────────┤ │Id │dbfcbe15-7392-4e35-9e1d-3d06918472be │ │FQN │https://opentdf.io/attr/department/value/engineering │ │Value │engineering │ │Created At │Mon Jun 24 11:12:45 UTC 2024 │ │Updated At │Mon Jun 24 11:12:45 UTC 2024 │ └────────────────────────────────────────────────────────────────────────┴─────────────────────────────────────────────────────────────────────────────────────────────────────────┘ NOTE Use 'values get --id=dbfcbe15-7392-4e35-9e1d-3d06918472be --json' to see all properties Save the engineering value ID: export ENGINEERING_VALUE_ID=&lt;id&gt; Create Clearance Attribute​ Now create a clearance attribute using HIERARCHY rule. This means someone with executive clearance automatically has standard clearance too: otdfctl --profile platform-otdf-local policy attributes create --name clearance -s $NAMESPACE_ID -r HIERARCHY SUCCESS Created attributes: af23c7bd-987d-4c6b-85f4-2a8d4a127abc ┌────────────────────────────────────────────────────────────────────────────────┬─────────────────────────────────────────────────────────────────────────────────────────────────┐ │Property │Value │ ├────────────────────────────────────────────────────────────────────────────────┼─────────────────────────────────────────────────────────────────────────────────────────────────┤ │Name │clearance │ │Rule │HIERARCHY │ │Values │[] │ │Namespace │opentdf.io │ │Created At │Mon Jun 24 11:09:39 UTC 2024 │ │Updated At │Mon Jun 24 11:09:39 UTC 2024 │ └────────────────────────────────────────────────────────────────────────────────┴─────────────────────────────────────────────────────────────────────────────────────────────────┘ NOTE Use 'attributes get --id=af23c7bd-987d-4c6b-85f4-2a8d4a127abc --json' to see all properties Save the clearance attribute ID: export CLEARANCE_ATTRIBUTE_ID=&lt;id&gt; Add Clearance Values​ Add clearance levels. Order matters for HIERARCHY - list them from highest to lowest: # Executive clearance (Jen has this - highest level) otdfctl --profile platform-otdf-local policy attributes values create -a $CLEARANCE_ATTRIBUTE_ID --value executive SUCCESS Created values: 654f0877-2c0b-4a62-a9c3-87ed42bf77ac ┌──────────────────────────────────────────────────────────────────────────┬───────────────────────────────────────────────────────────────────────────────────────────────────────┐ │Property │Value │ ├──────────────────────────────────────────────────────────────────────────┼───────────────────────────────────────────────────────────────────────────────────────────────────────┤ │Id │654f0877-2c0b-4a62-a9c3-87ed42bf77ac │ │FQN │https://opentdf.io/attr/clearance/value/executive │ │Value │executive │ │Created At │Mon Jun 24 11:14:22 UTC 2024 │ │Updated At │Mon Jun 24 11:14:22 UTC 2024 │ └──────────────────────────────────────────────────────────────────────────┴───────────────────────────────────────────────────────────────────────────────────────────────────────┘ NOTE Use 'values get --id=654f0877-2c0b-4a62-a9c3-87ed42bf77ac --json' to see all properties Save the executive clearance value ID: export EXECUTIVE_VALUE_ID=&lt;id&gt; # Standard clearance (Preston and Jack have this) otdfctl --profile platform-otdf-local policy attributes values create -a $CLEARANCE_ATTRIBUTE_ID --value standard SUCCESS Created values: 789a1234-3c0b-4a62-b8d4-98fe53cf88bd ┌──────────────────────────────────────────────────────────────────────────┬───────────────────────────────────────────────────────────────────────────────────────────────────────┐ │Property │Value │ ├──────────────────────────────────────────────────────────────────────────┼───────────────────────────────────────────────────────────────────────────────────────────────────────┤ │Id │789a1234-3c0b-4a62-b8d4-98fe53cf88bd │ │FQN │https://opentdf.io/attr/clearance/value/standard │ │Value │standard │ │Created At │Mon Jun 24 11:14:22 UTC 2024 │ │Updated At │Mon Jun 24 11:14:22 UTC 2024 │ └──────────────────────────────────────────────────────────────────────────┴───────────────────────────────────────────────────────────────────────────────────────────────────────┘ NOTE Use 'values get --id=789a1234-3c0b-4a62-b8d4-98fe53cf88bd --json' to see all properties Save the standard clearance value ID: export STANDARD_VALUE_ID=&lt;id&gt; Review Your Attributes​ Now you have two attributes with values. Let's verify the department attribute: otdfctl --profile platform-otdf-local policy attributes get --id=$DEPT_ATTRIBUTE_ID SUCCESS Found attributes: bd02d7ab-564d-4b6c-95c4-3d4a8a259000 ┌────────────────────────────────────────────────────────────────────────────┬─────────────────────────────────────────────────────────────────────────────────────────────────────┐ │Property │Value │ ├────────────────────────────────────────────────────────────────────────────┼─────────────────────────────────────────────────────────────────────────────────────────────────────┤ │Id │bd02d7ab-564d-4b6c-95c4-3d4a8a259000 │ │Name │department │ │Rule │ANY_OF │ │Values │[finance, engineering] │ │Namespace │opentdf.io │ │Created At │Mon Jun 24 11:09:39 UTC 2024 │ │Updated At │Mon Jun 24 11:14:22 UTC 2024 │ └────────────────────────────────────────────────────────────────────────────┴─────────────────────────────────────────────────────────────────────────────────────────────────────┘ NOTE Use 'attributes get --id=bd02d7ab-564d-4b6c-95c4-3d4a8a259000 --json' to see all properties Create Subject Mappings​ A subject mapping connects users to attributes, granting them entitlements. This is where we define: Jen gets clearance/executive (which also grants clearance/standard due to hierarchy)Preston gets department/finance and clearance/standardJack gets department/engineering and clearance/standard First, we need a subject condition set - this defines WHO qualifies for the entitlement based on their identity properties (like client ID, email, or group membership). Create Subject Condition Sets​ For this tutorial, we'll simulate our three users by creating condition sets that match different criteria. Download the example subject condition set as a template. In a real deployment, you'd match users by email, group membership, or other identity properties from your identity provider (like Keycloak). For now, we'll use the default client ID. otdfctl --profile platform-otdf-local policy subject-condition-sets create -j &lt;path to file&gt;/subject_condition_set.json SUCCESS Created subject-condition-sets: 74bf521f-5a79-48fe-acb8-b4b63ee7950b ┌──────────────┬───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐ │Property │Value │ ├──────────────┼───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┤ │Id │74bf521f-5a79-48fe-acb8-b4b63ee7950b │ │SubjectSets │[{&quot;condition_groups&quot;:[{&quot;conditions&quot;:[{&quot;subject_external_selector_value&quot;:&quot;.clientId&quot;,&quot;operator&quot;:1,&quot;subject_external_values&quot;:[&quot;opentdf&quot;]}],&quot;boolean_operator&quot;:1}]}] │ │Created At │Mon Jun 24 11:33:28 UTC 2024 │ │Updated At │Mon Jun 24 11:33:28 UTC 2024 │ └──────────────┴───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘ NOTE Use 'subject-condition-sets get --id=74bf521f-5a79-48fe-acb8-b4b63ee7950b --json' to see all properties Save the condition set ID - we'll use this to represent all three users in our demo: export SUBJECT_CONDITION_SET_ID=&lt;id&gt; Encrypt Jen's Executive Document​ Before granting any permissions, let's create Jen's executive strategy document and see what happens when someone without proper clearance tries to access it. Create the Executive Strategy Document​ Jen creates her highly sensitive executive strategy document. This requires executive clearance: echo 'Executive Financial Strategy 2026: Confidential merger plans and Board-level decisions' | otdfctl encrypt --profile platform-otdf-local -o executive-strategy.tdf --attr https://opentdf.io/attr/clearance/value/executive Try to Decrypt Without Permission (Will Fail)​ Right now, we haven't granted ourselves any permissions. Let's try to decrypt this executive document: otdfctl decrypt --profile platform-otdf-local executive-strategy.tdf You'll see an error like this: Error: rpc error: code = PermissionDenied desc = Access denied: insufficient permissions This is access control working! The platform checked our entitlements, found that we don't have the clearance/executive attribute, and denied access. Grant Jen Executive Clearance​ Now let's grant executive clearance to represent Jen's access level: otdfctl --profile platform-otdf-local policy subject-mappings create --action read --attribute-value-id $EXECUTIVE_VALUE_ID --subject-condition-set-id $SUBJECT_CONDITION_SET_ID SUCCESS Created subject-mappings: 751054f8-14da-44c0-9341-5dab36b8256d ┌─────────────────────────┬────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐ │Property │Value │ ├─────────────────────────┼────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┤ │Id │751054f8-14da-44c0-9341-5dab36b8256d │ │Subject AttrVal: Id │654f0877-2c0b-4a62-a9c3-87ed42bf77ac │ │Actions │[{&quot;Value&quot;:{&quot;Standard&quot;:1}}] │ │Subject Condition Set: I…│74bf521f-5a79-48fe-acb8-b4b63ee7950b │ │Subject Condition Set │[{&quot;condition_groups&quot;:[{&quot;conditions&quot;:[{&quot;subject_external_selector_value&quot;:&quot;.clientId&quot;,&quot;operator&quot;:1,&quot;subject_external_values&quot;:[&quot;opentdf&quot;]}],&quot;boolean_opera…│ │Attribute Value Id │654f0877-2c0b-4a62-a9c3-87ed42bf77ac │ │Created At │Mon Jun 24 11:35:13 UTC 2024 │ │Updated At │Mon Jun 24 11:35:13 UTC 2024 │ └─────────────────────────┴────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘ NOTE Use 'subject-mappings get --id=751054f8-14da-44c0-9341-5dab36b8256d --json' to see all properties Because we're using HIERARCHY for clearance, this executive clearance automatically grants standard clearance too. This means Jen can access both executive-level documents and standard documents. Decrypt Now That We Have Permission​ Now that we've been granted executive clearance, try decrypting the executive document again: otdfctl decrypt --profile platform-otdf-local executive-strategy.tdf # Output Executive Financial Strategy 2026: Confidential merger plans and Board-level decisions Success! With the proper clearance, Jen can now access her executive document. The same file that was locked before is now accessible. Create the Derivative Finance Report​ Now Jen creates a derivative version for the finance team. This one requires finance department access but only standard clearance: echo 'Finance Department Report 2026: Budget allocations and quarterly targets (no executive details)' | otdfctl encrypt --profile platform-otdf-local -o finance-report.tdf --attr https://opentdf.io/attr/department/value/finance --attr https://opentdf.io/attr/clearance/value/standard Notice this document has TWO attributes - it requires BOTH finance department membership AND standard clearance. Grant Finance Department Access​ To simulate Preston's access, let's grant ourselves the finance department attribute: otdfctl --profile platform-otdf-local policy subject-mappings create --action read --attribute-value-id $FINANCE_VALUE_ID --subject-condition-set-id $SUBJECT_CONDITION_SET_ID Decrypt the Finance Report​ Now we can access the derivative document (since we have executive clearance which includes standard, plus we just added finance department): otdfctl decrypt --profile platform-otdf-local finance-report.tdf # Output Finance Department Report 2026: Budget allocations and quarterly targets (no executive details) Success! Both Jen and Preston can now access this finance-specific document. What About Jack?​ Jack (engineering department) cannot access either document because: Executive strategy: Requires clearance/executive (Jack only has standard)Finance report: Requires department/finance (Jack is in engineering) This demonstrates attribute-based access control - the same encrypted files behave differently depending on WHO is trying to decrypt them. Takeaways and Next Steps​ You've successfully implemented Jen, Preston, and Jack's scenario! Here's what you learned: Key Concepts​ Namespaces organize attributes for your organizationAttributes classify data (department, clearance level, classification, etc.)Attribute Rules: ANY_OF: Need at least one value (departments)HIERARCHY: Higher values include lower ones (clearance levels)ALL_OF: Need all values (not used in this example) Subject Mappings grant users entitlements to decrypt data with specific attributesMultiple Attributes can be combined on a single document for fine-grained control Real-World Applications​ In production, you would: Create unique users in Keycloak for Jen, Preston, and JackUse subject condition sets that match by email, group membership, or custom claimsIntegrate with your existing identity providerSet up roles and groups in your IdP that map to attributes What's Next?​ Explore SDK integration to encrypt/decrypt in your applicationsLearn about Key Access Servers (KAS) for policy enforcementUnderstand policy management for access controlBuild attribute hierarchies for complex organizational structures","keywords":"","version":"Next"},{"title":"OpenTDF Specification","type":0,"sectionRef":"#","url":"/pr-172/spec","content":"OpenTDF Specification The Open, Interoperable Standard for Data-Centric Security Introduction​ OpenTDF (Trusted Data Format) defines an open and interoperable format for embedding data protection directly into data objects themselves (like files or emails). This enables robust data-centric security, ensuring data remains protected wherever it travels. This repository contains the official specification for OpenTDF, including the data format, cryptography, and protocols. It serves as the definitive reference for: Developers building applications or SDKs that create, consume, or manage TDF objects.Organizations implementing data protection solutions needing a standard for interoperability and integration.Partners participating in federated ecosystems where consistent data protection across organizational boundaries is crucial. Client SDKs and server-side services can be built upon this OpenTDF specification, ensuring standards-based security and enabling seamless interaction between different systems and organizations in a federated environment. OpenTDF derives its modern JSON-encoded format from the original TDF XML Specification. For details on interoperability with legacy TDF XML formats, please contact us. Versioning: This specification adheres to the Semantic Versioning 2.0.0 standard. Navigation​ OpenTDF Specification IntroductionNavigationSpecification DetailsLineage and UsageKey ConceptsCore Features &amp; CapabilitiesSecurity Principles: The C.I.A. TriadTDF StructureReference Implementation &amp; SDKsContact Specification Details​ The detailed technical specification is organized into the following sections: Schema (schema/): Defines the JSON schemas for the manifest.json and its constituent objects (like EncryptionInformation, KeyAccess, PolicyObject, etc.). This is the reference for the data structure format.Protocol (protocol/): Describes the high-level architecture, process workflows (e.g., key requests, unwrapping), and interactions between clients, Key Access Servers (KAS), and Identity Providers.Concepts (concepts/): Contains detailed explanations of core concepts including access control and security principles. Developers should consult these sections for implementation details regarding data formats, cryptographic operations, and protocol interactions. Lineage and Usage​ OpenTDF represents a modernization of data-centric security concepts originally established in the IC-TDF (Intelligence Community Trusted Data Format) specification. While IC-TDF utilized an XML-based structure, OpenTDF adopts a more contemporary approach using JSON for its manifest, enhancing flexibility and ease of integration with modern web technologies. Furthermore, OpenTDF serves as the foundational layer for other specialized data formats. Notably, ZTDF (Zero Trust Data Format), developed within NATO contexts, builds directly upon the OpenTDF specification. ZTDF extends OpenTDF by mandating the inclusion of specific cryptographic assertions required for NATO use cases, ensuring compliance with their operational requirements. The detailed specifications for IC-TDF and ZTDF are maintained separately and are not covered within this document. Key Concepts​ At its core, OpenTDF wraps sensitive data within a protective layer. This layer includes: Encrypted Payload: The original data, strongly encrypted.Metadata Manifest: A manifest.json file containing crucial information, such as: How the payload was encrypted.Where to retrieve the decryption key (Key Access information).The access control policy governing the data.Optionally, cryptographic assertions about the data or policy. This structure allows fine-grained control and auditing, independent of underlying storage or transport systems. To learn more about access control, and what makes OpenTDF secure, reference the following sections: Access ControlSecurity Core Features &amp; Capabilities​ OpenTDF is designed to provide comprehensive data security through the following features: Strong Encryption: Utilizes robust, modern cryptographic algorithms to protect both the data payload and the encryption keys themselves.Attribute-Based Access Control (ABAC): Enables highly scalable and flexible access control based on attributes of users, data, and the environment, defined within the TDF's policy.Persistent Policy Enforcement: Access policies are bound to the data, allowing data owners or administrators to manage access even after the data has been shared outside organizational boundaries.End-to-End Auditability: The protocol facilitates comprehensive logging of key requests, providing a reliable audit trail of data access attempts.Large File &amp; Streaming Support: Efficiently handles large data objects through secure streaming mechanisms, maintaining integrity throughout the process.Policy Integrity: Cryptographically binds the access policy defined in the manifest to the key access information, preventing policy tampering after creation.Offline Creation: Allows TDF objects to be created securely by clients even without immediate network connectivity to a key server, thanks to policy binding assurances.Federated Key Management: Supports scenarios where multiple Key Access Servers (KAS), potentially hosted by different organizations, can collaboratively manage access to a single TDF object, enabling secure cross-domain collaboration in a zero-trust manner. Security Principles: The C.I.A. Triad​ OpenTDF is designed with the fundamental security principles of Confidentiality, Integrity, and Availability (C.I.A.) at its core: Confidentiality: Ensures that sensitive data is only accessible to authorized users through strong encryption and attribute-based access control.Integrity: Maintains data authenticity and prevents unauthorized modifications through cryptographic binding of policies and payloads.Availability: Enables secure access to protected data through distributed key management and offline creation capabilities. These principles work together to provide comprehensive data protection while maintaining usability and accessibility for authorized users. TDF Structure​ By default, a TDF object is packaged as a standard Zip archive file, typically using the .tdf extension appended to the original filename. This archive contains two primary components: manifest.json: The metadata manifest described in the Key Concepts section. It holds instructions for decryption and access control.payload: The encrypted data payload itself. However, a TDF can be encoded in other ways. For example, as an HTML document: A TDF object can be packaged as a standard ZIP, or as an HTML document Reference Implementation &amp; SDKs​ A robust, open-source reference implementation of the OpenTDF specification is actively developed and maintained at opentdf/platform. This platform provides: Client SDKs: Ready-to-use libraries for integrating TDF capabilities into applications: JavaJavaScriptGo Server Components: Example implementations of backend services like the Key Access Server (KAS). Developers can use this platform as a practical guide, a starting point for their own implementations, or directly leverage the provided SDKs. Contact​ For questions regarding OpenTDF, interoperability, or the specification, please reach out to support@opentdf.io.","keywords":"","version":"Next"},{"title":"Creating TDFs","type":0,"sectionRef":"#","url":"/pr-172/sdks/tdf","content":"Creating TDFs Encrypting / Decrypting zTDF GoJavaTypescript package main import ( &quot;bytes&quot; &quot;log&quot; &quot;strings&quot; &quot;github.com/opentdf/platform/sdk&quot; ) func main() { log.Println(&quot;🚀 Starting OpenTDF example...&quot;) platformEndpoint := &quot;http://localhost:8080&quot; log.Printf(&quot;📡 Connecting to platform: %s&quot;, platformEndpoint) // Create a new client log.Println(&quot;🔐 Initializing new SDK client...&quot;) client, err := sdk.New( platformEndpoint, sdk.WithClientCredentials(&quot;opentdf&quot;, &quot;secret&quot;, nil), ) if err != nil { log.Fatalf(&quot;❌ Client initialization failed: %v&quot;, err) } // Encrypt ztdf log.Println(&quot;📝 Preparing sensitive data for encryption...&quot;) str := strings.NewReader(&quot;Sensitive data!&quot;) buf := &amp;bytes.Buffer{} log.Println(&quot;🔒 Encrypting data...&quot;) manifest, err := client.CreateTDF(buf, str, //sdk.WithDataAttributes(&quot;https://opentdf.io/attr/role/value/developer&quot;), sdk.WithKasInformation( sdk.KASInfo{ URL: platformEndpoint, }, ), ) if err != nil { log.Fatalf(&quot;❌ Encryption failed: %v&quot;, err) } log.Println(&quot;✅ Data successfully encrypted&quot;) log.Printf(&quot;📋 TDF Manifest details:\\n\\n%v\\n\\n&quot;, manifest) // Decrypt ZTDF log.Println(&quot;🔓 Decrypting data...&quot;) tdfReader, err := client.LoadTDF(bytes.NewReader(buf.Bytes())) if err != nil { log.Fatalf(&quot;❌ Decryption failed: %v&quot;, err) } // Create a buffer to capture the decrypted data var decryptedBuf bytes.Buffer if _, err = tdfReader.WriteTo(&amp;decryptedBuf); err != nil { log.Fatalf(&quot;❌ Failed to write decrypted data: %v&quot;, err) } log.Printf(&quot;📤 Decrypted content: \\n\\n%s\\n\\n&quot;, decryptedBuf.String()) log.Println(&quot;✅ Example complete!&quot;) } ","keywords":"","version":"Next"},{"title":"OpenTDF Access Control Concepts (ABAC)","type":0,"sectionRef":"#","url":"/pr-172/spec/concepts/access_control","content":"OpenTDF Access Control Concepts (ABAC) OpenTDF implements a sophisticated access control model known as Attribute-Based Access Control (ABAC). This approach provides fine-grained, flexible, and scalable authorization for data protection. What is ABAC?​ Attribute-Based Access Control is a security paradigm where access rights are granted based on the evaluated attributes of entities involved in an access request, rather than solely on roles or explicit permissions lists. Key components include: Subject Attributes: Characteristics of the entity requesting access (e.g., user's clearance, department, nationality, group memberships).Resource Attributes: Characteristics of the data or resource being accessed (e.g., data classification, sensitivity level, project code).Policies: Rules that define allowable actions by comparing subject, resource, and potentially environment attributes (e.g., &quot;Allow access if subject's clearance &gt;= resource's classification AND subject is in department 'X'&quot;).Policy Enforcement Point (PEP): The logical component that evaluates the policies against the attributes and makes the final access decision (grant or deny). ABAC offers significant advantages over traditional models, enabling dynamic access decisions that adapt to changing conditions without needing constant updates to user roles or access control lists (ACLs). OpenTDF's Implementation of ABAC​ OpenTDF embeds ABAC directly into the data's protection layer. Here's how its components map to ABAC concepts: Subject Attributes: Represented by Entity Entitlements. These are the attribute instances asserted by the identity system or client about the user/entity requesting access. They are provided to the PEP during an access request.Resource Attributes: Defined within the TDF's Policy Object in the dataAttributes array. These specify the attribute instances required to access this specific piece of data.Policies: Defined by the combination of: The dataAttributes required by the specific TDF.The optional dissem list in the TDF's Policy Object acting as an initial filter.Attribute Definitions managed externally by Attribute Authorities, which specify the rules (e.g., AllOf, AnyOf, Hierarchy) for comparing subject and resource attributes. Policy Enforcement Point (PEP): Typically resides within the Key Access Server (KAS) or associated logic. It receives the TDF's policy requirements, the subject's entitlements, retrieves the relevant Attribute Definitions, and makes the authorization decision before releasing a key. OpenTDF Attribute Representation​ To ensure interoperability and clarity, OpenTDF represents attributes as URIs (Uniform Resource Identifiers). The standard structure is:{Attribute Namespace}/attr/{Attribute Name}/value/{Attribute Value} Components: Component\tExample Value\tDescription\tGlobally Unique?Attribute Namespace\thttps://example.com\tTypically a domain controlled by the authoritative source of the attribute definition. Recommended to use a stable, controlled namespace.\tNo (by itself) Attribute Canonical Name\thttps://example.com/attr/classification\tCombination of Namespace and Name ({Namespace}/attr/{Name}). This MUST be globally unique and identifies the specific attribute type.\tYes Attribute Instance\thttps://example.com/attr/classification/value/secret\tThe full URI ({Canonical Name}/value/{Value}). This represents a specific, actionable attribute assertion used in policies or entitlements.\tYes Attribute Definitions (External Rules)​ Crucially, the rules governing how attributes are compared are defined in Attribute Definitions, which are associated with the globally unique Attribute Canonical Name. These definitions are managed by the attribute authority and are stored outside the TDF manifest itself. An Attribute Definition typically includes: Rule Type: How multiple values or comparisons should be handled (e.g., AllOf - entity must have all specified values, AnyOf - entity must have at least one, Hierarchy - values have an order).Allowed Values: An optional enumeration or pattern restricting valid attribute values.Order/Rank (for Hierarchy): Defines the relationship between values in a hierarchical attribute (e.g., Confidential &lt; Secret &lt; TopSecret). The PEP retrieves these definitions at access decision time based on the Canonical Names found in the TDF's dataAttributes and the entity's entitlements. Access Control Flow in OpenTDF​ When an entity requests access to an OpenTDF object: Request Initiation: The client presents the relevant Key Access Object(s) from the TDF manifest to the appropriate KAS, along with the client's credentials and asserted Entity Entitlements (Subject Attributes).PEP Evaluation: The KAS performs the following checks based on the TDF's embedded Policy Object (extracted from the policy field): Dissemination Check (if applicable): If the policy's dissem list is present and non-empty, the PEP verifies if the requesting entity's identifier is in the list. If not, access is denied.Attribute Check: The PEP examines the required dataAttributes (Resource Attributes) listed in the policy.For each required attribute, it retrieves the corresponding external Attribute Definition based on the attribute's Canonical Name.It compares the required dataAttributes against the provided Entity Entitlements using the comparison logic (AllOf, AnyOf, Hierarchy) specified in the retrieved Attribute Definitions.If the entity's entitlements do not satisfy the requirements of all dataAttributes according to their rules, access is denied. Key Release (if authorized): If both the Dissemination Check (if applicable) and the Attribute Check pass, the PEP considers the entity authorized. It then proceeds with verifying the Policy Binding and, if valid, unwraps and provides the requested key share(s) to the client. Policy Logic Clarification: The relationship between the dissem list and the dataAttributes is effectively an AND. An entity MUST be on the dissem list (if it's used) AND MUST satisfy the dataAttributes requirements. If the dissem list is empty or omitted, then only the dataAttributes requirements need to be met. The dissem list acts as an additional filter to narrow the audience beyond what the attributes alone define. By combining embedded policy requirements with externally defined attribute rules, OpenTDF achieves a powerful and flexible ABAC implementation for data-centric security.","keywords":"","version":"Next"},{"title":"OpenTDF Security Concepts","type":0,"sectionRef":"#","url":"/pr-172/spec/concepts/security","content":"OpenTDF Security Concepts OpenTDF is designed with security and tamper evidence as core principles, enabling data-centric protection where security travels with the data itself. This document outlines the key conceptual mechanisms that provide these guarantees. 1. Payload Encryption​ The most fundamental layer of protection is payload encryption. The original data within a TDF is encrypted using strong, authenticated symmetric encryption algorithms (typically AES-256-GCM). This ensures the confidentiality of the data – it cannot be read without the correct decryption key. The management and protection of this decryption key are handled by other mechanisms described below. 2. Payload Integrity Verification​ While encryption protects confidentiality, it doesn't inherently prevent undetected modification of the ciphertext. An attacker could potentially flip bits in the encrypted data. OpenTDF addresses this using the integrityInformation object within the manifest. Purpose: To allow recipients to verify that the encrypted payload has not been altered since its creation. This is especially critical for streamed data.Mechanism: Segmentation: The plaintext payload is processed in chunks (segments).Segment Hashing/Tagging: As each segment is encrypted (using AES-GCM, for example), a cryptographic integrity tag (like a GMAC) is generated for that encrypted segment using the payload encryption key. This tag is stored (as hash) in the corresponding Segment Object.Root Signature: All the individual segment tags/hashes are concatenated in order. A final HMAC (e.g., HMAC-SHA256) is calculated over this concatenated string of hashes, again using the payload encryption key. This result is stored as the rootSignature.sig. Result: Any modification to even a single bit of the encrypted payload will invalidate the integrity tag of the affected segment and consequently invalidate the final rootSignature. During decryption, the receiving client MUST verify the integrity tag of each segment and the overall rootSignature. Failure indicates tampering. 3. Policy Binding​ It's crucial that the access policy defined for a TDF cannot be detached from the key required to decrypt it. An attacker shouldn't be able to take a wrapped key associated with a strict policy and attach it to a TDF manifest that specifies a weaker policy. The policyBinding object within each Key Access Object prevents this. Purpose: To cryptographically link the specific access policy (defined in encryptionInformation.policy) to a particular wrapped key share held by a specific Key Access Server (KAS).Mechanism: The client retrieves the full, Base64-encoded policy string from the encryptionInformation section of the manifest it is constructing.For each key share it prepares to wrap for a specific KAS, the client takes the plaintext key share itself.It calculates an HMAC (e.g., HMAC-SHA256, specified by policyBinding.alg) using the plaintext key share as the secret key and the Base64-encoded policy string as the message data.This resulting HMAC hash is Base64 encoded and stored as policyBinding.hash within the same keyAccess object that contains the corresponding wrapped key share. Result: When a recipient requests key access from a KAS, they provide the keyAccess object (including the policyBinding). The KAS decrypts the wrappedKey to get the plaintext key share. It then recalculates the policy binding HMAC using this key share and the policy string provided (or referenced) in the request. If the calculated hash matches the policyBinding.hash received from the client, the KAS knows the policy presented corresponds to the one originally bound to this key share. If they don't match, it indicates tampering or a mismatch, and the KAS MUST deny the request. 4. Key Splitting (Multi-Party Access Control)​ To enhance security and enable multi-party control, OpenTDF supports key splitting. Instead of a single KAS holding the complete (wrapped) key, the key can be divided into multiple shares distributed across different KAS instances. Purpose: To require authorization from multiple, independent KAS entities before a client can reconstruct the full payload decryption key. This prevents a single compromised KAS from leaking the key and enforces multi-party access control logic.Mechanism: The client generates the payload encryption key.It splits the key into multiple cryptographic shares (e.g., using XOR with random nonces such that Share1 ⊕ Share2 ⊕ ... ⊕ ShareN = FullKey).Each share is treated as an independent key: it's wrapped using the public key of its designated KAS and associated with its own Policy Binding.Each wrapped share is stored in a separate Key Access Object within the encryptionInformation.keyAccess array. Crucially, each of these objects is assigned a unique Split ID (sid).To decrypt, a client must contact each KAS responsible for a required share (identified via the sid and url).Each KAS independently verifies the request against its bound policy (using the Policy Binding).If all necessary KASes grant access, the client receives the unwrapped shares.The client reconstructs the full payload key by combining the shares (e.g., XORing them together). Result: Access requires successfully authenticating and satisfying the policy constraints at multiple independent KAS instances. No single KAS holds enough information to decrypt the data alone. Summary: Layered Security​ These mechanisms work together: Encryption protects confidentiality.Payload Integrity ensures the encrypted data hasn't been undetectably modified.Policy Binding ensures the access policy cannot be decoupled from the key access grant for a specific KAS.Key Splitting enforces multi-party authorization, preventing single points of failure or compromise for key access. This layered approach provides robust, data-centric security and tamper evidence for data protected by OpenTDF.","keywords":"","version":"Next"},{"title":"OpenTDF Schema Documentation","type":0,"sectionRef":"#","url":"/pr-172/spec/schema","content":"OpenTDF Schema Documentation This directory contains the schema documentation for the base OpenTDF format. Specifications​ OpenTDF Format - The primary JSON-based TDF specification","keywords":"","version":"Next"},{"title":"OpenTDF Protocols","type":0,"sectionRef":"#","url":"/pr-172/spec/protocol","content":"OpenTDF Protocols This section describes the interaction protocols between OpenTDF clients (SDKs) and Key Access Servers (KAS) for securely managing access to the Data Encryption Keys (DEKs) used to protect TDF payloads. Protocol Selection and Crypto-Agility​ A core design principle of OpenTDF is crypto-agility. The specific cryptographic algorithms and protocols used for key wrapping and KAS communication are not rigidly fixed by the core TDF structure. Instead, each Key Access Object within a TDF's manifest specifies: The URL of the responsible KAS.The protocol identifier (e.g., wrapped) indicating how to interact with that KAS.A Key Identifier (kid) referencing a specific KAS public key.A Split Identifier (sid) uniquely identifying a key share when the DEK is split across multiple KAS instances for multi-party access control This allows different keyAccess objects within the same TDF to potentially use different key wrapping mechanisms (e.g., one KAS using RSA, another using ECIES based on Elliptic Curve Cryptography) or evolve independently to adopt new algorithms, such as post-quantum cryptography, without breaking the overall TDF format. The client SDK MUST interpret the details within a specific keyAccess object to determine how to interact with the corresponding KAS. General Interaction Flow​ While specific protocols vary, the high-level interaction generally follows these phases: TDF Creation: The SDK encrypts the payload with a generated DEK, defines the access policy, wraps the DEK using the target KAS's public key(s) according to the chosen protocol(s), calculates policy bindings, and constructs the manifest.Access Request: A client SDK parses the TDF manifest, identifies the relevant keyAccess object(s), and sends a request to the specified KAS URL(s). This request includes the wrapped key(s), policy binding information, the policy itself, and client authentication/authorization context (including the client's public key for rewrapping).KAS Verification: The KAS authenticates the client, decrypts the wrapped DEK share(s) using its private key, validates the policy binding against the provided policy and the decrypted DEK share, and performs the authorization check (evaluating the policy against the client's authenticated attributes).Key Rewrap &amp; Response: If all checks pass, the KAS re-encrypts (&quot;rewraps&quot;) the DEK share using the client's public key provided in the request and returns it. If any check fails, the KAS returns an error.Payload Decryption: The client SDK decrypts the rewrapped DEK share(s) using its private key, reconstructs the full DEK (if key splitting was used), and uses the DEK to decrypt the TDF payload, verifying payload integrity simultaneously. Example Protocol: RSA Key Wrapping​ The OpenTDF reference implementation (opentdf/platform) demonstrates specific protocols. Below is a detailed example flow using RSA for wrapping the DEK. This assumes a scenario with a single KAS for simplicity. TDF Creation (Encryption Flow)​ Executed by the OpenTDF Client/SDK Generate DEK: Generate a cryptographically strong symmetric Data Encryption Key (DEK) (e.g., AES-256).Encrypt Payload: Encrypt the original payload data using the DEK and an authenticated encryption mode (e.g., AES-256-GCM), generating an Initialization Vector (IV) and integrity tags per segment. Store the IV and segment information.Define Policy: Construct the Policy Object JSON defining the required attributes (dataAttributes) and dissemination list (dissem). Base64 encode this JSON string.Generate Policy Binding: Calculate the policy binding hash: HMAC(DEK, Base64(policyJSON)) using a standard algorithm like HMAC-SHA256. Base64 encode the resulting hash.Prepare Optional Metadata: If client-specific metadata needs to be passed securely to the KAS during decryption, prepare this data.Encrypt Optional Metadata: Encrypt the prepared metadata using the DEK (e.g., AES-GCM). Base64 encode the ciphertext. The encypted metadata is always passed to the KAS for processing, but from the perspective of a developer using the SDK, it is optional.Fetch KAS Public Key: Obtain the target KAS's RSA public key (identified by the KAS URL and potentially a kid). This might involve a separate discovery step or be pre-configured.Wrap DEK: Encrypt the plaintext DEK using the KAS's RSA public key (e.g., using RSAES-OAEP). Base64 encode the resulting ciphertext.Construct Key Access Object: Create the Key Access Object including: type: &quot;wrapped&quot;url: KAS URLprotocol: &quot;kas&quot; (or a more specific identifier if needed)kid: Identifier of the KAS key used.wrappedKey: Base64 encoded wrapped DEK from step 8.policyBinding: Object containing alg (e.g., &quot;HS256&quot;) and the Base64 encoded hash from step 4.encryptedMetadata: (Optional) Base64 encoded encrypted metadata from step 6. Construct Manifest: Assemble the full manifest.json including the payload, encryptionInformation (containing the keyAccess object(s), method, integrityInformation, and policy string), and any assertions.Package TDF: Create the Zip archive containing manifest.json and the encrypted payload file.Securely Discard DEK: Erase the plaintext DEK from memory immediately after it has been wrapped and used for metadata encryption/bindings. It should never be stored persistently by the encrypting client. TDF Access (Decryption Flow)​ Involves interaction between Client/SDK and KAS Phase 1: Client Preparation &amp; Request (Executed by SDK) Parse Manifest: Read the TDF's manifest.json.Identify KAS Target(s): Select the appropriate Key Access Object(s) based on desired KAS or required key shares (sid if splitting).Extract Information: From the selected keyAccess object(s), extract the KAS url, wrappedKey, policyBinding object, and optionally encryptedMetadata. Extract the Base64 policy string from encryptionInformation.Prepare Client Context: Obtain the client's authentication credentials (e.g., OAuth token) and the client's public key (corresponding to the private key the client will use for decryption).Construct Rewrap Request: Create a request payload (typically JSON) containing: The wrappedKey to be rewrapped.The policyBinding object (alg and hash).The Base64 policy string.(Optional) The encryptedMetadata.The client's public key (for the KAS to rewrap the DEK).Client authentication/authorization information (e.g., in HTTP headers). Send Request: POST the request payload to the KAS endpoint (e.g., {KAS_URL}/v1/rewrap). Phase 2: KAS Processing &amp; Verification (Executed by KAS) Authenticate Client: Verify the client's authentication credentials. If invalid, return an authentication error.Decrypt DEK Share: Use the KAS's private RSA key (corresponding to the public key used for wrapping, identified by kid) to decrypt the wrappedKey provided in the request, yielding the plaintext DEK share.Validate Policy Binding: Recalculate the HMAC: HMAC(DEK share, policy string from request) using the algorithm specified in the request's policyBinding.alg.Compare the recalculated HMAC hash with the policyBinding.hash provided in the request.If they do not match, return a policy binding error (indicates tampering or mismatch). (Optional) Decrypt Metadata: If encryptedMetadata was provided, decrypt it using the plaintext DEK share. This metadata might inform policy decisions or logging.Perform Authorization Check: Retrieve the requesting client's validated attributes/entitlements (based on their authenticated identity).Parse the policy string from the request to get the required dataAttributes and dissem list.Evaluate the policy rules (potentially retrieving external Attribute Definitions) against the client's attributes.Check if the client is in the dissem list (if applicable).If authorization fails (policy requirements not met), return an authorization error. Rewrap DEK Share: If all checks pass, encrypt the plaintext DEK share using the client's public key provided in the request (e.g., using RSAES-OAEP if the client key is RSA). Base64 encode the result.Send Response: Return a success response containing the Base64 encoded, rewrapped DEK share. Phase 3: Client Decryption (Executed by SDK) Receive Response: Get the response from the KAS. Check for errors (authentication, binding, authorization failures).Decrypt DEK Share: If the request was successful, use the client's private key to decrypt the rewrapped DEK share received from the KAS.(If Key Splitting) Reconstruct DEK: If multiple shares were required (sid was used), combine the decrypted shares (e.g., via XOR) to reconstruct the full plaintext DEK.Decrypt Payload: Use the plaintext DEK and the parameters from encryptionInformation.method (IV) to decrypt the TDF payload. During decryption (especially with AES-GCM or streaming), simultaneously verify the integrity of each segment using the hash from the Segment Object and finally verify the rootSignature from integrityInformation. If any integrity check fails, abort decryption and report an error.Securely Discard DEK: Once the payload is decrypted or decryption fails, securely erase the plaintext DEK and any intermediate shares from memory. Error Handling​ KAS implementations SHOULD return standard HTTP error codes and informative error messages (without revealing sensitive internal state) for failed requests, clearly distinguishing between: Authentication failures (401/403)Policy Binding validation failures (e.g., 400 Bad Request or 403 Forbidden)Authorization failures (policy denied) (403 Forbidden)Invalid input or malformed requests (400 Bad Request)Internal server errors (500) Clients MUST handle these errors appropriately.","keywords":"","version":"Next"},{"title":"OpenTDF Specification Overview","type":0,"sectionRef":"#","url":"/pr-172/spec/schema/opentdf","content":"OpenTDF Specification Overview This section details the OpenTDF format, the primary specification for general-purpose Trusted Data Format (TDF) implementations. It utilizes a JSON-based manifest packaged with the encrypted payload within a standard Zip archive. Core Concepts​ Before diving into specific object definitions, understand these core OpenTDF concepts: Security: Learn about what makes OpenTDF secure. See Security Concepts.Key Access and Wrapping: How access control is defined using ABAC. See Access Control. Format Structure​ An OpenTDF file is a Zip archive, typically using the .tdf extension (e.g., document.pdf.tdf). It MUST contain the following components: manifest.json: A JSON file containing all metadata required for decryption and access control. This is the core of the TDF structure.payload: The encrypted original data. The filename within the archive is referenced by the manifest.json (commonly 0.payload). Key Components of manifest.json​ The manifest.json file orchestrates the TDF. Its main sections are: Payload Description: Information about the encrypted payload (type, reference, protocol, encryption status). See Payload Object.Encryption Information: Details on how the payload was encrypted, how to access the key, integrity checks, and the access policy. See Encryption Information. This includes: Key Access Objects: How and where to get the decryption key.Method: Symmetric encryption algorithm details.Integrity Information: Hashes/signatures for payload integrity.Policy: The access control policy (embedded as a Base64 string). Assertions: Optional, verifiable statements about the TDF or payload. See Assertions. Manifest Schema​ Use the links below to explore the detailed structure of each component: Manifest Structure (manifest.json)Payload ObjectEncryption Information Object Key Access ObjectMethod ObjectIntegrity Information ObjectSegment Object Assertions Statement ObjectBinding Object Conceptual Guides: SecurityAccess Control","keywords":"","version":"Next"},{"title":"Assertions Array","type":0,"sectionRef":"#","url":"/pr-172/spec/schema/opentdf/assertion","content":"Assertions Array The assertions array, an optional top-level property in the manifest, contains assertion objects. Assertions are verifiable statements about the TDF or its payload, often used for security labeling or handling instructions. Example (Array containing one Assertion Object)​ &quot;assertions&quot;: [ { &quot;id&quot;: &quot;handling-assertion-1&quot;, &quot;type&quot;: &quot;handling&quot;, &quot;scope&quot;: &quot;payload&quot;, &quot;appliesToState&quot;: &quot;encrypted&quot;, &quot;statement&quot;: { /* See Statement Object */ }, &quot;binding&quot;: { /* See Binding Object */ } } ] Assertion Object Structure​ Each object within the assertions array represents a single assertion and has the following fields: Parameter\tType\tDescription\tRequired?id\tString\tA unique identifier for this assertion within this TDF manifest. Used for internal referencing.\tYes type\tString\tCategorizes the assertion's purpose. Common values include handling (e.g., caveats, dissemination controls) or metadata (general information).\tYes scope\tString\tSpecifies whether the assertion applies to the entire TDF object (tdo) or just the payload.\tYes appliesToState\tString\tIndicates if the assertion's statement applies to the data in its encrypted state or its unencrypted state (after decryption). Default is encrypted.\tNo statement\tObject\tThe actual content of the assertion. See Statement Object.\tYes binding\tObject\tA cryptographic signature ensuring the assertion's integrity and preventing it from being moved to another TDF. See Assertion Binding\tYes","keywords":"","version":"Next"},{"title":"Statement Object","type":0,"sectionRef":"#","url":"/pr-172/spec/schema/opentdf/assertion_statement","content":"Statement Object The statement object, nested within an Assertion Object, contains the core information or claim of the assertion. Example​ &quot;statement&quot;: { &quot;schema&quot;: &quot;urn:nato:stanag:4774:confidentialitymetadatalabel:1:0&quot;, &quot;format&quot;: &quot;json-structured&quot;, &quot;value&quot;: { &quot;Xmlns&quot;: &quot;urn:nato:stanag:4774:confidentialitymetadatalabel:1:0&quot;, &quot;CreationTime&quot;: &quot;2015-08-29T16:15:00Z&quot;, &quot;ConfidentialityInformation&quot;: { /* ... specific assertion info ... */ } } } Fields​ Parameter\tType\tDescription\tRequired?schema\tString\tAn optional URI identifying the schema or standard that defines the structure and semantics of the value.\tNo format\tString\tDescribes how the value is encoded. Common values: json-structured (value is a JSON object), base64binary (value is Base64 encoded binary), string.\tYes value\tAny\tThe assertion content itself, formatted according to the format field. Can be a string, number, boolean, object, or array (if format is json-structured).\tYes","keywords":"","version":"Next"},{"title":"Attribute Object (Structure)","type":0,"sectionRef":"#","url":"/pr-172/spec/schema/opentdf/attributes","content":"Attribute Object (Structure) This document describes the JSON structure representing an Attribute Instance when embedded within a Policy Object. For a conceptual overview of attributes, and their role in access control, see Access Control Concepts. An Attribute Object represents a single required attribute instance needed to access the data. Example​ { &quot;attribute&quot;: &quot;https://example.com/attr/classification/value/topsecret&quot; } Fields​ Parameter\tType\tDescription\tRequired?attribute\tString\tThe full Attribute Instance URI, composed of {Namespace}/attr/{Name}/value/{Value}. See Access Control concepts.\t","keywords":"","version":"Next"},{"title":"Binding Object (Assertion)","type":0,"sectionRef":"#","url":"/pr-172/spec/schema/opentdf/assertion_binding","content":"Binding Object (Assertion) The binding object, nested within an Assertion Object, contains a cryptographic signature binding the assertion to the TDF context, ensuring its integrity and preventing replay on other TDFs. Example​ &quot;binding&quot;: { &quot;method&quot;: &quot;jws&quot;, &quot;signature&quot;: &quot;eyJhbGciOiJSUzI1NiJ9...&quot; // Base64URL encoded JWS string } Fields​ Parameter\tType\tDescription\tRequired?method\tString\tThe cryptographic method used for the signature. jws (JSON Web Signature) is commonly used, implying standard JWS processing rules apply.\tYes signature\tString\tThe Base64URL encoded signature value (e.g., a JWS Compact Serialization string). The signature calculation MUST include the assertion content and sufficient TDF context (like policy or key info hash) to prevent replay.\tYes","keywords":"","version":"Next"},{"title":"Encryption Information Object","type":0,"sectionRef":"#","url":"/pr-172/spec/schema/opentdf/encryption_information","content":"Encryption Information Object The encryptionInformation object, part of the manifest, aggregates all information related to the encryption of the payload, policy enforcement, and key management. Example​ &quot;encryptionInformation&quot;: { &quot;type&quot;: &quot;split&quot;, &quot;keyAccess&quot;: [ { /* See Key Access Object */ } ], &quot;method&quot;: { /* See Method Object */ }, &quot;integrityInformation&quot;: { /* See Integrity Information Object */ }, &quot;policy&quot;: &quot;eyJ1dWlkIjoiNGYw...vbSJdfX0=&quot; // Base64 encoded Policy Object JSON } Fields​ Parameter\tType\tDescription\tRequired?type\tString\tSpecifies the key management scheme. split is the primary scheme, allowing key sharing or splitting across multiple keyAccess entries.\tYes keyAccess\tArray\tAn array of one or more Key Access Objects. Each object describes how to obtain the payload decryption key (or a key split) from a specific Key Access Server (KAS).\tYes method\tObject\tDescribes the symmetric encryption algorithm used on the payload. See Method Object.\tYes integrityInformation\tObject\tContains information for verifying the integrity of the payload, especially for streamed TDFs. See Integrity Information Object.\tYes policy\tString\tA Base64 encoding of the JSON string representing the Policy Object. Defines the access control rules for the TDF. For conceptual details, see Access Control.\t","keywords":"","version":"Next"},{"title":"Key Access Object","type":0,"sectionRef":"#","url":"/pr-172/spec/schema/opentdf/key_access_object","content":"Key Access Object A Key Access Object, found within the keyAccess array in encryptionInformation, stores information about how a specific payload encryption key (or key split/share) is stored and accessed, typically via a Key Access Server (KAS). Example​ { &quot;type&quot;: &quot;wrapped&quot;, &quot;url&quot;: &quot;https://kas.example.com:5000&quot;, &quot;kid&quot;: &quot;6f3b6a82-2f30-4c8a-aef3-57c65b8e7387&quot;, // Optional KAS Key ID &quot;sid&quot;: &quot;split-id-1&quot;, // Optional Split ID &quot;protocol&quot;: &quot;kas&quot;, &quot;wrappedKey&quot;: &quot;OqnOE...B82uw==&quot;, // Base64 encoded wrapped key &quot;policyBinding&quot;: { &quot;alg&quot;: &quot;HS256&quot;, &quot;hash&quot;: &quot;BzmgoIxZzMmIF42qzbdD4Rw30GtdaRSQL2Xlfms1OPs=&quot; // Base64 encoded hash }, &quot;encryptedMetadata&quot;: &quot;ZoJTNW24UMhnXIif0mSnqLVCU=&quot; // Base64 encoded encrypted metadata } Fields​ Parameter\tType\tDescription\tRequired?type\tString\tSpecifies how the key is stored/accessed. Possible Values: remote: Key stored remotely (legacy, details TBD).wrapped: Default. The wrappedKey field contains the payload key encrypted with the KAS key identified by url (and optionally kid).remoteWrapped: Key is wrapped, but managed by a distinct CKS (details TBD). Yes url\tString\tThe base URL of the Key Access Server (KAS) responsible for this key or key share.\tYes protocol\tString\tProtocol used to interact with the url. Currently, only kas is specified.\tYes wrappedKey\tString\tThe Base64 encoded payload symmetric key (or key share), encrypted (&quot;wrapped&quot;) using the public key of the KAS identified by url (and optionally kid).\tYes policyBinding\tObject\tAn object containing a keyed hash binding the policy string from encryptionInformation to this specific wrappedKey. This prevents policy tampering without access to the key share.\tYes kid\tString\tOptional. An identifier for the specific public key at the KAS (url) used to wrap the wrappedKey. This could be a key fingerprint, UUID, etc. Aids key rotation.\tNo sid\tString\tOptional. A Key Split (or Share) Identifier. If present, it indicates this wrappedKey represents only a share of the full payload key. Multiple keyAccess objects with different sid values (but potentially the same type/url) might need to be combined (e.g., via XOR) by the client after receiving unwrapped shares from respective KASes to reconstruct the final payload key. The encryptionInformation.type (split) governs this behavior.\tNo encryptedMetadata\tString\tOptional. Base64 encoded, encrypted metadata associated with this key access entry. Contains client-provided information (e.g., request context) passed to the KAS during rewrap requests. The KAS decrypts this using its private key. The content is freeform and SHOULD NOT be used for primary access decisions.\tNo Policy Binding Object (keyAccess.policyBinding)​ This nested object provides the cryptographic binding between the policy and the key share. Parameter\tType\tDescription\tRequired? alg\tString\tThe algorithm used to generate the hash. HS256 (HMAC-SHA256) is commonly used.\tYes hash\tString\tA Base64 encoding of HMAC(KEY, POLICY), where: - POLICY: The Base64 encoded policy string from encryptionInformation.policy. - HMAC: The algorithm specified by alg (e.g., HMAC-SHA256). - KEY: The plaintext symmetric key corresponding to the wrappedKey in this Key Access Object (i.e., the key share itself). The KAS verifies this binding upon receiving a rewrap request before proceeding.\tYes","keywords":"","version":"Next"},{"title":"Integrity Information Object","type":0,"sectionRef":"#","url":"/pr-172/spec/schema/opentdf/integrity_information","content":"Integrity Information Object The integrityInformation object, nested within encryptionInformation, provides mechanisms to verify the integrity of the encrypted payload, essential for streaming and detecting tampering. Example​ &quot;integrityInformation&quot;: { &quot;rootSignature&quot;: { &quot;alg&quot;: &quot;HS256&quot;, &quot;sig&quot;: &quot;M2E2MTI5YmMxMW...WNlMWVjYjlmODUzNmNiZQ==&quot; // Base64 encoded signature }, &quot;segmentHashAlg&quot;: &quot;GMAC&quot;, &quot;segments&quot;: [ { /* See Segment Object */ } ], &quot;segmentSizeDefault&quot;: 1000000, &quot;encryptedSegmentSizeDefault&quot;: 1000028 } Fields​ Parameter\tType\tDescription\tRequired?rootSignature\tObject\tContains a cryptographic signature or HMAC over the combined integrity hashes of all segments, providing overall payload integrity.\tYes rootSignature.alg\tString\tAlgorithm used for the rootSignature.sig. HS256 (HMAC-SHA256 using the payload key) is commonly used.\tYes rootSignature.sig\tString\tThe Base64 encoded signature or HMAC value. Calculated over the concatenation of all segment hashes/tags in order. E.g., Base64(HMAC-SHA256(PayloadKey, Concat(SegmentHash1, SegmentHash2, ...))).\tYes segmentHashAlg\tString\tThe algorithm used to generate the hash for each segment in the segments array. GMAC (using the AES-GCM payload key) is commonly used when method.algorithm is AES-256-GCM.\tYes segments\tArray\tAn array of Segment Objects, one for each chunk of the payload if method.isStreamable is true. Order MUST match payload order.\tYes segmentSizeDefault\tNumber\tThe default size (in bytes) of the plaintext payload segments. Allows omitting segmentSize in individual segment objects if they match this default.\tYes encryptedSegmentSizeDefault\tNumber\tThe default size (in bytes) of the encrypted payload segments (including any authentication tag overhead, like from AES-GCM). Allows omitting encryptedSegmentSize in segments. encryptionInformation.integrityInformation.segment​ Object containing integrity information about a segment of the payload, including its hash. { &quot;hash&quot;: &quot;NzhlZDg5OWMwZWVhZDBjMWEzZTQyYmFlODA0NjNlMDM=&quot;, &quot;segmentSize&quot;: 14056, &quot;encryptedSegmentSize&quot;: 14084 } Parameter\tType\tDescriptionhash\tString\tA hash generated using the specified segmentHashAlg. Base64.encode(HMAC(segment, payloadKey)) segmentSize\tNumber\tThe size of the segment. This field is optional. The size of the segment is inferred from 'segmentSizeDefault' defined above, but in the event that a segment were modified and re-encrypted, the segment size would change. encryptedSegmentSize\tNumber\tThe size of the segment (in bytes) after the payload segment has been encrypted.","keywords":"","version":"Next"},{"title":"Method Object","type":0,"sectionRef":"#","url":"/pr-172/spec/schema/opentdf/method","content":"Method Object The method object, nested within encryptionInformation, describes the symmetric encryption algorithm and parameters used to encrypt the payload. Example​ &quot;method&quot;: { &quot;algorithm&quot;: &quot;AES-256-GCM&quot;, &quot;isStreamable&quot;: true, &quot;iv&quot;: &quot;D6s7cSgFXzhVkran&quot; // Base64 encoded IV } Fields​ Parameter\tType\tDescription\tRequired?algorithm\tString\tThe symmetric encryption algorithm used. AES-256-GCM is the recommended and commonly implemented algorithm.\tYes isStreamable\tBoolean\tIndicates if the payload was encrypted in segments suitable for streaming decryption. If true, integrityInformation MUST contain segment details.\tYes iv\tString\tThe Base64 encoded Initialization Vector (IV) used with the symmetric algorithm. MUST be unique for each TDF encrypted with the same key. For AES-GCM, typically 12 bytes (96 bits).\tYes","keywords":"","version":"Next"},{"title":"Payload Object","type":0,"sectionRef":"#","url":"/pr-172/spec/schema/opentdf/payload","content":"Payload Object The payload object within the manifest contains metadata required to locate and process the TDF's encrypted payload. Example​ &quot;payload&quot;: { &quot;type&quot;: &quot;reference&quot;, &quot;url&quot;: &quot;0.payload&quot;, &quot;protocol&quot;: &quot;zip&quot;, &quot;isEncrypted&quot;: true, &quot;mimeType&quot;: &quot;application/pdf&quot; } Fields​ Parameter\tType\tDescription\tRequired?type\tString\tDescribes how the payload is referenced. Currently, reference (indicating the payload is within the TDF archive) is the only specified type.\tYes url\tString\tA URI pointing to the location of the payload. For type: reference, this is typically a relative path within the Zip archive (e.g., 0.payload).\tYes protocol\tString\tDesignates the packaging format of the payload within the TDF. Allowed values include zip (for standard files) and zipstream (for streamed files).\tYes isEncrypted\tBoolean\tIndicates whether the payload referenced by url is encrypted. MUST be true for standard TDFs. Future use may allow false.\tYes mimeType\tString\tSpecifies the MIME type of the original, unencrypted data. If not provided, application/octet-stream SHOULD be assumed.\tNo","keywords":"","version":"Next"},{"title":"OpenTDF Manifest (manifest.json)","type":0,"sectionRef":"#","url":"/pr-172/spec/schema/opentdf/manifest","content":"OpenTDF Manifest (manifest.json) Summary​ The manifest.json file MUST be in JSON format and reside within the root of the OpenTDF Zip archive. It serves as the central metadata component, storing the necessary information for processing the TDF payload and making access decisions by a Policy Enforcement Point (PEP). Top-Level Structure​ The manifest object contains the following top-level properties: Parameter\tType\tDescription\tRequired?tdf_spec_version\tString\tSemver version number of the OpenTDF specification this manifest conforms to.\tYes payload\tObject\tDescribes the location and characteristics of the encrypted payload. See Payload Object.\tYes encryptionInformation\tObject\tContains details about encryption, key access, integrity, and policy. See Encryption Information Object.\tYes assertions\tArray\tOptional array of verifiable statements about the TDF or payload. See Assertions Array.\tNo Full Manifest Example​ This example illustrates a complete manifest.json structure. Links point to detailed descriptions of each major section. { &quot;tdf_spec_version&quot;: &quot;1.0.0&quot;, // --- Payload Object --- &quot;payload&quot;: { &quot;type&quot;: &quot;reference&quot;, &quot;url&quot;: &quot;0.payload&quot;, &quot;protocol&quot;: &quot;zip&quot;, &quot;isEncrypted&quot;: true, &quot;mimeType&quot;: &quot;application/octet-stream&quot; }, // --- Encryption Information Object --- &quot;encryptionInformation&quot;: { &quot;type&quot;: &quot;split&quot;, // --- Key Access Array --- &quot;keyAccess&quot;: [ { &quot;type&quot;: &quot;wrapped&quot;, &quot;url&quot;: &quot;http://kas.example.com:4000&quot;, &quot;protocol&quot;: &quot;kas&quot;, &quot;wrappedKey&quot;: &quot;YBkqvsiDnyDfw5JQzux2S2IaiClhsojZuLYY9WOc9N9l37A5/Zi7iloxcqgFvBFbzVjGW4QBwAHsytKQvE87bHTuQkZs4XyPACOZE/k9r+mK8KazcGTkOnqPKQNhf2XK4TBACJZ6eItO5Q1eHUQVLKjxUfgyx2TBDfhB/7XifNthu+6lFbKHmPl1q7q1Vaa/rpPRhSgqf89x5fQvcSWdkuOH9Y4wTa8tdKqSS3DUNMKTIUQq8Ti/WFrq26DRemybBgBcL/CyUZ98hFjDQgy4csBusEqwQ5zG+UAoRgkLkHiAw7hNAayAUCVRw6aUYRF4LWfcs2BM9k6d3bHqun0v5w==&quot;, &quot;policyBinding&quot;: { &quot;alg&quot;: &quot;HS256&quot;, &quot;hash&quot;: &quot;ZGMwNGExZjg0ODFjNDEzZTk5NjdkZmI5MWFjN2Y1MzI0MTliNjM5MmRlMTlhYWM0NjNjN2VjYTVkOTJlODcwNA==&quot; }, &quot;encryptedMetadata&quot;: &quot;OEOqJCS6mZsmLWJ38lh6EN2lDUA8OagL/OxQRQ==&quot; } ], // --- Method Object --- &quot;method&quot;: { &quot;algorithm&quot;: &quot;AES-256-GCM&quot;, &quot;isStreamable&quot;: true, &quot;iv&quot;: &quot;OEOqJCS6mZsmLWJ3&quot; }, // --- Integrity Information Object --- &quot;integrityInformation&quot;: { &quot;rootSignature&quot;: { &quot;alg&quot;: &quot;HS256&quot;, &quot;sig&quot;: &quot;YjliMzAyNjg4NzA0NzUyYmUwNzY1YWE4MWNhNDRmMDZjZDU3OWMyYTMzNjNlNDYyNTM4MDA4YjQxYTdmZmFmOA==&quot; }, &quot;segmentSizeDefault&quot;: 1000000, &quot;segmentHashAlg&quot;: &quot;GMAC&quot;, // --- Segments Array --- &quot;segments&quot;: [ { &quot;hash&quot;: &quot;ZmQyYjY2ZDgxY2IzNGNmZTI3ODFhYTk2ZjJhNWNjODA=&quot;, &quot;segmentSize&quot;: 14056, &quot;encryptedSegmentSize&quot;: 14084 } ], &quot;encryptedSegmentSizeDefault&quot;: 1000028 }, // --- Policy String --- &quot;policy&quot;: &quot;eyJ1dWlkIjoiNjEzMzM0NjYtNGYwYS00YTEyLTk1ZmItYjZkOGJkMGI4YjI2IiwiYm9keSI6eyJhdHRyaWJ1dGVzIjpbXSwiZGlzc2VtIjpbInVzZXJAdmlydHJ1LmNvbSJdfX0=&quot; }, // --- Assertions Array --- &quot;assertions&quot;: [ { &quot;id&quot;: &quot;nato-label-1&quot;, &quot;type&quot;: &quot;handling&quot;, &quot;scope&quot;: &quot;payload&quot;, &quot;appliesToState&quot;: &quot;encrypted&quot;, // --- Statement Object --- &quot;statement&quot;: { &quot;format&quot;: &quot;json-structured&quot;, &quot;schema&quot;: &quot;urn:nato:stanag:4774:confidentialitymetadatalabel:1:0&quot;, &quot;value&quot;: { &quot;Xmlns&quot;: &quot;urn:nato:stanag:4774:confidentialitymetadatalabel:1:0&quot;, &quot;CreationTime&quot;: &quot;2015-08-29T16:15:00Z&quot;, &quot;ConfidentialityInformation&quot;: { &quot;PolicyIdentifier&quot;: &quot;NATO&quot;, &quot;Classification&quot;: &quot;SECRET&quot;, &quot;Category&quot;: { &quot;Type&quot;: &quot;PERMISSIVE&quot;, &quot;TagName&quot;: &quot;Releasable to&quot;, &quot;GenericValues&quot;: [ &quot;SWE&quot;, &quot;FIN&quot;, &quot;FRA&quot; ] } } } }, // --- Binding Object --- &quot;binding&quot;: { &quot;method&quot;: &quot;jws&quot;, &quot;signature&quot;: &quot;eyJhbGciOiJIUzI1NiJ9.eyJzY2hlbWEiOiJ1cm46bmF0bzpzdGFuYWc6NDc3NDpjb25maWRlbnRpYWxpdHltZXRhZGF0YWxhYmVsOjE6MCIsImZvcm1hdCI6Impzb24tc3RydWN0dXJlZCIsInZhbHVlIjp7IlhtbG5zIjoidXJuOm5hdG86c3RhbmFnOjQ3NzQ6Y29uZmlkZW50aWFsaXR5bWV0YWRhdGFsYWJlbDoxOjAiLCJDcmVhdGlvblRpbWUiOiIyMDE1LTA4LTI5VDE2OjE1OjAwWiIsIkNvbmZpZGVudGlhbGl0eUluZm9ybWF0aW9uIjp7IlBvbGljeUlkZW50aWZpZXIiOiJOQVRPIiwiQ2xhc3NpZmljYXRpb24iOiJTRUNSRVQiLCJDYXRlZ29yeSI6eyJNeXBlIjoiUEVSTUlTU0lWRSIsIlRhZ05hbWUiOiJSZWxlYXNhYmxlIHRvIiwiR2VuZXJpY1ZhbHVlcyI6WyJTV0UiLCJGSU4iLCJGUkEiXX19fX0.FakeBindingSignatureExample&quot; } } ] } ","keywords":"","version":"Next"},{"title":"Policy Object (Structure)","type":0,"sectionRef":"#","url":"/pr-172/spec/schema/opentdf/policy","content":"Policy Object (Structure) This document describes the JSON structure of the Policy Object. The entire object is JSON stringified and then Base64 encoded when stored in the encryptionInformation.policy field of the manifest. For a conceptual overview, see Access Control Concepts. The Policy Object contains the access control rules for the TDF. Example (Decoded JSON Structure)​ { &quot;uuid&quot;: &quot;1111-2222-33333-44444-abddef-timestamp&quot;, &quot;body&quot;: { &quot;dataAttributes&quot;: [&lt;Attribute Object&gt;], &quot;dissem&quot;: [&quot;user-id@domain.com&quot;] }, } Fields​ Parameter\tType\tDescription\tRequired?uuid\tString\tA UUID uniquely identifying this specific policy instance.\tYes body\tObject\tContains the core access control constraints.\tYes body.dataAttributes\tArray\tAn array of Attribute Objects. Represents the attributes an entity must possess (according to their definitions and rules) to satisfy the policy's ABAC requirements.\tYes body.dissem\tArray\tAn array of strings, where each string is a unique identifier for an entity (e.g., email address, user ID). If present, an entity requesting access must be included in this list in addition to satisfying the dataAttributes. If empty or omitted, any entity satisfying dataAttributes may be granted access.\tNo","keywords":"","version":"Next"},{"title":"Managing Policy","type":0,"sectionRef":"#","url":"/pr-172/sdks/policy","content":"Managing Policy Creating a Namespace GoJavaJavascript package main import ( &quot;context&quot; &quot;log&quot; &quot;github.com/opentdf/platform/protocol/go/policy/namespaces&quot; &quot;github.com/opentdf/platform/sdk&quot; ) func main() { platformEndpoint := &quot;http://localhost:8080&quot; // Create a new client client, err := sdk.New( platformEndpoint, sdk.WithClientCredentials(&quot;opentdf&quot;, &quot;secret&quot;, nil), ) if err != nil { log.Fatal(err) } // Create Namespace namespace := &amp;namespaces.CreateNamespaceRequest{ Name: &quot;opentdf.io&quot;, } _, err = client.Namespaces.CreateNamespace(context.Background(), namespace) if err != nil { log.Fatal(err) } } List Namespaces GoJavaJavascript package main import ( &quot;context&quot; &quot;log&quot; &quot;github.com/opentdf/platform/protocol/go/policy/namespaces&quot; &quot;github.com/opentdf/platform/sdk&quot; ) func main() { platformEndpoint := &quot;http://localhost:8080&quot; // Create a new client client, err := sdk.New( platformEndpoint, sdk.WithClientCredentials(&quot;opentdf&quot;, &quot;secret&quot;, nil), ) if err != nil { log.Fatal(err) } // List All Namespaces namespaces, err := client.Namespaces.ListNamespaces(context.Background(), &amp;namespaces.ListNamespacesRequest{}) if err != nil { log.Fatal(err) } for _, namespace := range namespaces.GetNamespaces() { log.Printf(&quot;Namespace: %s\\n&quot;, namespace.GetName()) } } Create Attribute GoJavaJavascript package main import ( &quot;context&quot; &quot;crypto/rand&quot; &quot;log&quot; &quot;github.com/opentdf/platform/protocol/go/policy&quot; &quot;github.com/opentdf/platform/protocol/go/policy/attributes&quot; &quot;github.com/opentdf/platform/protocol/go/policy/namespaces&quot; &quot;github.com/opentdf/platform/sdk&quot; ) func main() { platformEndpoint := &quot;http://localhost:8080&quot; // Create a new client client, err := sdk.New( platformEndpoint, sdk.WithClientCredentials(&quot;opentdf&quot;, &quot;secret&quot;, nil), ) if err != nil { log.Fatal(err) } // List namespaces to get a namespace ID listResponse, err := client.Namespaces.ListNamespaces(context.Background(), &amp;namespaces.ListNamespacesRequest{}) if err != nil { log.Fatalf(&quot;failed to list namespaces: %s&quot;, err) } if len(listResponse.GetNamespaces()) == 0 { log.Fatal(&quot;no namespaces found&quot;) } namespaceID := listResponse.GetNamespaces()[0].GetId() // Create a new attribute attrRequest := &amp;attributes.CreateAttributeRequest{ NamespaceId: namespaceID, Name: &quot;role&quot; + &quot;-&quot; + rand.Text()[:4], Rule: policy.AttributeRuleTypeEnum_ATTRIBUTE_RULE_TYPE_ENUM_ANY_OF, Values: []string{&quot;admin&quot;, &quot;developer&quot;, &quot;guest&quot;}, } attribute, err := client.Attributes.CreateAttribute(context.Background(), attrRequest) if err != nil { log.Fatal(err) } log.Printf(&quot;Created attribute: %s with ID: %s in namespace: %s\\n&quot;, attribute.GetAttribute().Name, attribute.GetAttribute().GetId(), namespaceID) } List Attributes GoJavaJavascript package main import ( &quot;context&quot; &quot;log&quot; &quot;github.com/opentdf/platform/protocol/go/policy/attributes&quot; &quot;github.com/opentdf/platform/sdk&quot; ) func main() { platformEndpoint := &quot;http://localhost:8080&quot; // Create a new client client, err := sdk.New( platformEndpoint, sdk.WithClientCredentials(&quot;opentdf&quot;, &quot;secret&quot;, nil), ) if err != nil { log.Fatal(err) } // List attributes attrs, err := client.Attributes.ListAttributes(context.Background(), &amp;attributes.ListAttributesRequest{}) if err != nil { log.Fatal(err) } for _, attr := range attrs.GetAttributes() { log.Printf(&quot;Attribute: %s, ID: %s, &quot;, attr.GetName(), attr.GetId()) for _, value := range attr.Values { log.Printf(&quot;Value: %s, ID: %s&quot;, value.GetValue(), value.GetId()) } } } Create Subject Condition Set GoJavaJavascript package main import ( &quot;context&quot; &quot;log&quot; &quot;github.com/opentdf/platform/protocol/go/policy&quot; &quot;github.com/opentdf/platform/protocol/go/policy/subjectmapping&quot; &quot;github.com/opentdf/platform/sdk&quot; ) func main() { platformEndpoint := &quot;http://localhost:8080&quot; // Create a new client client, err := sdk.New( platformEndpoint, sdk.WithClientCredentials(&quot;opentdf&quot;, &quot;secret&quot;, nil), ) if err != nil { log.Fatal(err) } // Create Subject Condition Set conditionset := &amp;subjectmapping.CreateSubjectConditionSetRequest{ SubjectConditionSet: &amp;subjectmapping.SubjectConditionSetCreate{ SubjectSets: []*policy.SubjectSet{ { ConditionGroups: []*policy.ConditionGroup{ { BooleanOperator: policy.ConditionBooleanTypeEnum_CONDITION_BOOLEAN_TYPE_ENUM_AND, Conditions: []*policy.Condition{ { SubjectExternalSelectorValue: &quot;.clientId&quot;, Operator: policy.SubjectMappingOperatorEnum_SUBJECT_MAPPING_OPERATOR_ENUM_IN, SubjectExternalValues: []string{&quot;opentdf&quot;}, }, }, }, }, }, }, }, } resp, err := client.SubjectMapping.CreateSubjectConditionSet(context.Background(), conditionset) if err != nil { log.Fatal(err) } log.Printf(&quot;Created Subject Condition Set with ID: %s\\n&quot;, resp.GetSubjectConditionSet().GetId()) } Create Subject Mapping GoJavaJavascript package main import ( &quot;context&quot; &quot;log&quot; &quot;github.com/opentdf/platform/protocol/go/policy&quot; &quot;github.com/opentdf/platform/protocol/go/policy/subjectmapping&quot; &quot;github.com/opentdf/platform/sdk&quot; ) func main() { platformEndpoint := &quot;http://localhost:8080&quot; // Create a new client client, err := sdk.New( platformEndpoint, sdk.WithClientCredentials(&quot;opentdf&quot;, &quot;secret&quot;, nil), ) if err != nil { log.Fatal(err) } // Create Subject Mapping subjectMapping := &amp;subjectmapping.CreateSubjectMappingRequest{ AttributeValueId: &quot;224c9d29-2cd4-4a38-b6ad-5f025ca93a8c&quot;, Actions: []*policy.Action{ { Value: &amp;policy.Action_Standard{ Standard: policy.Action_STANDARD_ACTION_DECRYPT, }, }, }, ExistingSubjectConditionSetId: &quot;890b26db-4ee4-447f-ae8a-2862d922eeef&quot;, } _, err = client.SubjectMapping.CreateSubjectMapping(context.Background(), subjectMapping) if err != nil { log.Fatal(err) } } List Subject Mappings GoJavaJavascript package main import ( &quot;context&quot; &quot;log&quot; &quot;github.com/opentdf/platform/protocol/go/policy/subjectmapping&quot; &quot;github.com/opentdf/platform/sdk&quot; ) func main() { platformEndpoint := &quot;http://localhost:8080&quot; // Create a new client client, err := sdk.New( platformEndpoint, sdk.WithClientCredentials(&quot;opentdf&quot;, &quot;secret&quot;, nil), ) if err != nil { log.Fatal(err) } // List Subject Mapping subjectmappings, err := client.SubjectMapping.ListSubjectMappings(context.Background(), &amp;subjectmapping.ListSubjectMappingsRequest{}) if err != nil { log.Fatal(err) } for _, sm := range subjectmappings.GetSubjectMappings() { log.Printf(&quot;Subject Mapping: %s&quot;, sm.GetId()) } } ","keywords":"","version":"Next"},{"title":"Making Authorization Decisions","type":0,"sectionRef":"#","url":"/pr-172/sdks/authorization","content":"Making Authorization Decisions OpenTDF's authorization system provides two primary methods for access control: Entitlements and Authorization Decisions. Understanding when and how to use each is crucial for implementing effective data security. Overview​ Entitlements vs Decisions​ Entitlements: Answer &quot;What can this entity access?&quot; - Returns all attribute values an entity is entitled to accessDecisions: Answer &quot;Can this entity access this specific resource?&quot; - Returns a permit/deny decision for specific resource access Typical Workflow​ During Resource Discovery: Use GetEntitlements to show users what data they can accessDuring Resource Access: Use GetDecision to enforce access controls when accessing specific resourcesFor Bulk Operations: Use GetDecisionBulk for efficient batch authorization Authentication Setup​ All authorization calls require proper authentication. Here's how to set up the SDK client: GoJavaJavaScript package main import ( &quot;context&quot; &quot;fmt&quot; &quot;log&quot; &quot;github.com/opentdf/platform/protocol/go/authorization&quot; authorizationv2 &quot;github.com/opentdf/platform/protocol/go/authorization/v2&quot; &quot;github.com/opentdf/platform/protocol/go/entity&quot; &quot;github.com/opentdf/platform/protocol/go/policy&quot; &quot;github.com/opentdf/platform/sdk&quot; &quot;google.golang.org/protobuf/proto&quot; ) func main() { platformEndpoint := &quot;http://localhost:8080&quot; // Create authenticated client client, err := sdk.New( platformEndpoint, sdk.WithClientCredentials(&quot;opentdf&quot;, &quot;secret&quot;, nil), ) if err != nil { log.Fatal(err) } // Client is ready for authorization calls } Getting Entitlements​ Use GetEntitlements to discover what attribute values an entity can access. This is useful for: Building user interfaces that show available dataPre-filtering content based on user permissionsUnderstanding an entity's overall access scope Basic Entitlements Query​ GoJavaJavaScript V2 API (Recommended)​ func getEntitlementsV2(client *sdk.SDK) { // Using v2 API with EntityIdentifier entitlementReq := &amp;authorizationv2.GetEntitlementsRequest{ EntityIdentifier: &amp;authorizationv2.EntityIdentifier{ Identifier: &amp;authorizationv2.EntityIdentifier_EntityChain{ EntityChain: &amp;entity.EntityChain{ Entities: []*entity.Entity{ { EphemeralId: &quot;user-bob&quot;, EntityType: &amp;entity.Entity_EmailAddress{ EmailAddress: &quot;bob@OrgA.com&quot;, }, }, }, }, }, }, } entitlements, err := client.AuthorizationV2.GetEntitlements( context.Background(), entitlementReq, ) if err != nil { log.Fatal(err) } // Process entitlements for _, entitlement := range entitlements.GetEntitlements() { fmt.Printf(&quot;Entity has access to: %v\\n&quot;, entitlement.GetActionsPerAttributeValueFqn()) } } V1 API (Legacy)​ func getEntitlementsV1(client *sdk.SDK) { // Using v1 API - note: v1 doesn't have GetEntitlements // Instead, use GetDecisions to understand entity capabilities decisionRequests := []*authorization.DecisionRequest{{ Actions: []*policy.Action{{Name: &quot;read&quot;}}, EntityChains: []*authorization.EntityChain{{ Id: &quot;ec1&quot;, Entities: []*authorization.Entity{{ EntityType: &amp;authorization.Entity_EmailAddress{ EmailAddress: &quot;bob@OrgA.com&quot;, }, Category: authorization.Entity_CATEGORY_SUBJECT, }}, }}, // Query with multiple resource attributes to understand scope ResourceAttributes: []*authorization.ResourceAttribute{{ AttributeValueFqns: []string{ &quot;https://company.com/attr/classification/value/public&quot;, &quot;https://company.com/attr/classification/value/confidential&quot;, }, }}, }} decisionRequest := &amp;authorization.GetDecisionsRequest{ DecisionRequests: decisionRequests, } decisionResponse, err := client.Authorization.GetDecisions( context.Background(), decisionRequest, ) if err != nil { log.Fatal(err) } // Process decisions to understand entitlements for _, dr := range decisionResponse.GetDecisionResponses() { fmt.Printf(&quot;Entity chain %s has decision: %v\\n&quot;, dr.GetEntityChainId(), dr.GetDecision()) } } Entitlements with Scope​ You can limit entitlement queries to specific attribute hierarchies: GoJavaJavaScript // Note: This example uses the v1 API as WithComprehensiveHierarchy is a v1-only feature func getEntitlementsWithScope(client *sdk.SDK) { entitlementReq := &amp;authorization.GetEntitlementsRequest{ EntityIdentifier: &amp;authorization.EntityIdentifier{ EntityChain: &amp;entity.EntityChain{ Entities: []*entity.Entity{ { Id: &quot;user-123&quot;, EntityType: &amp;entity.Entity_EmailAddress{ EmailAddress: &quot;user@company.com&quot;, }, }, }, }, }, // When true, returns all entitled values for attributes with hierarchy rules, propagating down from the entitled value WithComprehensiveHierarchy: proto.Bool(true), } entitlements, err := client.Authorization.GetEntitlements( context.Background(), entitlementReq, ) if err != nil { log.Fatal(err) } log.Printf(&quot;Scoped entitlements: %v&quot;, entitlements.GetEntitlements()) } Making Authorization Decisions​ Use GetDecision when you need to authorize access to specific resources. This is the enforcement point in your application. Single Resource Decision​ GoJavaJavaScript V2 API (Recommended)​ func getDecisionV2(client *sdk.SDK) { decisionReq := &amp;authorizationv2.GetDecisionRequest{ EntityIdentifier: &amp;authorizationv2.EntityIdentifier{ Identifier: &amp;authorizationv2.EntityIdentifier_EntityChain{ EntityChain: &amp;entity.EntityChain{ Entities: []*entity.Entity{ { EphemeralId: &quot;user-123&quot;, EntityType: &amp;entity.Entity_EmailAddress{ EmailAddress: &quot;user@company.com&quot;, }, }, }, }, }, }, Action: &amp;policy.Action{ Name: &quot;decrypt&quot;, }, Resource: &amp;authorizationv2.Resource{ Resource: &amp;authorizationv2.Resource_AttributeValues_{ AttributeValues: &amp;authorizationv2.Resource_AttributeValues{ Fqns: []string{ &quot;https://company.com/attr/classification/value/confidential&quot;, &quot;https://company.com/attr/department/value/finance&quot;, }, }, }, }, } decision, err := client.AuthorizationV2.GetDecision( context.Background(), decisionReq, ) if err != nil { log.Fatal(err) } resDecision := decision.GetDecision() if resDecision.GetDecision() == authorizationv2.Decision_DECISION_PERMIT { fmt.Println(&quot;Access granted&quot;) // Note: ResourceDecision doesn't have obligations in v2 API } else { fmt.Println(&quot;Access denied&quot;) } } V1 API (Legacy)​ func getDecisionV1(client *sdk.SDK) { // V1 API uses bulk decisions decisionRequests := []*authorization.DecisionRequest{{ Actions: []*policy.Action{{ Name: &quot;decrypt&quot;, }}, EntityChains: []*authorization.EntityChain{{ Id: &quot;ec1&quot;, Entities: []*authorization.Entity{{ EntityType: &amp;authorization.Entity_EmailAddress{ EmailAddress: &quot;user@company.com&quot;, }, Category: authorization.Entity_CATEGORY_SUBJECT, }}, }}, ResourceAttributes: []*authorization.ResourceAttribute{{ AttributeValueFqns: []string{ &quot;https://company.com/attr/classification/value/confidential&quot;, &quot;https://company.com/attr/department/value/finance&quot;, }, }}, }} decisionRequest := &amp;authorization.GetDecisionsRequest{ DecisionRequests: decisionRequests, } decisionResponse, err := client.Authorization.GetDecisions( context.Background(), decisionRequest, ) if err != nil { log.Fatal(err) } for _, dr := range decisionResponse.GetDecisionResponses() { if dr.GetDecision() == authorization.DecisionResponse_DECISION_PERMIT { fmt.Println(&quot;Access granted&quot;) // Process any obligations if len(dr.GetObligations()) &gt; 0 { fmt.Printf(&quot;Obligations to fulfill: %v\\n&quot;, dr.GetObligations()) } } else { fmt.Println(&quot;Access denied&quot;) } } } Bulk Authorization Decisions​ For efficient batch processing, use bulk decision endpoints: GoJavaJavaScript V2 API (Recommended)​ func getBulkDecisionsV2(client *sdk.SDK) { bulkReq := &amp;authorizationv2.GetDecisionBulkRequest{ DecisionRequests: []*authorizationv2.GetDecisionMultiResourceRequest{ { EntityIdentifier: &amp;authorizationv2.EntityIdentifier{ Identifier: &amp;authorizationv2.EntityIdentifier_EntityChain{ EntityChain: &amp;entity.EntityChain{ Entities: []*entity.Entity{ { EphemeralId: &quot;user-123&quot;, EntityType: &amp;entity.Entity_EmailAddress{ EmailAddress: &quot;user@company.com&quot;, }, }, }, }, }, }, Action: &amp;policy.Action{Name: &quot;decrypt&quot;}, Resources: []*authorizationv2.Resource{ { EphemeralId: &quot;resource-1&quot;, Resource: &amp;authorizationv2.Resource_AttributeValues_{ AttributeValues: &amp;authorizationv2.Resource_AttributeValues{ Fqns: []string{&quot;https://company.com/attr/class/value/public&quot;}, }, }, }, { EphemeralId: &quot;resource-2&quot;, Resource: &amp;authorizationv2.Resource_AttributeValues_{ AttributeValues: &amp;authorizationv2.Resource_AttributeValues{ Fqns: []string{&quot;https://company.com/attr/class/value/confidential&quot;}, }, }, }, }, }, }, } decisions, err := client.AuthorizationV2.GetDecisionBulk( context.Background(), bulkReq, ) if err != nil { log.Fatal(err) } for _, resp := range decisions.GetDecisionResponses() { allPermitted := resp.GetAllPermitted() if allPermitted != nil { fmt.Printf(&quot;All resources permitted: %v\\n&quot;, allPermitted.GetValue()) } for _, resourceDecision := range resp.GetResourceDecisions() { fmt.Printf(&quot;Resource %s: %v\\n&quot;, resourceDecision.GetEphemeralResourceId(), resourceDecision.GetDecision()) } } } V1 API (Legacy)​ func getBulkDecisionsV1(client *sdk.SDK) { // V1 API uses GetDecisions for bulk processing decisionRequests := []*authorization.DecisionRequest{{ Actions: []*policy.Action{{Name: &quot;decrypt&quot;}}, EntityChains: []*authorization.EntityChain{{ Id: &quot;ec1&quot;, Entities: []*authorization.Entity{{ EntityType: &amp;authorization.Entity_EmailAddress{ EmailAddress: &quot;user@company.com&quot;, }, Category: authorization.Entity_CATEGORY_SUBJECT, }}, }}, ResourceAttributes: []*authorization.ResourceAttribute{ { AttributeValueFqns: []string{&quot;https://company.com/attr/class/value/public&quot;}, }, { AttributeValueFqns: []string{&quot;https://company.com/attr/class/value/confidential&quot;}, }, }, }} decisionRequest := &amp;authorization.GetDecisionsRequest{ DecisionRequests: decisionRequests, } decisionResponse, err := client.Authorization.GetDecisions( context.Background(), decisionRequest, ) if err != nil { log.Fatal(err) } for _, dr := range decisionResponse.GetDecisionResponses() { fmt.Printf(&quot;Entity chain %s: %v\\n&quot;, dr.GetEntityChainId(), dr.GetDecision()) if len(dr.GetObligations()) &gt; 0 { fmt.Printf(&quot;Obligations: %v\\n&quot;, dr.GetObligations()) } } } Entity Types and Authentication​ OpenTDF supports various entity types for flexible authentication: Supported Entity Types​ ClientId: Service-to-service authenticationEmailAddress: User identification via emailUserName: User identification via usernameUUID: Direct entity UUID referenceToken: JWT-based authenticationClaims: Custom claims-based entities Token-Based Authentication Example​ GoJavaJavaScript V2 API (Recommended)​ func getDecisionWithTokenV2(client *sdk.SDK, jwtToken string) { decisionReq := &amp;authorizationv2.GetDecisionRequest{ EntityIdentifier: &amp;authorizationv2.EntityIdentifier{ Identifier: &amp;authorizationv2.EntityIdentifier_Token{ Token: &amp;entity.Token{ EphemeralId: &quot;token-1&quot;, Jwt: jwtToken, }, }, }, Action: &amp;policy.Action{Name: &quot;decrypt&quot;}, Resource: &amp;authorizationv2.Resource{ Resource: &amp;authorizationv2.Resource_AttributeValues_{ AttributeValues: &amp;authorizationv2.Resource_AttributeValues{ Fqns: []string{&quot;https://company.com/attr/classification/value/public&quot;}, }, }, }, } decision, err := client.AuthorizationV2.GetDecision( context.Background(), decisionReq, ) if err != nil { log.Fatal(err) } resDecision := decision.GetDecision() fmt.Printf(&quot;Token-based decision: %v\\n&quot;, resDecision.GetDecision()) } V1 API (Legacy)​ func getDecisionWithTokenV1(client *sdk.SDK, jwtToken string) { // V1 API uses bulk decisions with token entity decisionRequests := []*authorization.DecisionRequest{{ Actions: []*policy.Action{{Name: &quot;decrypt&quot;}}, EntityChains: []*authorization.EntityChain{{ Id: &quot;token-chain&quot;, Entities: []*authorization.Entity{{ EntityType: &amp;authorization.Entity_Token{ Token: &amp;entity.Token{ EphemeralId: &quot;token-1&quot;, Jwt: jwtToken, }, }, Category: authorization.Entity_CATEGORY_SUBJECT, }}, }}, ResourceAttributes: []*authorization.ResourceAttribute{{ AttributeValueFqns: []string{&quot;https://company.com/attr/classification/value/public&quot;}, }}, }} decisionRequest := &amp;authorization.GetDecisionsRequest{ DecisionRequests: decisionRequests, } decisionResponse, err := client.Authorization.GetDecisions( context.Background(), decisionRequest, ) if err != nil { log.Fatal(err) } for _, dr := range decisionResponse.GetDecisionResponses() { fmt.Printf(&quot;Token-based decision: %v\\n&quot;, dr.GetDecision()) if len(dr.GetObligations()) &gt; 0 { fmt.Printf(&quot;Obligations: %v\\n&quot;, dr.GetObligations()) } } } Best Practices​ Performance Optimization​ Batch Operations: Use bulk endpoints for multiple authorization checksCaching: Cache entitlement results when appropriate (consider TTL)Scope Limiting: Use scoped entitlement queries to reduce response size Security Considerations​ Least Privilege: Request only the minimum necessary permissionsToken Validation: Ensure JWT tokens are properly validated before useObligation Handling: Always process and fulfill returned obligationsError Handling: Implement proper error handling and fallback policies Integration Patterns​ // Example: Authorization middleware func authorizationMiddleware(next http.Handler, sdk *sdk.SDK) http.Handler { return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) { // Extract entity from request (JWT, session, etc.) entity := extractEntityFromRequest(r) // Extract resource attributes from the requested resource resourceAttrs := extractResourceAttributes(r.URL.Path) // Make authorization decision decision := makeAuthorizationDecision(sdk, entity, &quot;access&quot;, resourceAttrs) if decision == authorization.DecisionResponse_DECISION_PERMIT { next.ServeHTTP(w, r) } else { http.Error(w, &quot;Access denied&quot;, http.StatusForbidden) } }) } Error Handling​ Always implement comprehensive error handling for authorization calls: Go func safeAuthorizationCall(client *sdk.SDK, req *authorizationv2.GetDecisionRequest) { decision, err := client.AuthorizationV2.GetDecision(context.Background(), req) if err != nil { // Log the error for debugging log.Printf(&quot;Authorization error: %v&quot;, err) // Implement your fallback policy. Choose one of the options below. // Option 1: Deny by default (more secure) handleAccessDenied() return /* // Option 2: Allow by default (less secure, only for non-critical resources) handleAccessAllowed() return */ /* // Option 3: Retry with exponential backoff retryWithBackoff(client, req) return */ } // Process successful response handleDecisionResponse(decision) } ","keywords":"","version":"Next"}],"options":{"id":"default"}}