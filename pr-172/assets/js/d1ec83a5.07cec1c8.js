"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[9787],{98233:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>a,default:()=>h,frontMatter:()=>c,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"spec/concepts/security","title":"Security","description":"OpenTDF is designed with security and tamper evidence as core principles, enabling data-centric protection where security travels with the data itself. This document outlines the key conceptual mechanisms that provide these guarantees.","source":"@site/docs/spec/concepts/security.md","sourceDirName":"spec/concepts","slug":"/spec/concepts/security","permalink":"/pr-172/spec/concepts/security","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2,"title":"Security"},"sidebar":"tutorialSidebar","previous":{"title":"Access Control","permalink":"/pr-172/spec/concepts/access_control"},"next":{"title":"Protocol","permalink":"/pr-172/spec/protocol/"}}');var s=i(74848),r=i(28453);const c={sidebar_position:2,title:"Security"},a="OpenTDF Security Concepts",o={},l=[{value:"1. Payload Encryption",id:"1-payload-encryption",level:2},{value:"2. Payload Integrity Verification",id:"2-payload-integrity-verification",level:2},{value:"3. Policy Binding",id:"3-policy-binding",level:2},{value:"4. Key Splitting (Multi-Party Access Control)",id:"4-key-splitting-multi-party-access-control",level:2},{value:"Summary: Layered Security",id:"summary-layered-security",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"opentdf-security-concepts",children:"OpenTDF Security Concepts"})}),"\n",(0,s.jsx)(n.p,{children:"OpenTDF is designed with security and tamper evidence as core principles, enabling data-centric protection where security travels with the data itself. This document outlines the key conceptual mechanisms that provide these guarantees."}),"\n",(0,s.jsx)(n.h2,{id:"1-payload-encryption",children:"1. Payload Encryption"}),"\n",(0,s.jsxs)(n.p,{children:["The most fundamental layer of protection is ",(0,s.jsx)(n.strong,{children:"payload encryption"}),". The original data within a TDF is encrypted using strong, authenticated symmetric encryption algorithms (typically AES-256-GCM). This ensures the confidentiality of the data \u2013 it cannot be read without the correct decryption key. The management and protection of this decryption key are handled by other mechanisms described below."]}),"\n",(0,s.jsx)(n.h2,{id:"2-payload-integrity-verification",children:"2. Payload Integrity Verification"}),"\n",(0,s.jsxs)(n.p,{children:["While encryption protects confidentiality, it doesn't inherently prevent undetected modification of the ",(0,s.jsx)(n.em,{children:"ciphertext"}),". An attacker could potentially flip bits in the encrypted data. OpenTDF addresses this using the ",(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"integrityInformation"})})," object within the manifest."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Purpose:"})," To allow recipients to verify that the encrypted payload has not been altered since its creation. This is especially critical for streamed data."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Mechanism:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Segmentation:"})," The plaintext payload is processed in chunks (segments)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Segment Hashing/Tagging:"})," As each segment is encrypted (using AES-GCM, for example), a cryptographic integrity tag (like a GMAC) is generated for that encrypted segment using the ",(0,s.jsx)(n.em,{children:"payload encryption key"}),". This tag is stored (as ",(0,s.jsx)(n.code,{children:"hash"}),") in the corresponding ",(0,s.jsx)(n.a,{href:"/pr-172/spec/schema/opentdf/integrity_information#encryptioninformationintegrityinformationsegment",children:"Segment Object"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Root Signature:"})," All the individual segment tags/hashes are concatenated in order. A final HMAC (e.g., HMAC-SHA256) is calculated over this concatenated string of hashes, again using the ",(0,s.jsx)(n.em,{children:"payload encryption key"}),". This result is stored as the ",(0,s.jsx)(n.code,{children:"rootSignature.sig"}),"."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Result:"})," Any modification to even a single bit of the encrypted payload will invalidate the integrity tag of the affected segment ",(0,s.jsx)(n.em,{children:"and"})," consequently invalidate the final ",(0,s.jsx)(n.code,{children:"rootSignature"}),". During decryption, the receiving client MUST verify the integrity tag of each segment and the overall ",(0,s.jsx)(n.code,{children:"rootSignature"}),". Failure indicates tampering."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"3-policy-binding",children:"3. Policy Binding"}),"\n",(0,s.jsxs)(n.p,{children:["It's crucial that the access policy defined for a TDF cannot be detached from the key required to decrypt it. An attacker shouldn't be able to take a wrapped key associated with a strict policy and attach it to a TDF manifest that specifies a weaker policy. The ",(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"policyBinding"})})," object within ",(0,s.jsx)(n.em,{children:"each"})," ",(0,s.jsx)(n.a,{href:"/pr-172/spec/schema/opentdf/key_access_object",children:"Key Access Object"})," prevents this."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Purpose:"})," To cryptographically link the specific access policy (defined in ",(0,s.jsx)(n.code,{children:"encryptionInformation.policy"}),") to a particular wrapped key share held by a specific Key Access Server (KAS)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Mechanism:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["The client retrieves the full, Base64-encoded ",(0,s.jsx)(n.code,{children:"policy"})," string from the ",(0,s.jsx)(n.code,{children:"encryptionInformation"})," section of the manifest it is constructing."]}),"\n",(0,s.jsxs)(n.li,{children:["For ",(0,s.jsx)(n.em,{children:"each"})," key share it prepares to wrap for a specific KAS, the client takes the ",(0,s.jsx)(n.em,{children:"plaintext key share"})," itself."]}),"\n",(0,s.jsxs)(n.li,{children:["It calculates an HMAC (e.g., HMAC-SHA256, specified by ",(0,s.jsx)(n.code,{children:"policyBinding.alg"}),") using the ",(0,s.jsx)(n.strong,{children:"plaintext key share"})," as the secret key and the ",(0,s.jsx)(n.strong,{children:"Base64-encoded policy string"})," as the message data."]}),"\n",(0,s.jsxs)(n.li,{children:["This resulting HMAC hash is Base64 encoded and stored as ",(0,s.jsx)(n.code,{children:"policyBinding.hash"})," within the ",(0,s.jsx)(n.em,{children:"same"})," ",(0,s.jsx)(n.code,{children:"keyAccess"})," object that contains the corresponding wrapped key share."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Result:"})," When a recipient requests key access from a KAS, they provide the ",(0,s.jsx)(n.code,{children:"keyAccess"})," object (including the ",(0,s.jsx)(n.code,{children:"policyBinding"}),"). The KAS decrypts the ",(0,s.jsx)(n.code,{children:"wrappedKey"})," to get the plaintext key share. It then ",(0,s.jsx)(n.em,{children:"recalculates"})," the policy binding HMAC using this key share and the policy string provided (or referenced) in the request. If the calculated hash matches the ",(0,s.jsx)(n.code,{children:"policyBinding.hash"})," received from the client, the KAS knows the policy presented corresponds to the one originally bound to this key share. If they don't match, it indicates tampering or a mismatch, and the KAS MUST deny the request."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"4-key-splitting-multi-party-access-control",children:"4. Key Splitting (Multi-Party Access Control)"}),"\n",(0,s.jsxs)(n.p,{children:["To enhance security and enable multi-party control, OpenTDF supports ",(0,s.jsx)(n.strong,{children:"key splitting"}),". Instead of a single KAS holding the complete (wrapped) key, the key can be divided into multiple shares distributed across different KAS instances."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Purpose:"})," To require authorization from multiple, independent KAS entities before a client can reconstruct the full payload decryption key. This prevents a single compromised KAS from leaking the key and enforces multi-party access control logic."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Mechanism:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"The client generates the payload encryption key."}),"\n",(0,s.jsxs)(n.li,{children:["It splits the key into multiple cryptographic shares (e.g., using XOR with random nonces such that ",(0,s.jsx)(n.code,{children:"Share1 \u2295 Share2 \u2295 ... \u2295 ShareN = FullKey"}),")."]}),"\n",(0,s.jsxs)(n.li,{children:["Each share is treated as an independent key: it's wrapped using the public key of its designated KAS and associated with its own ",(0,s.jsx)(n.a,{href:"#policy-binding",children:"Policy Binding"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["Each wrapped share is stored in a separate ",(0,s.jsx)(n.a,{href:"/pr-172/spec/schema/opentdf/key_access_object",children:"Key Access Object"})," within the ",(0,s.jsx)(n.code,{children:"encryptionInformation.keyAccess"})," array. Crucially, each of these objects is assigned a unique ",(0,s.jsx)(n.strong,{children:"Split ID"})," (",(0,s.jsx)(n.code,{children:"sid"}),")."]}),"\n",(0,s.jsxs)(n.li,{children:["To decrypt, a client must contact ",(0,s.jsx)(n.em,{children:"each"})," KAS responsible for a required share (identified via the ",(0,s.jsx)(n.code,{children:"sid"})," and ",(0,s.jsx)(n.code,{children:"url"}),")."]}),"\n",(0,s.jsxs)(n.li,{children:["Each KAS independently verifies the request against its bound policy (using the ",(0,s.jsx)(n.a,{href:"#policy-binding",children:"Policy Binding"}),")."]}),"\n",(0,s.jsxs)(n.li,{children:["If all necessary KASes grant access, the client receives the unwrapped ",(0,s.jsx)(n.em,{children:"shares"}),"."]}),"\n",(0,s.jsx)(n.li,{children:"The client reconstructs the full payload key by combining the shares (e.g., XORing them together)."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Result:"})," Access requires successfully authenticating and satisfying the policy constraints at ",(0,s.jsx)(n.em,{children:"multiple"})," independent KAS instances. No single KAS holds enough information to decrypt the data alone."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"summary-layered-security",children:"Summary: Layered Security"}),"\n",(0,s.jsx)(n.p,{children:"These mechanisms work together:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Encryption"})," protects confidentiality."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Payload Integrity"})," ensures the encrypted data hasn't been undetectably modified."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Policy Binding"})," ensures the access policy cannot be decoupled from the key access grant for a specific KAS."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Key Splitting"})," enforces multi-party authorization, preventing single points of failure or compromise for key access."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"This layered approach provides robust, data-centric security and tamper evidence for data protected by OpenTDF."})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},28453:(e,n,i)=>{i.d(n,{R:()=>c,x:()=>a});var t=i(96540);const s={},r=t.createContext(s);function c(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:c(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);