"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[2604],{72570:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>a,contentTitle:()=>o,default:()=>h,frontMatter:()=>c,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"components/key_access","title":"Key Access Service","description":"The Key Access Server (KAS) manages the lifecycle of cryptographic keys and provides access to these keys for the encryption and decryption of TDFs. KAS serves as an out-of-the-box Policy Enforcement Point (PEP) for the OpenTDF platform.","source":"@site/docs/components/key_access.md","sourceDirName":"components","slug":"/components/key_access","permalink":"/pr-172/components/key_access","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Entity Resolution Service","permalink":"/pr-172/components/entity_resolution"},"next":{"title":"SDK","permalink":"/pr-172/category/sdk"}}');var i=s(74848),r=s(28453);const c={},o="Key Access Service",a={},l=[{value:"RPC Methods",id:"rpc-methods",level:2},{value:"How Rewrap Works",id:"how-rewrap-works",level:2},{value:"TDF",id:"tdf",level:3}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"key-access-service",children:"Key Access Service"})}),"\n",(0,i.jsxs)(n.p,{children:["The Key Access Server (KAS) manages the lifecycle of cryptographic keys and provides access to these keys for the encryption and decryption of TDFs. KAS serves as an out-of-the-box ",(0,i.jsx)(n.strong,{children:"Policy Enforcement Point (PEP)"})," for the OpenTDF platform."]}),"\n",(0,i.jsx)(n.h2,{id:"rpc-methods",children:"RPC Methods"}),"\n",(0,i.jsx)(n.p,{children:"KAS offers the following RPC methods:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"PublicKey"})," - Retrieves a public key from KAS. It defaults to ",(0,i.jsx)(n.code,{children:"rsa:2048"})," and uses the currently active default key. The key is returned in PEM format by default."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-protobuf",metastring:"reference",children:"https://github.com/opentdf/platform/blob/7dea6407322b5e625ee2810dfcf407c010d9996f/service/kas/kas.proto#L69-L75\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-protobuf",metastring:"reference",children:"https://github.com/opentdf/platform/blob/7dea6407322b5e625ee2810dfcf407c010d9996f/service/kas/kas.proto#L34-L43\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"Rewrap"})," - This method takes a key wrapped using a key retrieved from the ",(0,i.jsx)(n.code,{children:"PublicKey"})," endpoint and rewraps it with a client key. The process succeeds only if the following conditions are met:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"The policy binding is validated."}),"\n",(0,i.jsx)(n.li,{children:"The authorization service confirms that the entity is allowed access to the TDF."}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-protobuf",metastring:"reference",children:"https://github.com/opentdf/platform/blob/7dea6407322b5e625ee2810dfcf407c010d9996f/service/kas/kas.proto#L86-L95\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-protobuf",metastring:"reference",children:"https://github.com/opentdf/platform/blob/7dea6407322b5e625ee2810dfcf407c010d9996f/service/kas/kas.proto#L45-L56\n"})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"how-rewrap-works",children:"How Rewrap Works"}),"\n",(0,i.jsx)(n.h3,{id:"tdf",children:"TDF"}),"\n",(0,i.jsx)("img",{src:"/img/kas_tdf_flow.svg",alt:"KAS TDF Rewrap"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"The client extracts two pieces of information from the TDF:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/spec/schema/opentdf/key_access_object",children:"Key Access Object (KAO)"}),": This contains the wrapped key and the policy binding."]}),"\n",(0,i.jsxs)(n.li,{children:["The ",(0,i.jsx)(n.a,{href:"/spec/schema/opentdf/policy",children:"Policy"})," from the manifest."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"The client generates an ephemeral asymmetric key pair, used to wrap the KAO content (such as an AES encryption key that can access the TDF payload) from KAS."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["The client builds a ",(0,i.jsx)(n.code,{children:"RequestBody"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'{\n  "keyAccess": "<The Key Access Object>",\n  "policy": "<The Policy from the Manifest>",\n  "clientPublicKey": "<The public key created in step 2>"\n}\n'})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["With this ",(0,i.jsx)(n.code,{children:"RequestBody"}),", the client creates a Signed Request Token, which is a JWT signed with the client's DPoP public key or Ephemeral Key Pair."]}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsx)(n.p,{children:'"Demonstration of Proof of Possession" is currently optional due to inconsistencies across identity providers.'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",metastring:'title="Body of JWT"',children:'{\n  "requestBody": "<RequestBody>"\n}\n'})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"At this point, the client is ready to make the rewrap request. The following is an example request body."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",metastring:'title="Signed Request Token"',children:'{\n  "signedRequestToken": "<The JWT>"\n}\n'})}),"\n",(0,i.jsxs)(n.ol,{start:"5",children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["KAS first verifies the policy binding against the policy passed in the ",(0,i.jsx)(n.code,{children:"RequestBody"}),". To do this, KAS unwraps the key to retrieve the symmetric key used to sign the original policy. It then generates the HMAC of the policy and compares it to the policy binding in the KAO. If they match, the policy is valid."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-text",children:"HMAC-SHA256(B64(POLICY), KEY)\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["If the policy is valid and untampered, KAS calls the ",(0,i.jsx)(n.a,{href:"./authorization",children:"Authorization Service"})," to confirm whether the entity is allowed access to the TDF. If authorized, KAS rewraps the symmetric key with the client's public key and returns the newly wrapped key for the client to use in decrypting the TDF."]}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},28453:(e,n,s)=>{s.d(n,{R:()=>c,x:()=>o});var t=s(96540);const i={},r=t.createContext(i);function c(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:c(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);