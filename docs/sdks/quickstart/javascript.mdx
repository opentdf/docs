---
sidebar_position: 3
title: JavaScript/TypeScript
unlisted: true
---

# JavaScript/TypeScript SDK Quickstart

:::tip Back to SDK Quickstart
This guide covers the **JavaScript/TypeScript SDK** implementation. For other languages or general information, see the [SDK Quickstart](/sdks/quickstart) page.
:::

## Prerequisites

- Node.js 18 or later
- npm or yarn
- Your OpenTDF platform running locally (from Getting Started guide)

:::warning Browser Authentication Requirements
The JavaScript SDK is browser-only and cannot use client credentials (client secrets) for security reasons. Instead, you'll need to obtain a refresh token from your OIDC provider. This quickstart shows how to get a token from Keycloak for testing purposes.

For production applications, your web app would obtain tokens through a proper OAuth/OIDC authentication flow.
:::

## Step 1: Get a Refresh Token {#step-1-javascript}

Before you can use the SDK, you need to obtain a refresh token from Keycloak:

```bash
curl -k -X POST 'https://keycloak.opentdf.local:9443/auth/realms/opentdf/protocol/openid-connect/token' \
  -H 'Content-Type: application/x-www-form-urlencoded' \
  -d 'grant_type=password' \
  -d 'client_id=opentdf-public' \
  -d 'username=sample-user' \
  -d 'password=testuser123' \
  -d 'scope=openid'
```

This will return a JSON response. Copy the `refresh_token` value (you'll need it in Step 4).

<details>
<summary>Example response</summary>

```json
{
  "access_token": "eyJhbGc...",
  "expires_in": 300,
  "refresh_expires_in": 1800,
  "refresh_token": "eyJhbGc...",  // Copy this value
  "token_type": "Bearer",
  "scope": "openid email profile"
}
```

</details>

## Step 2: Create a New Project {#step-2-javascript}

Create a new directory and initialize a Node.js project:

```bash
mkdir opentdf-quickstart
cd opentdf-quickstart
npm init -y
```

## Step 3: Install the SDK {#step-3-javascript}

```bash
npm install @opentdf/client
```

Expected output:
> ```console
> added 45 packages, and audited 46 packages in 3s
> ```

## Step 4: Create Your Application {#step-4-javascript}

<details>
<summary>TypeScript Implementation Code</summary>

For **TypeScript** projects, create `quickstart.ts`:

```typescript title="quickstart.ts"
import { AuthProviders, TDF3Client } from '@opentdf/client';

async function main() {
    try {
        console.log("üöÄ Starting OpenTDF SDK Quickstart...");

        const platformEndpoint = "https://platform.opentdf.local:8443";
        const oidcOrigin = "https://keycloak.opentdf.local:9443/auth/realms/opentdf";
        const clientId = "opentdf-public";

        // TODO: Paste your refresh token from Step 1 here
        const refreshToken = "YOUR_REFRESH_TOKEN_HERE";

        console.log("üì° Connecting to platform: " + platformEndpoint);

        // Create authentication provider with refresh token
        console.log("üîê Setting up refresh token authentication...");
        const authProvider = await AuthProviders.refreshAuthProvider({
            clientId,
            refreshToken,
            oidcOrigin,
            exchange: 'refresh',
        });
        console.log("‚úÖ Authentication provider created");

        // Create OpenTDF client
        console.log("üîß Initializing SDK client...");
        const client = new TDF3Client({
            authProvider: authProvider,
            kasEndpoint: platformEndpoint,
        });
        console.log("‚úÖ SDK client initialized successfully");

        // Encrypt data
        console.log("\nüìù Encrypting sensitive data...");
        const sensitiveData = "Hello from the OpenTDF JavaScript SDK! This data is encrypted.";

        console.log("üîí Creating TDF...");
        // Create a ReadableStream from the data
        const source = new ReadableStream({
            start(controller) {
                controller.enqueue(new TextEncoder().encode(sensitiveData));
                controller.close();
            },
        });

        const encryptedStream = await client.encrypt({
            offline: false,
            source: source,
        });

        // Convert encrypted stream to buffer for decryption
        const encryptedBuffer = await new Response(encryptedStream as any).arrayBuffer();
        const encryptedBytes = new Uint8Array(encryptedBuffer);

        console.log("‚úÖ Data successfully encrypted");
        console.log("üìä Encrypted TDF size: " + encryptedBytes.length + " bytes");

        // Decrypt data
        console.log("\nüîì Decrypting TDF...");
        const decryptedStream = await client.decrypt({
            source: { type: 'buffer', location: encryptedBytes },
        });

        const decryptedText = await decryptedStream.toString();

        console.log("‚úÖ Data successfully decrypted");
        console.log("üì§ Decrypted content:\n\n" + decryptedText + "\n");

        console.log("üéâ Quickstart complete!");

    } catch (error) {
        console.error("‚ùå Error occurred:", error);
    }
}

main();
```

</details>

<details>
<summary>JavaScript Implementation Code</summary>

For **JavaScript** projects, create `quickstart.mjs`:

```javascript title="quickstart.mjs"
import { AuthProviders, TDF3Client } from '@opentdf/client';

async function main() {
    try {
        console.log("üöÄ Starting OpenTDF SDK Quickstart...");

        const platformEndpoint = "https://platform.opentdf.local:8443";
        const oidcOrigin = "https://keycloak.opentdf.local:9443/auth/realms/opentdf";
        const clientId = "opentdf-public";

        // TODO: Paste your refresh token from Step 1 here
        const refreshToken = "YOUR_REFRESH_TOKEN_HERE";

        console.log("üì° Connecting to platform: " + platformEndpoint);

        // Create authentication provider with refresh token
        console.log("üîê Setting up refresh token authentication...");
        const authProvider = await AuthProviders.refreshAuthProvider({
            clientId,
            refreshToken,
            oidcOrigin,
            exchange: 'refresh',
        });
        console.log("‚úÖ Authentication provider created");

        // Create OpenTDF client
        console.log("üîß Initializing SDK client...");
        const client = new TDF3Client({
            authProvider: authProvider,
            kasEndpoint: platformEndpoint,
        });
        console.log("‚úÖ SDK client initialized successfully");

        // Encrypt data
        console.log("\nüìù Encrypting sensitive data...");
        const sensitiveData = "Hello from the OpenTDF JavaScript SDK! This data is encrypted.";

        console.log("üîí Creating TDF...");
        // Create a ReadableStream from the data
        const source = new ReadableStream({
            start(controller) {
                controller.enqueue(new TextEncoder().encode(sensitiveData));
                controller.close();
            },
        });

        const encryptedStream = await client.encrypt({
            offline: false,
            source: source,
        });

        // Convert encrypted stream to buffer for decryption
        const encryptedBuffer = await new Response(encryptedStream).arrayBuffer();
        const encryptedBytes = new Uint8Array(encryptedBuffer);

        console.log("‚úÖ Data successfully encrypted");
        console.log("üìä Encrypted TDF size: " + encryptedBytes.length + " bytes");

        // Decrypt data
        console.log("\nüîì Decrypting TDF...");
        const decryptedStream = await client.decrypt({
            source: { type: 'buffer', location: encryptedBytes },
        });

        const decryptedText = await decryptedStream.toString();

        console.log("‚úÖ Data successfully decrypted");
        console.log("üì§ Decrypted content:\n\n" + decryptedText + "\n");

        console.log("üéâ Quickstart complete!");

    } catch (error) {
        console.error("‚ùå Error occurred:", error);
    }
}

main();
```

</details>

## Step 5: Run Your Application {#step-5-javascript}

The JavaScript SDK is designed for browser environments. To run your quickstart code, you'll need to set up a simple web application.

### Create an HTML File

Create `index.html` in your project directory:

```html title="index.html"
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OpenTDF Quickstart</title>
</head>
<body>
    <h1>OpenTDF JavaScript SDK Quickstart</h1>
    <p>Check the browser console for output (F12 or Right-click ‚Üí Inspect ‚Üí Console)</p>
    <script type="module" src="/quickstart.ts"></script>
</body>
</html>
```

### Install and Run Vite Dev Server

Install Vite as a development dependency:

```bash
npm install --save-dev vite
```

Start the development server:

```bash
npx vite
```

Open your browser to `http://localhost:5173` (or the URL shown in the terminal). Open the browser console (F12 or Right-click ‚Üí Inspect ‚Üí Console) to see the output.

<details>
<summary>Expected browser console output</summary>

```console
üöÄ Starting OpenTDF SDK Quickstart...
üì° Connecting to platform: https://platform.opentdf.local:8443
üîê Setting up refresh token authentication...
‚úÖ Authentication provider created
üîß Initializing SDK client...
‚úÖ SDK client initialized successfully

üìù Encrypting sensitive data...
üîí Creating TDF...
‚úÖ Data successfully encrypted
üìä Encrypted TDF size: 1234 bytes

üîì Decrypting TDF...
‚úÖ Data successfully decrypted
üì§ Decrypted content:

Hello from the OpenTDF JavaScript SDK! This data is encrypted.

üéâ Quickstart complete!
```

</details>

---

## Step 6: Add ABAC Features {#step-6-javascript}

:::tip JavaScript-Specific Examples
The following examples are specific to the **JavaScript/TypeScript SDK**.
:::

Now that you have basic encryption working, you can add attribute-based access control to your application.

If you want to follow along, you can add the code to your quickstart file as we go. Otherwise, a [complete version is available below](#complete-example-create-attribute-encrypt-grant-access-and-decrypt).

:::info More ABAC Examples
For additional policy management examples including managing attributes, namespaces, subject mappings, and more, see the [Policy SDK Guide](/sdks/policy).
:::


### Create a New Attribute Value

First, let's create a new attribute value that we can use for access control. If you followed the [Quickstart setup guide](/quickstart), you'll already have an attribute "department" with two values: finance and engineering. Let's add "marketing" to those values:

```typescript
// Get the existing department attribute
const attrFqn = 'https://opentdf.io/attr/department';
const getAttrResponse = await client.attributes.getAttribute({
    fqn: attrFqn,
});

console.log(`‚úÖ Found existing attribute: ${getAttrResponse.attribute.name}`);

// Check if "marketing" value already exists
const targetValue = 'marketing';
const valueExists = getAttrResponse.attribute.values.some(
    (value: any) => value.value === targetValue
);

if (!valueExists) {
    // Add the "marketing" value to the existing attribute
    await client.attributes.createAttributeValue({
        attributeId: getAttrResponse.attribute.id,
        value: targetValue,
    });
    console.log(`‚úÖ Added '${targetValue}' value to department attribute`);
} else {
    console.log(`‚úÖ Attribute 'department' already has '${targetValue}' value`);
}

console.log(`Full attribute FQN: https://opentdf.io/attr/department/value/${targetValue}`);
```

:::warning
If you get a [resource not found error](/sdks/troubleshooting#resource-not-found), you may need to create the "department" attribute, along with the namespace.
:::

### Add Attributes for Access Control

Now that you've created the attribute, update your `encrypt` call to include the attribute for access control:

```typescript
const encryptedStream = await client.encrypt({
    offline: false,
    source: dataBuffer,
    attributes: ["https://opentdf.io/attr/department/value/marketing"],
});
```

:::tip
Only users with the `department/marketing` entitlement will be able to decrypt this TDF. If you try to decrypt before granting access to the attribute, you will see a [permission denied error](/sdks/troubleshooting#permission-denied--insufficient-entitlements). Try it now!
:::

### Grant Yourself Access to the Attribute

To decrypt the TDF you just created, you need to grant yourself the `marketing` entitlement by creating a subject mapping. This connects your identity to the attribute value, giving you permission to access data encrypted with it.

```typescript
// Get the attribute value ID for "marketing"
const attributeValue = getAttrResponse.attribute.values.find(
    (value: any) => value.value === targetValue
);
const attributeValueId = attributeValue.id;

// Create subject condition set that matches your identity
const scsResponse = await client.subjectMapping.createSubjectConditionSet({
    subjectConditionSet: {
        subjectSets: [{
            conditionGroups: [{
                booleanOperator: 'CONDITION_BOOLEAN_TYPE_ENUM_AND',
                conditions: [{
                    subjectExternalSelectorValue: '.clientId',
                    operator: 'SUBJECT_MAPPING_OPERATOR_ENUM_IN',
                    subjectExternalValues: ['opentdf'],
                }],
            }],
        }],
    },
});

// Create the subject mapping to grant yourself the entitlement
await client.subjectMapping.createSubjectMapping({
    attributeValueId: attributeValueId,
    actions: [{ name: 'read' }],
    existingSubjectConditionSetId: scsResponse.subjectConditionSet.id,
});

console.log('‚úÖ Granted yourself access to department/marketing');
```

Now you can decrypt the TDF you encrypted with the `marketing` attribute. üéâ


## Save TDF to a File

In production applications, you'll often need to persist encrypted TDFs to disk for storage, transmission, or archival. This allows you to:

- **Separate encryption from distribution**: Encrypt data once, then share the TDF file through your preferred channels (email, S3, SFTP, etc.)
- **Enable offline access**: Recipients can decrypt TDFs without needing to re-fetch data from your application
- **Archive encrypted data**: Store TDFs in backup systems or long-term storage with their access policies intact

:::note Browser vs Server-Side
The example below shows Node.js file system operations. In a browser environment, you would trigger a download using the browser's download API or save data to IndexedDB. For server-side applications using Node.js, you'll need to handle the SDK's browser dependencies appropriately.
:::

```typescript
import * as fs from 'fs';

// After encryption
fs.writeFileSync('encrypted.tdf', encryptedBytes);

// Later, decrypt from file
const fileData = fs.readFileSync('encrypted.tdf');
const decryptedStream = await client.decrypt({
    source: new Uint8Array(fileData),
});
```

## Handle Large Files with Streaming

:::note Browser vs Server-Side
The example below shows Node.js streaming with the file system. In a browser environment, you would use the File API to read files and trigger downloads for the encrypted output. For server-side applications using Node.js, you'll need to handle the SDK's browser dependencies appropriately.
:::

```typescript
import * as fs from 'fs';
import { Readable } from 'stream';

// Encrypt a large file
const fileStream = fs.createReadStream('large-file.pdf');
const encryptedStream = await client.encrypt({
    offline: false,
    source: fileStream,
});

// Save encrypted stream to file
const writeStream = fs.createWriteStream('large-file.pdf.tdf');
Readable.fromWeb(encryptedStream).pipe(writeStream);
```

## Step 7: Putting it Together {#step-7-javascript}

Here's a complete TypeScript code example that brings all the pieces together:

:::note
This example includes Node.js file system operations (`fs.writeFileSync`, `fs.readFileSync`). In a browser environment, you would use browser APIs for file handling instead.
:::

<details id="complete-example-create-attribute-encrypt-grant-access-and-decrypt">
<summary>Create Attribute, Encrypt, Grant Access, and Decrypt</summary>

```typescript title="complete-example.ts"
import { AuthProviders, TDF3Client } from '@opentdf/client';
import * as fs from 'fs';

async function main() {
    try {
        const platformEndpoint = 'http://localhost:8080';
        const oidcEndpoint = 'http://localhost:8888/realms/opentdf';

        // TODO: Paste your refresh token here
        const refreshToken = "YOUR_REFRESH_TOKEN_HERE";

        // Create authentication provider
        const authProvider = await AuthProviders.refreshAuthProvider({
            clientId: 'opentdf',
            refreshToken,
            oidcOrigin: oidcEndpoint,
            exchange: 'refresh',
        });

        // Create SDK client
        const client = new TDF3Client({
            authProvider: authProvider,
            kasEndpoint: platformEndpoint,
        });

        // 1. Create namespace (or use existing)
        let nsResponse;
        try {
            nsResponse = await client.namespaces.createNamespace({
                name: 'opentdf.io',
            });
            console.log(`‚úÖ Created namespace: ${nsResponse.namespace.id}`);
        } catch (error: any) {
            if (error.message && error.message.includes('already_exists')) {
                // Namespace already exists, fetch it
                const listResponse = await client.namespaces.listNamespaces();
                const existingNs = listResponse.namespaces.find(
                    (ns: any) => ns.name === 'opentdf.io'
                );
                nsResponse = { namespace: existingNs };
                console.log(`‚úÖ Using existing namespace: ${existingNs.id}`);
            } else {
                throw error;
            }
        }

        // 2. Create attribute with marketing value (or use existing)
        let attrResponse;
        try {
            attrResponse = await client.attributes.createAttribute({
                namespaceId: nsResponse.namespace.id,
                name: 'department',
                rule: 'ANY_OF',
                values: ['marketing'],
            });
            console.log(`‚úÖ Created attribute: ${attrResponse.attribute.name}`);
        } catch (error: any) {
            if (error.message && error.message.includes('already_exists')) {
                // Attribute already exists, fetch it
                const listResponse = await client.attributes.listAttributes();
                const existingAttr = listResponse.attributes.find(
                    (attr: any) => attr.name === 'department' && attr.namespace.id === nsResponse.namespace.id
                );
                attrResponse = { attribute: existingAttr };
                console.log(`‚úÖ Using existing attribute: ${existingAttr.name}`);
            } else {
                throw error;
            }
        }

        // 3. Encrypt data with the marketing attribute
        const plaintext = 'Sensitive marketing campaign data';
        const dataBuffer = new TextEncoder().encode(plaintext);

        const encryptedStream = await client.encrypt({
            offline: false,
            source: dataBuffer,
            attributes: ['https://opentdf.io/attr/department/value/marketing'],
        });

        const encryptedBuffer = await new Response(encryptedStream).arrayBuffer();
        const encryptedBytes = new Uint8Array(encryptedBuffer);
        console.log('‚úÖ Data encrypted with marketing attribute');

        // 4. Save TDF to file
        fs.writeFileSync('encrypted.tdf', encryptedBytes);
        console.log('‚úÖ TDF saved to encrypted.tdf');

        // 5. Grant yourself access to the marketing attribute
        const attributeValueId = attrResponse.attribute.values[0].id;

        const scsResponse = await client.subjectMapping.createSubjectConditionSet({
            subjectConditionSet: {
                subjectSets: [{
                    conditionGroups: [{
                        booleanOperator: 'CONDITION_BOOLEAN_TYPE_ENUM_AND',
                        conditions: [{
                            subjectExternalSelectorValue: '.clientId',
                            operator: 'SUBJECT_MAPPING_OPERATOR_ENUM_IN',
                            subjectExternalValues: ['opentdf'],
                        }],
                    }],
                }],
            },
        });

        try {
            await client.subjectMapping.createSubjectMapping({
                attributeValueId: attributeValueId,
                actions: [{ name: 'read' }],
                existingSubjectConditionSetId: scsResponse.subjectConditionSet.id,
            });
            console.log('‚úÖ Granted yourself access to department/marketing');
        } catch (error: any) {
            if (error.message && error.message.includes('already_exists')) {
                console.log('‚úÖ Subject mapping already exists for department/marketing');
            } else {
                throw error;
            }
        }

        // 6. Load TDF from file
        const tdfData = fs.readFileSync('encrypted.tdf');
        console.log('‚úÖ TDF loaded from encrypted.tdf');

        // 7. Decrypt the data
        const decryptedStream = await client.decrypt({
            source: new Uint8Array(tdfData),
        });

        const decryptedText = await new Response(decryptedStream).text();
        console.log('‚úÖ Data successfully decrypted');
        console.log(`üì§ Decrypted content: ${decryptedText}`);
    } catch (error) {
        console.error('‚ùå Error:', error);
        process.exit(1);
    }
}

main();
```

</details>

## Troubleshooting

Having issues? See the **[SDK Troubleshooting](/sdks/troubleshooting)** guide for solutions to common problems.
