---
sidebar_position: 3
title: JavaScript/TypeScript
unlisted: true
---

# JavaScript/TypeScript SDK Quickstart

:::tip Back to SDK Quickstart
This guide covers the **JavaScript/TypeScript SDK** implementation. For other languages or general information, see the [SDK Quickstart](/sdks/quickstart) page.
:::

## Prerequisites

- Node.js 18 or later
- npm or yarn
- Your OpenTDF platform running locally (from Getting Started guide)

## Step 1: Create a New Project {#step-1-javascript}

Create a new directory and initialize a Node.js project:

```bash
mkdir opentdf-quickstart
cd opentdf-quickstart
npm init -y
```

## Step 2: Install the SDK {#step-2-javascript}

```bash
npm install @opentdf/client
```

Expected output:
> ```console
> added 45 packages, and audited 46 packages in 3s
> ```

## Step 3: Create Your Application {#step-3-javascript}

### TypeScript Implementation Code

For **TypeScript** projects, create `quickstart.ts`:

```typescript title="quickstart.ts"
import { AuthProviders, OpenTDF } from '@opentdf/client';

async function main() {
    try {
        console.log("üöÄ Starting OpenTDF SDK Quickstart...");

        const platformEndpoint = "https://platform.opentdf.local:8443";
        const oidcOrigin = "https://keycloak.opentdf.local:9443/realms/opentdf";
        const clientId = "opentdf";
        const clientSecret = "secret";

        console.log("üì° Connecting to platform: " + platformEndpoint);

        // Create authentication provider with client credentials
        console.log("üîê Setting up client credentials authentication...");
        const authProvider = await AuthProviders.clientSecretAuthProvider({
            clientId,
            clientSecret,
            oidcOrigin,
            exchange: 'client',
        });
        console.log("‚úÖ Authentication provider created");

        // Create OpenTDF client
        console.log("üîß Initializing SDK client...");
        const client = new OpenTDF({
            authProvider: authProvider,
            kasEndpoint: platformEndpoint,
        });
        console.log("‚úÖ SDK client initialized successfully");

        // Encrypt data
        console.log("\nüìù Encrypting sensitive data...");
        const sensitiveData = "Hello from the OpenTDF JavaScript SDK! This data is encrypted.";
        const dataBuffer = new TextEncoder().encode(sensitiveData);

        console.log("üîí Creating TDF...");
        const encryptedStream = await client.encrypt({
            offline: false,
            source: dataBuffer,
        });

        // Convert stream to buffer
        const encryptedBuffer = await new Response(encryptedStream).arrayBuffer();
        const encryptedBytes = new Uint8Array(encryptedBuffer);

        console.log("‚úÖ Data successfully encrypted");
        console.log("üìä Encrypted TDF size: " + encryptedBytes.length + " bytes");

        // Decrypt data
        console.log("\nüîì Decrypting TDF...");
        const decryptedStream = await client.decrypt({
            source: encryptedBytes,
        });

        const decryptedText = await new Response(decryptedStream).text();

        console.log("‚úÖ Data successfully decrypted");
        console.log("üì§ Decrypted content:\n\n" + decryptedText + "\n");

        console.log("üéâ Quickstart complete!");
        process.exit(0);

    } catch (error) {
        console.error("‚ùå Error occurred:", error);
        process.exit(1);
    }
}

main();
```

### JavaScript Implementation Code

For **JavaScript** projects, create `quickstart.mjs`:

```javascript title="quickstart.mjs"
import { AuthProviders, OpenTDF } from '@opentdf/client';

async function main() {
    try {
        console.log("üöÄ Starting OpenTDF SDK Quickstart...");

        const platformEndpoint = "https://platform.opentdf.local:8443";
        const oidcOrigin = "https://keycloak.opentdf.local:9443/realms/opentdf";
        const clientId = "opentdf";
        const clientSecret = "secret";

        console.log("üì° Connecting to platform: " + platformEndpoint);

        // Create authentication provider with client credentials
        console.log("üîê Setting up client credentials authentication...");
        const authProvider = await AuthProviders.clientSecretAuthProvider({
            clientId,
            clientSecret,
            oidcOrigin,
            exchange: 'client',
        });
        console.log("‚úÖ Authentication provider created");

        // Create OpenTDF client
        console.log("üîß Initializing SDK client...");
        const client = new OpenTDF({
            authProvider: authProvider,
            kasEndpoint: platformEndpoint,
        });
        console.log("‚úÖ SDK client initialized successfully");

        // Encrypt data
        console.log("\nüìù Encrypting sensitive data...");
        const sensitiveData = "Hello from the OpenTDF JavaScript SDK! This data is encrypted.";
        const dataBuffer = new TextEncoder().encode(sensitiveData);

        console.log("üîí Creating TDF...");
        const encryptedStream = await client.encrypt({
            offline: false,
            source: dataBuffer,
        });

        // Convert stream to buffer
        const encryptedBuffer = await new Response(encryptedStream).arrayBuffer();
        const encryptedBytes = new Uint8Array(encryptedBuffer);

        console.log("‚úÖ Data successfully encrypted");
        console.log("üìä Encrypted TDF size: " + encryptedBytes.length + " bytes");

        // Decrypt data
        console.log("\nüîì Decrypting TDF...");
        const decryptedStream = await client.decrypt({
            source: encryptedBytes,
        });

        const decryptedText = await new Response(decryptedStream).text();

        console.log("‚úÖ Data successfully decrypted");
        console.log("üì§ Decrypted content:\n\n" + decryptedText + "\n");

        console.log("üéâ Quickstart complete!");
        process.exit(0);

    } catch (error) {
        console.error("‚ùå Error occurred:", error);
        process.exit(1);
    }
}

main();
```

## Step 4: Run Your Application {#step-4-javascript}

For TypeScript:
```bash
npx tsx quickstart.ts
```

For JavaScript:
```bash
node quickstart.mjs
```

<details>
<summary>Expected output</summary>

```console
üöÄ Starting OpenTDF SDK Quickstart...
üì° Connecting to platform: https://platform.opentdf.local:8443
üîê Setting up client credentials authentication...
‚úÖ Authentication provider created
üîß Initializing SDK client...
‚úÖ SDK client initialized successfully

üìù Encrypting sensitive data...
üîí Creating TDF...
‚úÖ Data successfully encrypted
üìä Encrypted TDF size: 1234 bytes

üîì Decrypting TDF...
‚úÖ Data successfully decrypted
üì§ Decrypted content:

Hello from the OpenTDF JavaScript SDK! This data is encrypted.

üéâ Quickstart complete!
```

</details>

---

## Step 5: Add ABAC Features {#step-5-javascript}

:::tip JavaScript-Specific Examples
The following examples are specific to the **JavaScript/TypeScript SDK**.
:::

Now that you have basic encryption working, you can add attribute-based access control to your application.

If you want to follow along, you can add the code to your quickstart file as we go. Otherwise, a [complete version is available below](#complete-example-create-attribute-encrypt-grant-access-and-decrypt).

:::info More ABAC Examples
For additional policy management examples including managing attributes, namespaces, subject mappings, and more, see the [Policy SDK Guide](/sdks/policy).
:::


### Create a New Attribute Value

First, let's create a new attribute value that we can use for access control. If you followed the [Quickstart setup guide](/quickstart), you'll already have an attribute "department" with two values: finance and engineering. Let's add "marketing" to those values:

```typescript
// Get the existing department attribute
const attrFqn = 'https://opentdf.io/attr/department';
const getAttrResponse = await client.attributes.getAttribute({
    fqn: attrFqn,
});

console.log(`‚úÖ Found existing attribute: ${getAttrResponse.attribute.name}`);

// Check if "marketing" value already exists
const targetValue = 'marketing';
const valueExists = getAttrResponse.attribute.values.some(
    (value: any) => value.value === targetValue
);

if (!valueExists) {
    // Add the "marketing" value to the existing attribute
    await client.attributes.createAttributeValue({
        attributeId: getAttrResponse.attribute.id,
        value: targetValue,
    });
    console.log(`‚úÖ Added '${targetValue}' value to department attribute`);
} else {
    console.log(`‚úÖ Attribute 'department' already has '${targetValue}' value`);
}

console.log(`Full attribute FQN: https://opentdf.io/attr/department/value/${targetValue}`);
```

:::warning
If you get a [resource not found error](/sdks/troubleshooting#resource-not-found), you may need to create the "department" attribute, along with the namespace.
:::

### Add Attributes for Access Control

Now that you've created the attribute, update your `encrypt` call to include the attribute for access control:

```typescript
const encryptedStream = await client.encrypt({
    offline: false,
    source: dataBuffer,
    attributes: ["https://opentdf.io/attr/department/value/marketing"],
});
```

:::tip
Only users with the `department/marketing` entitlement will be able to decrypt this TDF. If you try to decrypt before granting access to the attribute, you will see a [permission denied error](/sdks/troubleshooting#permission-denied--insufficient-entitlements). Try it now!
:::

### Grant Yourself Access to the Attribute

To decrypt the TDF you just created, you need to grant yourself the `marketing` entitlement by creating a subject mapping. This connects your identity to the attribute value, giving you permission to access data encrypted with it.

```typescript
// Get the attribute value ID for "marketing"
const attributeValue = getAttrResponse.attribute.values.find(
    (value: any) => value.value === targetValue
);
const attributeValueId = attributeValue.id;

// Create subject condition set that matches your identity
const scsResponse = await client.subjectMapping.createSubjectConditionSet({
    subjectConditionSet: {
        subjectSets: [{
            conditionGroups: [{
                booleanOperator: 'CONDITION_BOOLEAN_TYPE_ENUM_AND',
                conditions: [{
                    subjectExternalSelectorValue: '.clientId',
                    operator: 'SUBJECT_MAPPING_OPERATOR_ENUM_IN',
                    subjectExternalValues: ['opentdf'],
                }],
            }],
        }],
    },
});

// Create the subject mapping to grant yourself the entitlement
await client.subjectMapping.createSubjectMapping({
    attributeValueId: attributeValueId,
    actions: [{ name: 'read' }],
    existingSubjectConditionSetId: scsResponse.subjectConditionSet.id,
});

console.log('‚úÖ Granted yourself access to department/marketing');
```

Now you can decrypt the TDF you encrypted with the `marketing` attribute. üéâ


## Save TDF to a File

In production applications, you'll often need to persist encrypted TDFs to disk for storage, transmission, or archival. This allows you to:

- **Separate encryption from distribution**: Encrypt data once, then share the TDF file through your preferred channels (email, S3, SFTP, etc.)
- **Enable offline access**: Recipients can decrypt TDFs without needing to re-fetch data from your application
- **Archive encrypted data**: Store TDFs in backup systems or long-term storage with their access policies intact

```typescript
import * as fs from 'fs';

// After encryption
fs.writeFileSync('encrypted.tdf', encryptedBytes);

// Later, decrypt from file
const fileData = fs.readFileSync('encrypted.tdf');
const decryptedStream = await client.decrypt({
    source: new Uint8Array(fileData),
});
```

## Handle Large Files with Streaming

```typescript
import * as fs from 'fs';
import { Readable } from 'stream';

// Encrypt a large file
const fileStream = fs.createReadStream('large-file.pdf');
const encryptedStream = await client.encrypt({
    offline: false,
    source: fileStream,
});

// Save encrypted stream to file
const writeStream = fs.createWriteStream('large-file.pdf.tdf');
Readable.fromWeb(encryptedStream).pipe(writeStream);
```

## Step 6: Putting it Together {#step-6-javascript}

Here's a complete TypeScript code example that brings all the pieces together:

<details id="complete-example-create-attribute-encrypt-grant-access-and-decrypt">
<summary>Create Attribute, Encrypt, Grant Access, and Decrypt</summary>

```typescript title="complete-example.ts"
import { AuthProviders, OpenTDF } from '@opentdf/client';
import * as fs from 'fs';

async function main() {
    try {
        const platformEndpoint = 'http://localhost:8080';
        const oidcEndpoint = 'http://localhost:8888/realms/opentdf';

        // Create authentication provider
        const authProvider = await AuthProviders.clientSecretAuthProvider({
            clientId: 'opentdf',
            clientSecret: 'secret',
            oidcOrigin: oidcEndpoint,
            exchange: 'client',
        });

        // Create SDK client
        const client = new OpenTDF({
            authProvider: authProvider,
            platformUrl: platformEndpoint,
        });

        // 1. Create namespace (or use existing)
        let nsResponse;
        try {
            nsResponse = await client.namespaces.createNamespace({
                name: 'opentdf.io',
            });
            console.log(`‚úÖ Created namespace: ${nsResponse.namespace.id}`);
        } catch (error: any) {
            if (error.message && error.message.includes('already_exists')) {
                // Namespace already exists, fetch it
                const listResponse = await client.namespaces.listNamespaces();
                const existingNs = listResponse.namespaces.find(
                    (ns: any) => ns.name === 'opentdf.io'
                );
                nsResponse = { namespace: existingNs };
                console.log(`‚úÖ Using existing namespace: ${existingNs.id}`);
            } else {
                throw error;
            }
        }

        // 2. Create attribute with marketing value (or use existing)
        let attrResponse;
        try {
            attrResponse = await client.attributes.createAttribute({
                namespaceId: nsResponse.namespace.id,
                name: 'department',
                rule: 'ANY_OF',
                values: ['marketing'],
            });
            console.log(`‚úÖ Created attribute: ${attrResponse.attribute.name}`);
        } catch (error: any) {
            if (error.message && error.message.includes('already_exists')) {
                // Attribute already exists, fetch it
                const listResponse = await client.attributes.listAttributes();
                const existingAttr = listResponse.attributes.find(
                    (attr: any) => attr.name === 'department' && attr.namespace.id === nsResponse.namespace.id
                );
                attrResponse = { attribute: existingAttr };
                console.log(`‚úÖ Using existing attribute: ${existingAttr.name}`);
            } else {
                throw error;
            }
        }

        // 3. Encrypt data with the marketing attribute
        const plaintext = 'Sensitive marketing campaign data';
        const dataBuffer = new TextEncoder().encode(plaintext);

        const encryptedStream = await client.encrypt({
            offline: false,
            source: dataBuffer,
            attributes: ['https://opentdf.io/attr/department/value/marketing'],
        });

        const encryptedBuffer = await new Response(encryptedStream).arrayBuffer();
        const encryptedBytes = new Uint8Array(encryptedBuffer);
        console.log('‚úÖ Data encrypted with marketing attribute');

        // 4. Save TDF to file
        fs.writeFileSync('encrypted.tdf', encryptedBytes);
        console.log('‚úÖ TDF saved to encrypted.tdf');

        // 5. Grant yourself access to the marketing attribute
        const attributeValueId = attrResponse.attribute.values[0].id;

        const scsResponse = await client.subjectMapping.createSubjectConditionSet({
            subjectConditionSet: {
                subjectSets: [{
                    conditionGroups: [{
                        booleanOperator: 'CONDITION_BOOLEAN_TYPE_ENUM_AND',
                        conditions: [{
                            subjectExternalSelectorValue: '.clientId',
                            operator: 'SUBJECT_MAPPING_OPERATOR_ENUM_IN',
                            subjectExternalValues: ['opentdf'],
                        }],
                    }],
                }],
            },
        });

        try {
            await client.subjectMapping.createSubjectMapping({
                attributeValueId: attributeValueId,
                actions: [{ name: 'read' }],
                existingSubjectConditionSetId: scsResponse.subjectConditionSet.id,
            });
            console.log('‚úÖ Granted yourself access to department/marketing');
        } catch (error: any) {
            if (error.message && error.message.includes('already_exists')) {
                console.log('‚úÖ Subject mapping already exists for department/marketing');
            } else {
                throw error;
            }
        }

        // 6. Load TDF from file
        const tdfData = fs.readFileSync('encrypted.tdf');
        console.log('‚úÖ TDF loaded from encrypted.tdf');

        // 7. Decrypt the data
        const decryptedStream = await client.decrypt({
            source: new Uint8Array(tdfData),
        });

        const decryptedText = await new Response(decryptedStream).text();
        console.log('‚úÖ Data successfully decrypted');
        console.log(`üì§ Decrypted content: ${decryptedText}`);
    } catch (error) {
        console.error('‚ùå Error:', error);
        process.exit(1);
    }
}

main();
```

</details>

## Troubleshooting

Having issues? See the **[SDK Troubleshooting](/sdks/troubleshooting)** guide for solutions to common problems.
