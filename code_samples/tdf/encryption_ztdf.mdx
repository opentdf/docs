import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

<details>
<summary>Encrypting / Decrypting zTDF</summary>
<Tabs>
<TabItem value="go" label="Go">

```go
package main

import (
	"bytes"
	"log"
	"strings"

	"github.com/opentdf/platform/sdk"
)

func main() {
	log.Println("üöÄ Starting OpenTDF example...")

	platformEndpoint := "http://localhost:9002"
	log.Printf("üì° Connecting to platform: %s", platformEndpoint)

	// Create a new client
	log.Println("üîê Initializing new SDK client...")
	client, err := sdk.New(
		platformEndpoint,
		sdk.WithClientCredentials("opentdf", "secret", nil),
	)

	if err != nil {
		log.Fatalf("‚ùå Client initialization failed: %v", err)
	}

	// Encrypt ztdf
	log.Println("üìù Preparing sensitive data for encryption...")
	str := strings.NewReader("Sensitive data!")
	buf := &bytes.Buffer{}

	log.Println("üîí Encrypting data...")
	manifest, err := client.CreateTDF(buf, str,
		//sdk.WithDataAttributes("https://opentdf.io/attr/role/value/developer"),
		sdk.WithKasInformation(
			sdk.KASInfo{
				URL: platformEndpoint,
			},
		),
	)

	if err != nil {
		log.Fatalf("‚ùå Encryption failed: %v", err)
	}

	log.Println("‚úÖ Data successfully encrypted")
	log.Printf("üìã TDF Manifest details:\n\n%v\n\n", manifest)

	// Decrypt ztdf
	log.Println("üîì Decrypting data...")
	tdfReader, err := client.LoadTDF(bytes.NewReader(buf.Bytes()))
	if err != nil {
		log.Fatalf("‚ùå Decryption failed: %v", err)
	}

	// Create a buffer to capture the decrypted data
	var decryptedBuf bytes.Buffer
	if _, err = tdfReader.WriteTo(&decryptedBuf); err != nil {
		log.Fatalf("‚ùå Failed to write decrypted data: %v", err)
	}

	log.Printf("üì§ Decrypted content: \n\n%s\n\n", decryptedBuf.String())
	log.Println("‚úÖ Example complete!")
}
```

</TabItem>
<TabItem value="java" label="Java">

```java
package io.opentdf.platform;

import io.opentdf.platform.sdk.*;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;

import java.io.IOException;
import java.nio.file.StandardOpenOption;
import java.nio.channels.FileChannel;
import java.nio.file.Path;

public class EncryptExample {

    public static void main(String[] args) {
        try {
            System.out.println("üöÄ Starting OpenTDF example...");
            
            String clientId = "opentdf";
            String clientSecret = "secret";
            String platformEndpoint = "http://localhost:8080";
            
            System.out.println("üì° Connecting to platform: " + platformEndpoint);
            
            // Create a new client
            System.out.println("üîê Initializing new SDK client...");
            SDKBuilder builder = SDKBuilder.newBuilder();
            SDK sdk = builder.platformEndpoint(platformEndpoint)
                    .clientSecret(clientId, clientSecret)
                    .useInsecurePlaintextConnection(true) // Set to true for http:// connections
                    .build();
            
            // Encrypt TDF
            System.out.println("üìù Preparing sensitive data for encryption...");
            String sensitiveData = "Sensitive data!";
            
            var kasInfo = new Config.KASInfo();
            kasInfo.URL = platformEndpoint + "/kas";
            
            var tdfConfig = Config.newTDFConfig(Config.withKasInformation(kasInfo));
            
            var inputStream = new ByteArrayInputStream(sensitiveData.getBytes(StandardCharsets.UTF_8));
            var outputStream = new ByteArrayOutputStream();
            
            System.out.println("üîí Encrypting data...");
            sdk.createTDF(inputStream, outputStream, tdfConfig);
            
            System.out.println("‚úÖ Data successfully encrypted");
            System.out.println("üìã TDF created with " + outputStream.size() + " bytes");
            
            // Decrypt TDF
            System.out.println("üîì Decrypting data...");
            var encryptedData = outputStream.toByteArray();
            
            // Save to temporary file for decryption
            Path tempFile = Files.createTempFile("encrypted", ".tdf");
            try {                
                Files.write(tempFile, encryptedData);
                
                try (var fileChannel = FileChannel.open(tempFile, StandardOpenOption.READ)) {
                    var readerConfig = Config.newTDFReaderConfig();
                    var reader = sdk.loadTDF(fileChannel, readerConfig);
                    var decryptedOutput = new ByteArrayOutputStream();
                    reader.readPayload(decryptedOutput);
                    
                    String decryptedContent = new String(decryptedOutput.toByteArray(), StandardCharsets.UTF_8);
                    System.out.println("üì§ Decrypted content: \n\n" + decryptedContent + "\n");
                }
            } catch (Exception e) {
                // Clean up
                Files.deleteIfExists(tempFile);
            }
            
            System.out.println("‚úÖ Example complete!");
        } catch (IOException | AutoConfigureException e) {
            System.err.println("‚ùå Error occurred: " + e.getMessage());
            e.printStackTrace();
        }
    }
}
```

</TabItem>
<TabItem value="js" label="Typescript">

```typescript
import { AuthProviders, NanoTDFClient } from '@opentdf/sdk';

// Configuration Options
const kasEndpoint = "https://kas.example.com";

// Authentication options (vary by middleware)
const oidcOrigin = "https://idp.example.com";
const clientId = "applicationNameFromIdP";
const refreshToken = "userRefreshTokenValueFromIdP";

// AuthProviders are middlewares that add `Authorization` or other bearer tokens to requests.
// These include The `refresh` provider can be handed a refresh and optional access token.
const authProvider = await AuthProviders.refreshAuthProvider({
  clientId,
  exchange: 'refresh',
  refreshToken,
  oidcOrigin,
});

const client = new TDF3Client({
  authProvider,
  kasEndpoint,
});

// ABAC
const attributes = ["http://example.com/attr/classification/value/secret"]

// encrypt
const source = new ReadableStream({
    pull(controller) {
      controller.enqueue(new TextEncoder().encode(string));
      controller.close();
    },
});
const ciphertextStream = await client.encrypt({ offline: true, source, scope: {attributes} });

// decrypt
const plaintextStream = await client.decrypt({
    source: { type: 'stream', location: ciphertextStream }
});
const plaintext = await plaintextStream.toString();
```

</TabItem>
</Tabs>
</details>